 Librarian A09-19                                                                
 Directory of TEXT library CARS3$DKA200:[MERON.MIDL]MIDL_LIB.TLB;1 on  2-OCT-1999
 Creation date:   2-OCT-1999 16:01:32      Creator:  Librarian A09-19            
 Revision date:   2-OCT-1999 18:50:32      Library format:   3.0                 
 Number of modules:    112                 Max. key length:  39                  
 Other entries:          0                 Preallocated index blocks:     11     
 Recoverable deleted blocks:      5        Total index blocks used:        6     
 Max. Number history records:      20      Library history records:       20     
                                                                                 
   1  ABGRAD
   2  ABS_MM
   3  ARC
   4  ARREQ
   5  ARRLOC
   6  ARRO
   7  ASP_CORR
   8  BESELK
   9  BESELK_MM
  10  BOX
  11  CAST
  12  CHEBYSHEV_POL
  13  CIRCLE
  14  CONFRAC
  15  CONSTANTS
  16  CONVOL_MM
  17  COO_CONV
  18  COSANGLE
  19  DEFAULT
  20  DEGLITCH
  21  DIAGOARR
  22  DIAGOVEC
  23  ELLIPSE
  24  ERRBARS
  25  ERRORF_MM
  26  EXTEND_ARRAY
  27  EXTREMA
  28  FPU_FIX
  29  FRESNEL_INT
  30  GAMMA_MM
  31  HEAD
  32  HOW_MANY
  33  IGAMMA_MM
  34  IMAGINARY_MM
  35  INTEG
  36  ISNUM
  37  LABELS
  38  LAPLACIAN
  39  LEGENDRE_POL
  40  LINCROSS
  41  LINFIT_MM
  42  LNGAMMA_MM
  43  MAKE_GRID
  44  M_ABS
  45  M_CONVOL
  46  M_ERRORF
  47  M_GAMMA
  48  M_IGAMMA
  49  M_IMAGINARY
  50  M_LINFIT
  51  M_LNGAMMA
  52  M_NERFC
  53  M_REAL
  54  M_SMOOTH
  55  NATAN
  56  NEIGHBORS
  57  NERFC_MM
  58  NOISE
  59  OBSTAT
  60  ONE_OF
  61  OUTPUT
  62  PARTOT
  63  PLOTOT
  64  PLOT_VER2
  65  PLVAR_KEEP
  66  POLEVAL
  67  PRINUMS
  68  RANDISC
  69  RASCII
  70  REAL_MM
  71  RECTAN
  72  ROMBERG
  73  ROOT
  74  SEQLIM
  75  SERIES_SUM
  76  SHAPE_AREA
  77  SHAPE_CLOSE
  78  SHAPE_COCON
  79  SHAPE_EDGE
  80  SHAPE_OVERLAP
  81  SHAPE_TRANS
  82  SHAPE_VER
  83  SHUFFLE
  84  SIGN
  85  SMOOTH_MM
  86  SOLVE_LINSYS
  87  SORPURGE
  88  SPLINROOT
  89  SPLINT
  90  SPLIN_COEFFS
  91  SPLIN_EVAL
  92  SP_BESELJ
  93  SP_BESELY
  94  SQUARE
  95  SQUNEXP
  96  SQUNORM
  97  STREQ
  98  STRMATCH
  99  STRMATCH_MM
 100  STRPARSE
 101  STRPARSE_MM
 102  TABULATE
 103  TAIL
 104  TOLER
 105  TYPE
 106  UNIVEC
 107  VINP
 108  VNORM
 109  VOUP
 110  WASCII
 111  WHERINSTRUCT
 112  WIGGLINE
1
                                 *** ABGRAD ***                          

 Function Abgrad, arr, delta
 
 ;+
 ; NAME:
 ;	ABGRAD
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the absolute value of the gradient of a function represented
 ;	as an array of values.  Works for 1-7 dimensions.
 ; CATEGORY:
 ;	Array Manipulation.
 ; CALLING SEQUENCE:
 ;	Result = ABGRAD( ARR [, DELTA])
 ; INPUTS:
 ;    ARR
 ;	Array, numeric, number of dimensions can be 1 through 7.
 ; OPTIONAL INPUT PARAMETERS:
 ;    DELTA
 ;	Size of step used to calculate the numeric derivatives.  The approx.
 ;	partial derivative in the i-th direction is calculated as
 ;	    (ARR(...,I + DELTA,...) - ARR(...,I - DELTA,...))/(2*DELTA).
 ;	The default value of DELTA is 1l.  If provided, it is rounded to a long
 ;	integer on input.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the absolute value of the gradient as an array of the same size
 ;	and type as ARR.  If ARR is not an array, returns 0.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	Due to current limitations of the MAKE_ARRAY system routine, 8
 ;	dimensions are not allowed.
 ; PROCEDURE:
 ;	Creates an 7-dimensional array, with dummy leading dimensions,
 ;	containing the original array.  Generates the differences using the
 ;	SHIFT system routine and strips the dummy dimensions at the end.
 ;	Uses the functions DEFAULT and FPU_FIX from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-NOV-1991 by Mati Meron.
 ;	Modified 30-AUG-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     ndmx = 7
     idel = abs(Default(delta,1l,/dtype))
     siz = size(arr)
     ndm = siz(0)
     if ndm eq 0 then begin
 	message, 'Not an Array!', /continue
 	return, 0
     endif else if ndm lt ndmx then siz = [ndmx,replicate(1,ndmx-ndm),siz(1:*)]
     res = make_array(size = siz)
     tarr = make_array(size = siz) + arr
 
     a = intarr(ndmx)
     for i = ndmx - ndm, ndmx - 1 do begin
 	a(i) = idel
 	b = - a
 	if 2*idel mod siz(i+1) ne 0 then res = res + $
 	abs(shift(tarr,a(0),a(1),a(2),a(3),a(4),a(5),a(6)) - $
 	shift(tarr,b(0),b(1),b(2),b(3),b(4),b(5),b(6)))^2
 	a(i) = 0
     endfor
 
     res = Fpu_fix(res)
     return, sqrt(reform(res,siz(ndmx-ndm+1:ndmx)))/(2.*idel)
 end
 
                                 *** ABS_MM ***                          

 Function Abs_mm, x
 
 ;+
 ; NAME:
 ;	ABS_MM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates absolute values.  A temporary fix needed since the IDL ABS
 ;	function fails with very large or very small complex numbers.
 ; CATEGORY:
 ;	Mathematical, general.
 ; CALLING SEQUENCE:
 ;	Result = ABS_MM (X)
 ; INPUTS:
 ;    X
 ;	Numerical, otherwise arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the absolute value of the input.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Calling FPU_FIX and ISNUM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-MAR-1996 by Mati Meron as M_ABS.
 ;	Modified 30-AUG-1998 by Mati Meron.  Underflow filtering added.
 ;	Renamed 25-SEP-1999 by Mati Meron, to ABS_MM.
 ;-
 
     on_error, 1
     if Isnum(x, /complex, type = xtyp) then begin
 	res = make_array(size = size([x]), type = xtyp/2 + 1)
 	w = where (x ne 0, nw)
 	if nw gt 0 then begin
 	    tem = abs(double(x(w))) > abs(imaginary(x(w)))
 	    res(w) = tem*abs(complex(double(x(w))/tem,imaginary(x(w))/tem))
 	endif
     endif else res = abs(x)
     res = Fpu_fix(res,/no_abs)
 
     if (size(x))(0) eq 0 then return, res(0) else return, res
 end
 
                                  *** ARC ***                             

 Pro Arc, r1, r2, center = cent, radius = rad, angle = ang, degrees = deg, $
     bigarc = big, symmetric= sym, no_show = nsh, shapeout = parc, _extra = _e
 
 ;+
 ; NAME:
 ;	ARC
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Draws a circular arc in the currently defined plot area.
 ;	Alternatively, a *SHAPE* representation (see SHAPE_VER for definition)
 ;	of the arc may be returned through the SHAPEOUT keyword.  DATA
 ;	coordinates are used.  The method of drawing depends on the number of
 ;	input parameters provided (see details in CALLING SEQUENCE below).
 ; CATEGORY:
 ;	General Graphics.
 ; CALLING SEQUENCE:
 ;	There are two possible modes of operation, and accordingly two
 ;	different calling sequences:
 ;	Mode 1:
 ;	    ARC, R1, CENTER = CENT, ANGLE = ANG [, optional keywords]
 ;	In this mode an arc with angular measure ANG is drawn around the point
 ;	CENT, in the mathematical-positive direction, starting from point R1.
 ;	Mode 2:
 ;	    ARC, R1, R2, {RADIUS = RAD, ANGLE = ANG} [, optional keywords]
 ;	In this mode the arc is drawn in the mathematical-positive direction,
 ;	from point R1 to point R2.  The arc is either drawn with radius RAD, or
 ;	corresponding to an angle ANG (both RAD and ANG cannot be specified).
 ; INPUTS:
 ;    R1, R2
 ;	2-dimensional vectors in the [x,y] format, representing points in the
 ;	plotting area.  R1 is mandatory.  The presence of R2 indicates that
 ;	Mode 2 is being used.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    CENTER
 ;	2 dimensional vector, arc center location, format [x,y].
 ;	Mandatory in Mode 1, forbidden in Mode 2.
 ;    RADIUS
 ;	Scalar, the radius of the arc.		|
 ;	Forbidden in Mode 1, allowed in Mode 2.	|  In Mode 2
 ;    ANGLE					|  one and only one
 ;	Scalar, the angle measure of the arc.	|  needs to be provided.
 ;	Mandatory in Mode 1, allowed in Mode 2. |
 ;    /DEGREES
 ;	Switch.  Indicates that the angle ANG is given in degrees (default is
 ;	radians).
 ;    /BIGARC
 ;	Switch.  When drawing in Mode 2, with the radius provided, there are two
 ;	possible arcs that can be drawn,  corresponding to angles smaller and
 ;	bigger than 180 degrees (the sum of both angles is 360 degrees).  By
 ;	default the smaller arc is drawn. Setting BIGARC selects the bigger arc.
 ;    /SYMMETRIC
 ;	Switch.  In Mode 1 causes the arc to be drawn symmetrically on both
 ;	sides of R1.  Forbidden in Mode 2.
 ;    /NO_SHOW
 ;	Switch.  If set, no plotting is done, but the shape is generated and
 ;	may be returned through SHAPEOUT.
 ;    SHAPEOUT
 ;	Optional output, see below.
 ;    _EXTRA
 ;       A formal keyword used to pass all plotting keywords.  Not to be used
 ;       directly.
 ; OUTPUTS:
 ;	None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    SHAPEOUT
 ;	When provided with the name of a variable, on return the variable
 ;	contains the *SHAPE* representation of the arc.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	The arc will appear as a true circular arc only if the aspect ratio of
 ;	the X to Y axes is 1:1.
 ;	The keywords passed through _EXTRA are transferred to the PLOTS
 ;	routine.  No keyword verification is performed by ARC.
 ; PROCEDURE:
 ;	Uses calls to ONE_OF and SHAPE_COCON from MIDL.
 ;	Generates a (2,N) array containing a sufficient number of the arc
 ;	points to yield a smooth curve.  N is variable, depending both on the
 ;	arc size and on the pixel size of the current output device.
 ; MODIFICATION HISTORY:
 ;	Created 15-DEC-1991 by Mati Meron.
 ;       Modified 15-DEC-1993 by Mati Meron.  Now ARC takes advantage of the
 ;       keyword inheritance property and accepts all PLOTS keywords.
 ;	Modified 15-JUN-1995 by Mati Meron.  Removed the ALT_EXT keyword which
 ;	is no longer needed (_EXTRA has been fixed).
 ;	Modified 25-JUL-1999 by Mati Meron.  Added keywords NO_SHOW and
 ;	SHAPEOUT.
 ;-
 
     on_error, 1
     nop = One_of(rad,ang)
     if nop eq -1 then message, 'Either radius or angle should be given!'
     if nop eq 1 then if keyword_set(deg) then dang= !dtor*ang else dang= 1.*ang
     tpi = 2*!pi
 
     errm = ['Underdefined!', 'Overdefined!', 'Invalid option!']
     case n_params() of
 	0:	message, errm(0)
 	1:	if n_elements(cent) eq 0 then message, errm(0) $
 		else if nop eq 0 then message, errm(1) $
 		else rad = sqrt(total((r1 - cent)^2))
 	2:	begin
 		    if keyword_set(sym) then message, errm(2) else $
 		    if n_elements(cent) ne 0 then message, errm(1) else begin
 			rt = .5*(r1 + r2)
 			rl = .5*reverse(r1 - r2)*[1,-1]
 			arl = sqrt(total(rl^2))
 			if nop eq 0 then begin
 			    if rad lt arl then message, 'impossible!'
 			    c = sqrt((rad/arl)^2 - 1)
 			    if keyword_set(big) then c = -c
 			    dang = 2.*((atan(1./c,1) + !pi) mod !pi)
 			endif else begin
 			    c = 1./tan(dang/2.)
 			    rad = arl*sqrt(c^2 + 1)
 			endelse
 			cent = rt + c*rl
 		    endelse
 		end
 	else:	message, errm(1)
     endcase
 
     ray = r1 - cent
     stang = (atan(ray(1),ray(0)) + tpi) mod tpi
     if keyword_set(sym) then stang = stang - dang/2
 
     rdat = transpose([[[0,rad] + cent(0)], [[0,rad] + cent(1)]])
     rdev = Shape_cocon(rdat, to = 'dev')
     npoints = 1 + round(abs(dang)/2*sqrt(max(abs(rdev(*,1) - rdev(*,0)))))
     tem = dang/npoints*indgen(npoints + 1) + stang
     parc = transpose([[cent(0) + rad*cos(tem)], [cent(1) + rad*sin(tem)]])
 
     if not keyword_set(nsh) then plots, parc, _extra = _e
 
     return
 end
 
                                 *** ARREQ ***                           

 Function Arreq, arr1, arr2, warn = wn, novalue = nov
 
 ;+
 ; NAME:
 ;	ARREQ
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Compares arrays for equality.  The arrays qualify as equal if:
 ;	    1) They are of the same general type (num., char., or struct.).
 ;	    2) Number of dimensions is the same.
 ;	    3) Size of each dimension is the same.
 ;	    4) Respective elements are equal.
 ; CATEGORY:
 ;	Mathematical Function (general).
 ; CALLING SEQUENCE:
 ;	Result = ARREQ( ARR1, ARR2 [, keywords])
 ; INPUTS:
 ;    ARR1, ARR2
 ;	Arrays, type and number of dimensions arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /WARN
 ;	Switch. If set, a warning message is issued for incompatible data types.
 ;    /NOVALUE
 ;	Switch.  If set, only number of elements and structure are compared.
 ; OUTPUTS:
 ;	Returns 1 if the arrays are equal, 0 otherwise.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses the SIZE function and ISNUM from MIDL to obtain information about
 ;	the arrays.  Compares, in order, number of dimensions, size of each
 ;	dimension, data types, and (unless NOVALUE is set) individual elements.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Modified 30-AUG-1998 by Mati Meron.  Scope broadened to pointer arrays.
 ;-
 
     fsiz = size(arr1)
     ssiz = size(arr2)
     if fsiz(0) eq ssiz(0) then ndim = fsiz(0) else return, 0b
     for i = 1, ndim do if fsiz(i) ne ssiz(i) then return, 0b
     fnum = Isnum(arr1, type = ftyp)
     snum = Isnum(arr2, type = styp)
     if not ((fnum and snum) or (ftyp eq styp)) then begin
 	if keyword_set(wn) then message, 'Incompatible data types!', /continue
 	return, 0b
     endif
 
     if keyword_set(nov) then return, 1b else return, min(arr1 eq arr2)
 end
 
                                 *** ARRLOC ***                          

 Function Arrloc, inds, siz, expand = exd, contract = cnt
 
 ;+
 ; NAME:
 ;	ARRLOC
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Converts array indices from expanded (multi dimensional) form to
 ;	contracted (one dimensional) form and vice versa.
 ; CATEGORY:
 ;	Array Function.
 ; CALLING SEQUENCE:
 ;	Result = ARRLOC( INDS, SIZ [, keywords])
 ; INPUTS:
 ;    INDS
 ;	Numeric, converted to long integer on input.  Structure depends on
 ;	usage mode (EXPAND versus CONTRACT) and on the input parameter SIZ, as
 ;	follows:
 ;	    EXPAND mode  :  INDS can be a scalar or a vector (1-dim array).
 ;	    CONTRACT mode:  If SIZ(0) = 0 then INDS arbitrary.  Else INDS can
 ;	    be a scalar, vector or a 2-dim array, subject to the following
 ;	    restrictions:
 ;		INDS is scalar:  SIZ(0) must be 1.
 ;		INDS is vector:  SIZ(0) must equal the length of INDS.
 ;		INDS is M*N array:  SIZ(0) must equal M (first array dimension).
 ;    SIZ
 ;	Vector in the form of the standard output of the system function SIZE.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /EXPAND
 ;	Switch, specifies expansion mode.  This is the default.
 ;    /CONTRACT
 ;	Switch, specifies contraction mode.
 ; OUTPUTS:
 ;	Depending on mode, as follows:
 ;	EXPAND mode:  Returns an M*N array, where M is the number of dimensions
 ;	    of the object charactarized by SIZ (i.e. SIZ(0)) and N is the
 ;	    number of elements in INDS.  For example, if S = [2,3,8,4,24]
 ;	    (corresponding to a 3*8 real array) then ARRLOC(5,S) will return
 ;	    the vector [2,1] (the indices of the 5th element) while
 ;	    ARRLOC([2,5,22]) will return:	2	0
 ;						2	1
 ;						1	7
 ;	CONTRACT mode:  Reverses the action of expand.  When fed an array in
 ;	    the form of the output of ARRLOC with EXPAND, returns a vector of
 ;	    1-dimensional indices.  For example a call to ARRLOC using S and
 ;	    the output array from the example above will return:	2
 ;									5
 ;									22
 ;    In either mode, if any of the resulting indices is out of bounds for the
 ;    array specified by SIZ, it is replaced by -1.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None other than those specified in the description of INDS, above.
 ; PROCEDURE:
 ;	Straightforward.  Calls ONE_OF from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 30-MARCH-1994 by Mati Meron.
 ;-
 
     on_error, 1
     act = One_of(exd,cnt) > 0
     item = long(inds)
     ndim = siz(0)
     if ndim gt 0 then begin
 	if act then begin
 	    csiz = size(item)
 	    case csiz(0) of
 		0:	begin
 			    if ndim eq 1 then begin
 				item = reform(replicate(item,1),1,1)
 				csiz = size(item)
 			    endif else message, 'Size incompatibility!'
 			end
 		1:	begin
 			    if ndim eq csiz(1) then begin
 				item = reform(item,csiz(1),1)
 				csiz = size(item)
 			    endif else message, 'Size incompatibility!'
 			end
 		2:	if ndim ne csiz(1) then $
 			message, 'Size incompatibility!'
 		else:	message, 'Size incompatibility!'
 	    endcase
 	    res = item(ndim-1,*)
 	    for i = ndim - 2, 0, -1 do res = res*siz(i+1) + item(i,*)
 	    for j = 0l, csiz(2) - 1 do begin
 		tem = item(*,j) lt 0 or item(*,j) ge siz(1:ndim)
 		dum = where(tem ne 0, nov)
 		if nov ne 0 then res(j) = -1l
 	    endfor
 	endif else begin
 	    nel = n_elements(item)
 	    ovfl = where(item lt 0 or item ge siz(ndim+2), nov)
 	    res = reform(lonarr(ndim*nel),ndim,nel)
 	    i = 0
 	    while i lt (ndim - 1) do begin
 		res(i,*) = item mod siz(i+1)
 		item = (item - res(i,*))/siz(i+1)
 		i = i + 1
 	    endwhile
 	    res(i,*) = item
 	    if nov ne 0 then res(*,ovfl) = -1l
 	endelse
     endif else begin
 	res = lonarr(n_elements(item))
 	jtem = where(item ne 0, ntem)
 	if ntem gt 0 then res(jtem) = -1l
     endelse
 
     return, res
 end
 
                                  *** ARRO ***                            

 Pro Arro, from = tail, to = head, size = siz, tail = ta, twosided = twos, $
     device = dev, normal = nor, _extra = _e
 
 ;+
 ; NAME:
 ;	ARRO.
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Draws an arrow in the current plot area, from the FROM to the TO
 ;	location.  DATA coordinates are used, unless one of the keywords
 ;	/DEVICE or /NORMAL is set.
 ; CATEGORY:
 ;	General Graphics.
 ; CALLING SEQUENCE:
 ;	ARRO, FROM = tail, TO = head [, keywords]
 ; INPUTS:
 ;	None.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    FROM
 ;	Two dimensional vector, start location, mandatory.
 ;    TO
 ;	Two dimensional vector, end location, mandatory.
 ;    SIZE
 ;	Scalar, specifies size of head [and tail], default is 1.
 ;    /TAIL
 ;	Switch.  Puts a tail on the arrow.
 ;    /TWOSIDED
 ;	Switch.  Draws a twosided arrow (heads on both ends).
 ;    /DEVICE
 ;	Standard IDL plotting interpretation.
 ;    /NORMAL
 ;	Ditto.
 ;    _EXTRA
 ;       A formal keyword used to pass all plotting keywords.  Not to be used
 ;       directly.
 ; OUTPUTS:
 ;	None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;       The keywords passed through _EXTRA are transferred to the PLOTS
 ;	routine.  No keyword verification is performed by ARRO.
 ; PROCEDURE:
 ;	Uses DEFAULT, ONE_OF, SHAPE_COCON, SHAPE_TRANS and WHERINSTRUCT
 ;	from MIDL.  All the coordinates are converted to DEVICE coordinates for
 ;	shape generation and plotting purposes.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Modified 15-DEC-1991 by Mati Meron.  Added keywords COLOR and TWOSIDED.
 ;       Modified 15-DEC-1993 by Mati Meron.  Now ARROW takes advantage of the
 ;       keyword inheritance property and accepts all IDL plotting keywords.
 ;	Modified 5-OCT-1994 by Mati Meron.  Name changed to ARRO to avoid
 ;	conflicts with library routines.
 ;	Modified 15-JUN-1995 by Mati Meron.  Utilizes WHERINSTRUCT for improved
 ;	keyword inheritance.
 ;-
 
     on_error, 1
     siz = Default(siz,1)
     posib = ['DATA', 'DEVICE', 'NORMAL']
     sor = posib(1 + One_of(dev,nor))
 
     tem = Shape_cocon([[tail],[head]], from = sor, to = 'DEVICE')
     ang = atan(tem(1,1) - tem(1,0), tem(0,1) - tem(0,0))
 
     arrhead = siz*Shape_trans(transpose([[0,-2,-2],[0,1,-1]]),ang)
     usersym, arrhead, /fill
     plots, tem, /device, _extra = _e
     plots, tem(*,1), psym = 8, /device, _extra = _e
     if keyword_set(twos) then begin
 	arrhead = Shape_trans(arrhead,180,/degrees)
 	usersym, arrhead, /fill
 	plots, tem(*,0), psym = 8, /device, _extra = _e
     endif else begin
 	if keyword_set(ta) then begin
 	    x = [1,-1,1,-1,1]
 	    y = [0,1,0,-1,0]
 	    arrtail = siz*Shape_trans(transpose([[x-1,x,x+1],[y,y,y]]),ang)
 	    nth = Wherinstruct('thi',_e,thcon)
 	    if thcon eq 1 then thi = _e.(nth(0)) else thi = !p.thick
 	    usersym, arrtail, thick = thi
 	    plots, tem(*,0), psym = 8, /device, _extra = _e
 	endif
     endelse
 
     return
 end
 
                                *** ASP_CORR ***                        

 Function Asp_Corr, shape, reference = reflin
 
 ;+
 ; NAME:
 ;	ASP_CORR
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Corrects the aspect ratio of a 2-dimensional shape, in order to make up
 ;	for for different scaling in the x and y dimensions.
 ; CATEGORY:
 ;	Array Manipulation /General Graphics.
 ; CALLING SEQUENCE:
 ;	Result = ASP_CORR( SHAPE, REFERENCE = reflin)
 ; INPUTS:
 ;    SHAPE
 ;	(2,*) numeric array, mandatory.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    REFERENCE
 ;	Defines the scaling procedure, according to the provided character
 ;	value.  Accepts one of the following six values (only the first two
 ;	characters matter):
 ;	    'XLO' :  Scale x, keeping lowest x-value constant.
 ;	    'XCEN':  Scale x, keeping center x-value constant.
 ;	    'XHI' :  Scale x, keeping highest x-value constant.
 ;	    'YLO' :  Scale y, keeping lowest y-value constant.
 ;	    'YCEN':  Scale y, keeping center y-value constant.
 ;	    'YHI' :  Scale y, keeping highest y-value constant.
 ; OUTPUTS:
 ;	0 in case of failure (bad or missing shape or keyword value), otherwise
 ;	the transformed shape is returned as a floating array (double if the
 ;	input is of type double).
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	Three dimensional shapes aren't currently accepted.
 ; PROCEDURE:
 ;	Uses calls to CAST, DEFAULT, SHAPE_VER and STRMATCH_MM from MIDL.  The
 ;	scaling is done using the sizes of the plotting area in device
 ;	coordinates, provided by the system variables !d.x_vsize and
 ;	!d.y_vsize.  Therefore the scaling is always proper for the current
 ;	output device.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;-
 
     if Shape_ver(shape) ne 2 then begin
 	message, 'Missing or invalid shape!', /continue
 	return, 0
     endif
 
     posib = ['XLO','XCEN','XHI','YLO','YCEN','YHI']
     numop = StrMatch_mm(reflin,posib,2)
     if numop ge 0 then begin
 	res = Cast(shape,4,5)
 	ic = numop/3
 	fac = (float(!d.y_vsize)/!d.x_vsize)^(1 - 2*ic)
 	top = max(res(ic,*), min = bot)
 	case (numop - 3*ic) of
 	    0 :	ref = bot
 	    1 :	ref = (top + bot)/2
 	    2 :	ref = top
 	endcase
 	res(ic,*) = (res(ic,*) - ref)*fac + ref
     endif else begin
 	show = strupcase(Default(reflin,'___',/strict))
 	message, show + ' is not a valid reference line!',/continue
 	return, 0
     endelse
 
     return, res
 end
 
                                 *** BESELK ***                          

 Function Beselk, x, ni, eps, integral = int
 
 ;+
 ; NAME:
 ;	BESELK
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates an approximation to Bessel K functions or their integrals.
 ; CATEGORY:
 ;	Mathemetical Function (General).
 ;	Obsolete, replaced by BESELK_MM.
 ; PROCEDURE:
 ;	Calls BESELK_MM and OBSTAT from MIDL.  See BESELK_MM for details.
 ; MODIFICATION HISTORY:
 ;	Created 1-MARCH-1993 by Mati Meron.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;	Replaced by BESELK_MM on SEP-30-1999.
 ;-
 
     Obstat
 
     return, Beselk_mm(x, ni, eps, integral = int)
 end
 
                               *** BESELK_MM ***                       

 Function Beselk_mm, x, ni, eps, integral = int
 
 ;+
 ; NAME:
 ;	BESELK_MM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates an approximation to Bessel K functions or their integrals.
 ; CATEGORY:
 ;	Mathemetical Function (General).
 ; CALLING SEQUENCE:
 ;	Result = BESELK_MM (X, NI [, /INTEGRAL ])
 ; INPUTS:
 ;    X
 ;	Numerical, otherwise arbitrary.
 ;    NI
 ;	Scalar, the order of the function.
 ; OPTIONAL INPUT PARAMETERS:
 ;    EPS
 ;	Allowed relative error.  Default is machine precision.
 ; KEYWORD PARAMETERS:
 ;    /INTEGRAL
 ;	Switch, if set the integral of the K function from X to infinity is
 ;	calculated.
 ; OUTPUTS:
 ;	Returns the value(s) of K_ni(X) or, if INTEGRAL is set, of the integral
 ;	of K_ni(t) from X to infinity.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses the Kostroun approximation, see NIM 172, 371-374 (1980).
 ;	Calls DEFAULT, FPU_FIX, ISNUM and TOLER from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 1-MARCH-1993 by Mati Meron as BESELK.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;	Renamed 25-SEP-1999 by Mati Meron, to BESELK_MM.
 ;-
 
     on_error, 1
     teps = Toler(x)
     wips = 1./(Default(eps,teps,/dtype) > teps)
     intf = keyword_set(int)
     if Isnum(x,/double) then wpi = !dpi else wpi = !pi
 
     h = 2*wpi/sqrt(x^2 + (ni + 2/wpi*alog(wips))^2)
     res = FPU_fix(0.5*exp(-x))
     nozer = where(res gt 0, noc)
     if noc gt 0 then res(nozer) = res(nozer)*exp(x(nozer))
     r = 0
     while noc gt 0 do begin
 	r = r + 1
 	rh = r*h(nozer)
 	term = cosh(ni*rh)*exp((1.-cosh(rh))*x(nozer))
 	if intf then term = term/cosh(rh)
 	res(nozer) = res(nozer) + term
 	pozer = where(wips*term ge res(nozer), noc)
 	if noc gt 0 then nozer = nozer(pozer)
     endwhile
 
     return, FPU_fix(h*exp(-x)*res)
 end
 
                                  *** BOX ***                             

 Pro Box, xlims, ylims, border = brd, over = ov, truasp = traxy, $
     update_lims = upl, _extra = _e
 
 ;+
 ; NAME:
 ;	BOX
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Creates an empty plot area, with boundaries defined by XLIMS and YLIMS.
 ; CATEGORY:
 ;	General Graphics.
 ; CALLING SEQUENCE:
 ;	BOX, XLIMS, YLIMS [, keywords]
 ; INPUTS:
 ;    XLIMS, YLIMS
 ;	2 dimensional vectors, format: [xmin,xmax] and [ymin,ymax] respectively.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /BORDER
 ;	Switch.  Draws a border around the plot area.  Default - no border.
 ;    /OVER
 ;	Switch.  Creates the plot area over an existing plot.  Default - new
 ;	plot area.
 ;    TRUASP
 ;	Corrects the XLIMS or YLIMS values to yield a 1:1 aspect ratio.
 ;	Accepts six possible character values (only first 2 characters matter):
 ;	    'XLO' :  Scale x, keeping lowest x-value constant.
 ;	    'XCEN':  Scale x, keeping center x-value constant.
 ;	    'XHI' :  Scale x, keeping highest x-value constant.
 ;	    'YLO' :  Scale y, keeping lowest y-value constant.
 ;	    'YCEN':  Scale y, keeping center y-value constant.
 ;	    'YHI' :  Scale y, keeping highest y-value constant.
 ;    /UPDATE_LIMS
 ;	Switch.  If set, XLIMS and YLIMS are updated to the values used in
 ;	plotting.
 ;    _EXTRA
 ;	A formal keyword used to pass all plotting keywords.  Not to be used
 ;	directly.  See comment in RESTRICTIONS.
 ; OUTPUTS:
 ;	None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	If UPDATE_LIMS is set, the values of XLIMS, YLIMS may change.
 ; RESTRICTIONS:
 ;       The keywords passed through _EXTRA are transferred to the PLOTS
 ;	routine.  No keyword verification is performed by BOX.
 ; PROCEDURE:
 ;	Uses calls to CAST, and STRMATCH_MM from MIDL.  The scaling is done
 ;	using the sizes of the plotting area in device coordinates, provided by
 ;	the  system variables !d.x_vsize and !d.y_vsize.  Therefore the scaling
 ;	is always proper for the current output device.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Modified 15-DEC-1991 by Mati Meron.  Added keyword COLOR.
 ;	Modified 15-DEC-1993 by Mati Meron.  Now BOX takes advantage of the
 ;	keyword inheritance property and accepts all IDL plotting keywords.
 ;	Modified 1-MAY-1995 by Mati Meron.  Improved aspect ratio correction.
 ;-
 
     on_error, 1
     blims = Cast(transpose([[xlims],[ylims]]),4,5)
     if keyword_set(brd) then sty = 16 else sty = 20
 
     if n_elements(traxy) ne 0 then begin
 	posib = ['XLO','XCEN','XHI','YLO','YCEN','YHI']
 	numop = StrMatch_mm(traxy,posib,2)
 	if numop ge 0 then begin
 	    ic = numop/3
 	    horp = !p.multi(1) > 1.
 	    verp = !p.multi(2) > 1.
 	    if !p.charsize eq 0 then chas = 1. else chas = !p.charsize
 	    if (horp > verp) gt 2 then chas = 0.5*chas
 	    facx = float(round((!d.x_vsize - $
 		    horp*chas*!d.x_ch_size*total(!x.margin))/horp>$
 		    (-chas*!d.x_ch_size*!x.margin(0))))
 	    facy = float(round((!d.y_vsize - $
 		    verp*chas*!d.y_ch_size*total(!y.margin))/verp>$
 		    (-chas*!d.y_ch_size*!y.margin(1))))
 	    fac = abs(facy/facx)
 	    span = (blims(1-ic,1) - blims(1-ic,0))*fac^(2*ic - 1)
 	    case numop mod 3 of
 		0    :	blims(ic,1) = blims(ic,0) + span
 		1    :	blims(ic,*) = 0.5*(total(blims(ic,*)) + span*[-1,1])
 		2    :	blims(ic,0) = blims(ic,1) - span
 	    endcase
 	endif else message, 'Illegal reference line entry!'
 	sty = sty + 1
 	if keyword_set(upl) then begin
 	    xlims = transpose(blims(0,*))
 	    ylims = transpose(blims(1,*))
 	endif
     endif
 
     plot, blims(0,*), blims(1,*), /nodata, xstyle = sty, ystyle = sty, $
     noerase = keyword_set(ov), ticklen = 0, _extra = _e
 
     return
 end
 
                                  *** CAST ***                            

 Function Cast, x, low, high, fix = fix
 
 ;+
 ; NAME:
 ;	CAST
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Generalized type casting.  Converts variables whose type code is out
 ;	of the range [LOW,HIGH] into this range.
 ; CATEGORY:
 ;	Programming (type conversion).
 ; CALLING SEQUENCE:
 ;	Result = CAST( X, [LOW [,HIGH]])
 ; INPUTS:
 ;    X
 ;	Numerical, arbitrary, or a character representation of a number(s).
 ;    LOW
 ;	Number representing a type code, range (1:9).  If greater than 9, it is
 ;	set to 9.  If less then 1, or not given, it is set to 1.
 ; OPTIONAL INPUT PARAMETERS:
 ;    HIGH
 ;	Type code, same as LOW.  Default value is 9.  If provided and less then
 ;	LOW, it is set to LOW.
 ; KEYWORD PARAMETERS:
 ;    /FIX
 ;	Switch.  If set, the output is filtered through FPU_FIX, eliminating
 ;	floating underflow errors.
 ; OUTPUTS:
 ;	If the type of X is < LOW, CAST returns X converted to type LOW.
 ;	If the type of X is > HIGH, CAST returns X converted to type HIGH.
 ;	Otherwise CAST returns X.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	1)  An attempt to convert a string which is NOT a character
 ;	    representation of a number into a numeric type will yield error.
 ;	2)  X cannot be a structure or pointer, but can be a structure element.
 ;	3)  The value 8 for either LOW or HIGH is not allowed (since it
 ;	    corresponds to structure type).  Value of 10 and above is ignored.
 ; PROCEDURE:
 ;	Identifies the type of X, and if out of the range given by [LOW,HIGH]
 ;	calls the proper conversion routine using the system routine
 ;	CALL_FUNCTION.  Also uses FPU_FIX and ISNUM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 25-DEC-1991 by Mati Meron.
 ;	Modified 15-JUN-1995 by Mati Meron to accept the new DOUBLECOMPLEX type.
 ;	Modified 25-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     conv = ['nada', 'byte', 'fix', 'long', 'float', 'double', 'complex', $
 	    'string', 'nonap', 'dcomplex']
     if n_elements(low)  eq 0 then ilo = 1 else ilo = 1   > fix(low)  < 9
     if n_elements(high) eq 0 then ihi = 9 else ihi = ilo > fix(high) < 9
 
     inum = Isnum(x, type = ityp) or ityp eq 7
     if ilo eq 8 or ihi eq 8 or not inum then message, "Can't do that!" else $
     if ityp lt ilo then res = call_function(conv(ilo),x) else $
     if ityp gt ihi then res = call_function(conv(ihi),x) else res = x
 
     if keyword_set(fix) then return, FPU_fix(res) else return, res
 end
 
                             *** CHEBYSHEV_POL ***                   

 Function Chebyshev_pol, x, n, associated = aso
 
 ;+
 ; NAME:
 ;	CHEBYSHEV_POL
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates Chebyshev polynomials Tn and associated functions.
 ; CATEGORY:
 ;	Mathematical function.
 ; CALLING SEQUENCE:
 ;	Result = CHEBYSHEV_POL( X, N, [ /ASSOCIATED])
 ; INPUTS:
 ;    X
 ;	Numeric, absolute values must be <= 1, otherwise arbitrary.
 ;    N
 ;       Nonnegative scalar, rounded to integer on input.  Defaults to 0.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /ASSOCIATED
 ;	Switch.  When set, an associated function, SIN(N*ARCCOS(X)) is returned.
 ; OUTPUTS:
 ;	Returns the values of the Chebyshev polynomial T(n,x), defined as
 ;	COS(N*ARCCOS(X)) or (when ASSOCIATED is set), the values of the
 ;	associated Chebyshev function, SIN(N*ARCCOS(X)).
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None other then the restrictions on X, and N as mentioned above.
 ; PROCEDURE:
 ;	Using the mathematical definition.  Calling DEFAULT and FPU_FIX from
 ;	MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 20-DEC-1994 by Mati Meron.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     wn = Default(n,0l,/dtype)
 
     if wn lt 0 then message, 'N must be nonnegative!'
     if max(abs(x)) gt 1 then message, 'Absolute value of X must be <=1 !'
 
     if keyword_set(aso) then return, FPU_fix(sin(wn*acos(x))) $
     else return, FPU_fix(cos(wn*acos(x)))
 end
 
                                 *** CIRCLE ***                          

 Pro Circle, center = cent, radius = prad, x_radius = xrad, y_radius = yrad, $
     fill = fil, device = dev, normal = nor, $
     no_show = nsh, shapeout = shap, _extra = _e
 
 ;+
 ; NAME:
 ;	CIRCLE
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ; 	Draws a circle, around CENTER, with radius given by RADIUS, X_RADIUS,
 ;	or Y_RADIUS.  The drawing is done in the currently defined plot area.
 ;	One and ONLY ONE of the three radius values MUST be provided.  RADIUS
 ;	and X_RADIUS are equivalent.  Alternatively, a *SHAPE* representation
 ;	(see SHAPE_VER for definition) of the circle may be returned through
 ;	the SHAPEOUT keyword.  DATA coordinates are used unless one of the
 ;	keywords /DEVICE or /NORMAL is set.  The circle is drawn so as to
 ;	appear visually as a circle, regardless of the coordinates used.
 ; CATEGORY:
 ;	General Graphics.
 ; CALLING SEQUENCE:
 ;	CIRCLE, CENTER = C, {RADIUS=R, X_RADIUS=XR, Y_RADIUS = YR} [, keywords]
 ; INPUTS:
 ;	None.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    CENTER
 ;	Two dimensional vector, circle center location, mandatory.
 ;    RADIUS							|
 ;	Scalar, value of radius (measured in the X direction).	| One
 ;    X_RADIUS							| and only one
 ;	Scalar, value of radius (measured in the X direction).	| must be
 ;    Y_RADIUS							| provided.
 ;	Scalar, value of radius (measured in the Y direction).	|
 ;    /FILL
 ;	Switch.  causes the circle to be filled with a solid pattern.
 ;    /DEVICE
 ;	Standard IDL plotting interpretation.
 ;    /NORMAL
 ;	Ditto.
 ;    /NO_SHOW
 ;	Switch.  If set, no plotting is done, but the shape is generated and
 ;	may be returned through SHAPEOUT.
 ;    SHAPEOUT
 ;	Optional output, see below.
 ;    _EXTRA
 ;       A formal keyword used to pass all plotting keywords.  Not to be used
 ;       directly.  See comment in RESTRICTIONS.
 ; OUTPUTS:
 ;	None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    SHAPEOUT
 ;	When provided with the name of a variable, on return the variable
 ;	contains the *SHAPE* representation of the circle.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	While nominally all graphics keywords can be passed (through _EXTRA),
 ;	care should be exercised to use only the applicable ones (ELLIPSE and
 ;	PLOTS keywords usually, POLYFILL keywords when /FILL is used.
 ; PROCEDURE:
 ;	Uses calls to COO_CONV, ONE_OF and SHAPE_COCON from MIDL.  Converts all
 ;	parameters to device coordinates and calls ELLIPSE (also from MIDL)
 ;	to do the actual plotting.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;       Modified 15-DEC-1993 by Mati Meron.  Now CIRCLE takes advantage of the
 ;       keyword inheritance property and accepts all IDL plotting keywords.
 ;	Modified 25-JUL-1999 by Mati Meron.  Added keywords NO_SHOW and
 ;	SHAPEOUT.
 ;-
 
     on_error, 1
     rnum = One_of(xrad,yrad,prad, value = rad) mod 2
     if rnum eq -1 then message, 'Missing radius!'
 
     posib = ['DATA', 'DEVICE', 'NORMAL']
     sor = posib(1 + One_of(dev,nor))
 
     tem = [cent(rnum),cent(rnum) + rad]
     tem = Coo_conv(tem, axis = rnum, from = sor, to = 'DEVICE')
     rad = tem(1) - tem(0)
 
     x = Coo_conv(cent(0), axis = 'X', from = sor, to = 'DEVICE')
     y = Coo_conv(cent(1), axis = 'Y', from = sor, to = 'DEVICE')
 
     Ellipse, center = [x,y], radii = [rad,rad], /device, fill = fil, $
     no_show = nsh, shapeout = shap, _extra = _e
 
     shap = Shape_cocon(temporary(shap), from = 'DEVICE', to = sor)
 
     return
 end
 
                                *** CONFRAC ***                         

 Function Confrac, a, b, x, afunction = afun, bfunction = bfun, $
     epsilon = eps, relative = rel, error = erv, status = stat
 
 ;+
 ; NAME:
 ;    CONFRAC
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Performs continued fraction evaluation.
 ; CATEGORY:
 ;	Mathematical function (general).
 ; CALLING SEQUENCE:
 ;	Result = CONFRAC( A, B [,X [, keywords]])
 ; INPUTS:
 ;    A
 ;	A numeric scalar, vector or a 2-D array.  A(i,*) contains the i-th
 ;	A coefficient(s) of the continued fraction.
 ;    B
 ;	Same as A for the B coefficient(s).  A and B must agree in their first
 ;	dimension, i.e. if A is an (N,M) array (including the possibility of
 ;	M = 1) then B must be an (N,M') array, with an arbitrary M'.
 ; OPTIONAL INPUT PARAMETERS:
 ;    X
 ;	Numeric, otherwise arbitrary.  When provided, X is used together with
 ;	A and B to determine the continued fraction coefficients.
 ; KEYWORD PARAMETERS:
 ;    AFUNCTION
 ;	Name of a function to be used (with the CALL_FUNCTION routine) to
 ;	determine the A coefficients.  Optional.
 ;    BFUNCTION
 ;	Same as AFUNCTION for the B coefficients.  Optional.
 ;    EPSILON
 ;	Smallness parameter, determining the allowed evaluation error.
 ;	Optional.  Default values are machine dependent, established through
 ;	TOLER which calls MACHAR().
 ;    /RELATIVE
 ;	Switch.  If set, EPS represent the allowed relative evaluation error.
 ;    ERROR
 ;	Optional output, see below.
 ;    STATUS
 ;	Optional output, see below.
 ; OUTPUTS:
 ;	Returns the value(s) of the continued fraction.  The result is of the
 ;	same format as X (a scalar if X is not given).  The type of the result
 ;	is the highest of the types of A, B, and X, but no lower than 4 (float).
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    ERROR
 ;	The name of the variable to receive the estimated evaluation error.
 ;	Given in the same format as X (scalar if X isn't provided).  If
 ;	RELATIVE is set the error returned is relative.
 ;    STATUS
 ;	The name of the variable to receive evaluation status information.
 ;	Same format as ERROR.  Possible values are:
 ;	    0 - evaluation didn't converge.
 ;	    1 - OK.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None other then the restrictions on A, B, as mentioned above.
 ; PROCEDURE:
 ;	CONFRAC evaluates continued fractions of the form
 ;
 ;		res = a(0)/(b(0) + a(1)/(b(1) + a(2)/(b(2) + ......
 ;
 ;	Using the recurrence relation from Numerical Recipies, Sec 5.2.  The
 ;	designation of the coefficients a(i), b(i) depends on the data
 ;	provided, as follows:
 ;
 ;	1)  If X isn't provided then a(i) = A(i) (or A(i,0) if A is a 2-dim
 ;	    array) and same is true for b(i) (using B)
 ;	2)  If X is provided then a(i) = Sum_j(A(i,j)*X^j) and the same for b(i)
 ;	    using B.  In other words the fraction coefficients are polynomials
 ;	    in X, using columns of A, B, as polynomial coefficients.  Note that
 ;	    if A and/or B are one dimensional arrays then only X^0 is used i.e.
 ;	    we are back to case 1.
 ;	3)  If AFUN and/or BFUN are provided then a(i) = afun(x,A(i,*),i) and
 ;	    same for b(i) with BFUN and B.  The functions can be arbitrary but
 ;	    they must accept at least three parameters.
 ;
 ;	CONFRAC uses CAST, DEFAULT, FPU_FIX, POLEVAL, TOLER and TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 20-DEC-1994 by Mati Meron.
 ;	Modified 10-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
 
     if n_params() lt 2 then message, 'both A and B are needed!'
     sia = size(a)
     sib = size(b)
     flen = (sia)(sia(0)<1)
     if (sib)(sib(0)<1) ne flen then message, "Unequal arrays' lengths!"
     afl = n_elements(afun) gt 0
     bfl = n_elements(bfun) gt 0
 
     dtyp = max([Type(a),Type(b),Type(x),4])
     weps = Default(eps,Toler(type=dtyp))
     relfl = keyword_set(rel)
 
     wx = Default(x,1.,low = dtyp)
     nox = 1. + 0.*wx
     erv = (machar(double = dtyp eq 5 or dtyp eq 9)).xmax*Cast(nox,4,5)
     stat = 0*fix(nox)
     norfl = 0
 
     ap = 1.
     bp = 0.
     al = 0.
     bl = 1.
     i = 0l
 
     repeat begin
 	if norfl then begin
 	    ap = ap*norm
 	    bp = bp*norm
 	    norfl = 0
 	endif
 
 	if afl then ai = call_function(afun,wx,i,a(i,*)) $
 	else ai = Poleval(wx,a(i,*))
 	if bfl then bi = call_function(bfun,wx,i,b(i,*)) $
 	else bi = Poleval(wx,b(i,*))
 
 	an = al*bi + ap*ai
 	bn = bl*bi + bp*ai
 	ap = al
 	bp = bl
 	al = an
 	bl = bn
 
 	binz = where(bn ne 0, noz)
 	if noz gt 0 then begin
 	    norfl = 1
 	    norm = nox
 	    norm(binz) = 1./bn(binz)
 	    al = al*norm
 	    bl = bl*norm
 	    erv(binz) = (abs(al - ap))(binz)
 	    if relfl then erv(binz) = erv(binz)/(abs(al) > weps)(binz)
 	    stat(binz) = fix(erv(binz) le weps)
 	endif
 	i = i + 1l
     endrep until i eq flen or min(stat) eq 1
 
     return, FPU_fix(al)
 end
 
                               *** CONSTANTS ***                       

 Pro Constants, mks = mks, cgs = cgs
 
 ;+
 ; NAME:
 ;	CONSTANTS
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Creates or updates a system variable named !PCON.  !PCON is a structure
 ;	the fields of which contain values of physical constants as follows:
 ;	!PCON
 ;	     USYS  - 	Unit System.  Either 'MKS' or CGS'.
 ;	     C     -	Speed of light.
 ;	     E     -	Electron charge.
 ;	     H     -	Planck constant.
 ;	     ME    -	Electron mass.
 ;	     K     -	Boltzman constant.
 ;	     NA    -	Avogadro constant.
 ;
 ;	     ECONV -	Used internally for unit conversion.
 ;
 ;	     HBAR  -	Planck constant divided by 2*pi.
 ;	     ALPHA -	Fine structure constant.
 ;	     AMU   -	Atomic mass unit.
 ;	     SIGMA -	Stefan-Boltzman radiation constant.
 ;
 ;	All the values are given in a double precision format.  Of course, the
 ;	actual accuracy depends on how precisely they can be measured.
 ; CATEGORY:
 ;	Utility.
 ; CALLING SEQUENCE:
 ;	CONSTANTS [,/MKS or /CGS]
 ; INPUTS:
 ;	None.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /MKS
 ;	Switch.  Sets the units system to MKS.  This is also the default.
 ;    /CGS
 ;	Switch.  Sets the units system to CGS.  Default is MKS.
 ; OUTPUTS:
 ;	None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	M_CONS.  Contains a single parameter, EXISTS.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	Can't use both MKS and CGS at the same time.
 ; PROCEDURE:
 ;	Either creates or, if EXISTS is defined, updates the system variable
 ;	!PCONS.  Uses ONE_OF from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 30-MAR-1994 by Mati Meron.
 ;-
 
     common m_cons, exists
 
     tem = {pcv,usys:	'CGS', $
 		c:	2.99792458d10, $
 		e:	4.8032068d-10, $
 		h:	6.6260755d-27, $
 		me:	9.1093897d-28, $
 		k:	1.380658d-16, $
 		na:	6.0221367d23, $
 		econv: 1d, hbar: 1d, alpha: 1d,	amu: 1d, sigma: 1d}
 
     if One_of(mks,cgs) le 0 then begin
 	tem.usys = 'MKS'
 	tem.c  = 1d-2*tem.c
 	tem.e  = tem.e/(10d*tem.c)
 	tem.h  = 1d-7*tem.h
 	tem.me = 1d-3*tem.me
 	tem.k  = 1d-7*tem.k
 
 	tem.econv = 1d-7*tem.c^2
 	tem.amu = 1d-3
     endif
 
     tem.hbar = tem.h/(2d*!dpi)
     tem.alpha = tem.econv*tem.e^2/(tem.c*tem.hbar)
     tem.amu = tem.amu/tem.na
     tem.sigma = tem.hbar/60d*(!dpi/tem.c*(tem.k/tem.hbar)^2)^2
 
     if n_elements(exists) eq 0 then begin
 	defsysv, '!pcon', tem
 	exists = 1
     endif else dum = execute('!pcon = tem')
 
     return
 end
 
                               *** CONVOL_MM ***                       

 Function Convol_mm, far, gar, nocenter = noc, reverse = rev, clip = cli, $
     edge_val = edv, edge_truncate = edt
 
 ;+
 ; NAME:
 ;	CONVOL_MM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the convolution of two functions represented by arrays.
 ; CATEGORY:
 ;	Mathematical, array function.
 ; CALLING SEQUENCE:
 ;	Result = CONVOL_MM (FAR, GAR [, keywords])
 ; INPUTS:
 ;    FAR
 ;	Array, numeric, otherwise arbitrary.
 ;    GAR
 ;	Ditto.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /NOCENTER
 ;	Switch.  Prevents centering one array over the other (corresponds to
 ;	the CENTER = 0 setting in IDL CONVOL.  The default is CENTERED.
 ;    /REVERSE
 ;	Switch.  Reverses the direction, i.e instead of f(x-x')g(x') the
 ;	integrand becomes f(x+x')g(x').
 ;    /CLIP
 ;	Switch.  If set, the edges of the result (which cannot be fully
 ;	convolved) are set to zero, same as the default behavior of IDL CONVOL.
 ;	The default behaviour of CONVOL_MM corresponds to the IDL CONVOL
 ;	EDGE_WRAP SETTING.
 ;    EDGE_VAL
 ;	Accepts a value to be used for all the "beyond the edge " elements.
 ;	if EDGE_VAL is provided, /CLIP is ignored.  EDGE_VAL and EDGE_TRUNCATE
 ;	are mutually exclusive
 ;    /EDGE_TRUNCATE
 ;	Switch.  If set, the "beyond the edge" elements are obtained by a
 ;	propagation of the edge elements of FAR.  EDGE_TRUNCATE and EDGE_VAL
 ;	are mutually exclusive
 ; OUTPUTS:
 ;	Returns the result of the convolution with dimensions corresponding to
 ;	the bigger of the two arrays.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses FFT.  Faster then the IDL CONVOL, and differs from it in few
 ;	significant aspects, as follows:
 ;
 ;	1) The two arrays are treated symmetrically, i.e. the result stays the
 ;	same if they are exchanged (with the exception that when /REVERSE is
 ;	set, it is always the second array that's reversed.
 ;	2) The problem with IDL CONVOL, where the centered convolution is
 ;	calculated in a reversed direction (versus standard mathematical
 ;	practice) has been corrected.
 ;	3) The arrays don't have to be of the same dimensionality.  If they're
 ;	not they are imbedded in an array big enough to contained both and
 ;	padded with zeroes (default), a constant value (if EDGE_VAL is used)
 ;	or the edge elements of FAR (if EDGE_TRUNCATE is used).
 ;
 ;	Calls CAST, EXTEND_ARRAY, FPU_FIX and TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-NOV-1996 by Mati Meron as M_CONVOL.
 ;	Modified 20-JAN-1997 by Mati Meron.  Streamlined (through the use of
 ;	EXTEND_ARRAY and added keyword EDGE_TRUNCATE.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;	Renamed 25-SEP-1999 by Mati Meron, to CONVOL_MM.
 ;-
 
     ndm = 7
     if keyword_set(noc) then cefl = 0 else cefl = 1
     if keyword_set(rev) then refl = 1 else refl = 0
     clfl = keyword_set(cli)
     edfl = keyword_set(edt) or n_elements(edv) ne 0
     typ = Type(far) > Type(gar)
 
     sif = size([far])
     sig = size([gar])
     ndf = sif(0)
     ndg = sig(0)
     if ndf lt ndm then nf=[replicate(1l,ndm-ndf),sif(1:ndf)] else nf=sif(1:ndf)
     if ndg lt ndm then ng=[replicate(1l,ndm-ndg),sig(1:ndg)] else ng=sig(1:ndg)
 
     p = nf > ng
     q = nf < ng
     if edfl then begin
 	clfl = 1
 	l = ((1 - refl)*(q - 1) + refl*cefl*q)/(1 + cefl)
 	p = p + q - 1
     endif else l = replicate(0l,ndm)
 
     prod = 1l
     for i = 0, ndm - 1 do prod = prod*p(i)
     sir = [ndm,p,typ,prod]
 
     wfar = Extend_array(far,l,newsize=sir,value=edv,edge=edt)
     wgar = Extend_array(gar,newsize=sir)
 
     if refl then res = conj(fft(conj(wgar))) else res = fft(wgar)
     res = reform(FPU_fix(prod*fft(fft(wfar)*res,/inverse)),sir(1:ndm))
 
     s = (2*refl - 1)*(q/2)
     if cefl then res = shift(res,s(0),s(1),s(2),s(3),s(4),s(5),s(6))
 
     if clfl then begin
 	l = ((1 - refl)*(q - 1) + refl*cefl*q)/(1 + cefl)
 	h = l + p - q
 
 	res = res(l(0):h(0),l(1):h(1),l(2):h(2),l(3):h(3), $
 		l(4):h(4),l(5):h(5),l(6):h(6))
 	if not edfl then res = Extend_array(res,l,newsize=sir)
     endif
 
     return, Cast(reform(res),typ,typ)
 end
 
                                *** COO_CONV ***                        

 Function Coo_conv, r, axis = ax, from = sor, to = des
 
 ;+
 ; NAME:
 ;	COO_CONV
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Transforms values between the coordinate systems supported by IDL.
 ;	Allowed coord systems are DATA, DEVICE (only for X, Y axes) and NORMAL.
 ;	Functionally similar to the IDL function CONVERT_COORD, COO_CONV is
 ;	maintained for historical reasons.
 ; CATEGORY:
 ;	Plotting /General Graphics.
 ; CALLING SEQUENCE:
 ;	Result = COO_CONV( R, AXIS = AX [, keywords])
 ; INPUTS:
 ;    R
 ;	numeric, otherwise arbitrary, assumed to be a coordinate(s) in the
 ;	direction specified by AXIS.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    AXIS
 ;	Sets the transformation axis.  Accepts either a numeric value, one of
 ;	(0, 1, 2) or a character value (only first character matters), one of
 ;	('X', 'Y', 'Z').  Mandatory.
 ;    FROM
 ;	Character value (only first 3 characters matter), specifies input
 ;	coord. system.  One of ('DATA','DEVICE','NORMAL').  Defaults to 'DATA'.
 ;    TO
 ;	Same as FROM.  Specifies output coord. system.
 ; OUTPUTS:
 ;	'' (0 length string) in case of failure (bad keyword value), otherwise
 ;	returns the transformed value as floating (or double if the input is
 ;	of type double).
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses calls to CAST, DEFAULT, FPU_FIX, ISNUM, STREQ, STRMATCH_MM and
 ;	TYPE from MIDL.  Converts coordinates using values provided by relevant
 ;	system variables.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Modified 10-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     axes = ['X', 'Y', 'Z']
     if Isnum(ax) then nax = fix(ax) else $
     if Type(ax) eq 7 then nax = StrMatch_mm(ax,axes,1) $
     else message, 'Bad input!'
     if nax eq -1 or nax gt 2 then begin
 	message, 'No such axis!', /continue
 	return, ''
     endif else res = Cast(r,4,5)
 
     posib = ['DATA', 'DEVICE', 'NORMAL']
     sor = Default(sor,'DATA')
     des = Default(des,'DATA')
     if StrMatch_mm(sor,posib,3) eq -1 or StrMatch_mm(des,posib,3) eq -1 then $
     begin
 	message, 'Unknown coordinate system!', /continue
 	return, ''
     endif
     if nax eq 2 and (sor eq 'DEVICE' or des eq 'DEVICE') then begin
 	message, 'DEVICE coordinates for Z axis do not exist!', /continue
 	return, ''
     endif
     if Streq(sor,des) then return, res
 
     q = [[!x.s],[!y.s],[!z.s]]
     v = [!d.x_vsize,!d.y_vsize,1]
     t = [!x.type,!y.type,0]
 
     if Streq(sor,'DATA') then cvec = q(*,nax) $
     else if Streq(des,'DATA') then cvec = [-q(0,nax),1.]/q(1,nax) $
     else cvec = [0.,1.]
 
     if Streq(des,'DEVICE') then cvec = cvec*v(nax) $
     else if Streq(sor,'DEVICE') then cvec(1) = cvec(1)/v(nax)
 
     if Streq(sor,'DATA') and t(nax) then res = alog10(res)
     res = cvec(1)*res
     if cvec(0) ne 0 then res = cvec(0) + res
     if Streq(des,'DATA') and t(nax) then res = 10^(res)
 
     return, FPU_fix(res)
 end
 
                                *** COSANGLE ***                        

 Function Cosangle, u, v
 
 ;+
 ; NAME:
 ;	COSANGLE
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Finds the Cosine of the angle between two vectors.
 ; CATEGORY:
 ;	Geometry, General.
 ; CALLING SEQUENCE:
 ;	Result = COSANGLE ( U, V)
 ; INPUTS:
 ;    U, V
 ;	Vectors, numeric, same length, otherwise arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the Cosine of the angle between the two vectors.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	Vectors must be non-zero.
 ; PROCEDURE:
 ;	Uses the functions FPU_FIX, VINP and VNORM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 30-JUNE-1992 by Mati Meron.
 ;	Added to MIDL 10-NOV-1997 by Mati Meron.
 ;	Modified 10-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
 
     return, FPU_fix(Vinp(u,v)/(Vnorm(u)*Vnorm(v)))
 end
 
                                *** DEFAULT ***                         

 Function Default, x, y, strict = strit, dtype = deft, low = lot, high = hit
 
 ;+
 ; NAME:
 ;	DEFAULT
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Provides an automatic default value for nondefined parameters.
 ; CATEGORY:
 ;	Programming.
 ; CALLING SEQUENCE:
 ;	Result = DEFAULT( X, Y [, keywords])
 ; INPUTS:
 ;    X, Y
 ;	Arbitrary, at least one needs to be defined.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /STRICT
 ;	Switch.  If set, X is considered defined only if it is of the same type
 ;	as Y.
 ;    /DTYPE
 ;	Switch.  If set, the result will be typecast into the type of Y.
 ;	Explicit settings for LOW and/or HIGH (see below) override DTYPE.
 ;    LOW
 ;	Numeric value between 1 to 9 (8 is excluded). If given, the result is
 ;	of type >= LOW.
 ;    HIGH
 ;	Numeric value between 1 to 9 (8 is excluded). If given, the result is
 ;	of type <= HIGH.
 ; OUTPUTS:
 ;	X if it is defined, otherwise Y.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	All type casting is bypassed if the result is of type 8 (STRUCTURE) or
 ;	higher than 9.
 ; PROCEDURE:
 ;	Uses the functions CAST, ISNUM and TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Modified 15-NOV-1993 by Mati Meron.  The keyword TYPE has been replaced
 ;	by STRICT.  Added keywords DTYPE, LOW and HIGH.
 ;-
 
     on_error, 1
     xtyp = Type(x)
     ytyp = Type(y)
 
     if not (xtyp eq 0 or keyword_set(strit)) then atyp = xtyp else $
     if ytyp ne 0 then atyp = ytyp else message,'Insufficient data!'
 
     if xtyp eq atyp then res = x else res = y
 
     if keyword_set(deft) then begin
 	if n_elements(lot) eq 0 then lot = ytyp
 	if n_elements(hit) eq 0 then hit = ytyp
     end
 
     if Isnum(res) or atyp eq 7 then return, Cast(res,lot,hit) else return, res
 end
 
                                *** DEGLITCH ***                        

 Function Deglitch, arr, thresh, down = down, up = up, count = cnt
 
 ;+
 ; NAME:
 ;	DEGLITCH
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Replaces exceptional array elements by the average of their neighbors.
 ; CATEGORY:
 ;	Array Function.
 ; CALLING SEQUENCE:
 ;	Result = DEGLITCH( ARR, THRESH [, keywords])
 ; INPUTS:
 ;    ARR
 ;	Array, numeric, otherwise arbitrary.
 ;    THRESH
 ;	Threshold value for element replacement.  Must be > 1.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /DOWN
 ;	Switch.  If set the correction is downward, i.e. elements which are too
 ;	big (in absolute value) are replaced.  This is the default.
 ;    /UP
 ;	Switch.  If set the correction is upward, i.e. elements which are too
 ;	small (in absolute value) are replaced.
 ;    COUNT
 ;	Optional output, see below.
 ; OUTPUTS:
 ;	Returns the corrected array, i.e. an array of the same format as ARR,
 ;	in which all the exceptional element have been replaced by the average
 ;	of their neighbors.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    COUNT
 ;	The name of the variable to receive the number of exceptional elements.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Compares the absolute values of the original array and the one obtained
 ;	by neighborhood averaging.  Locates exceptions and replaces them by
 ;	neighborhood average.  Uses FPU_FIX, NEIGHBORS and ONE_OF from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 30-MARCH-1994 by Mati Meron.
 ;	Modified 10-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     if thresh le 1 then message, 'Threshold must be > 1!'
     dir = One_of(down,up) > 0
     cnt = 0l
     res = arr
     siz = size(arr)
     ndmx = 7
     ndm = siz(0)
     if ndm gt 0 then begin
 	if ndm lt ndmx then asiz = [ndmx,replicate(1,ndmx-ndm),siz(1:*)]
 	tarr = make_array(size = asiz)
 	abar = tarr + abs(arr)
 	a = lonarr(ndmx)
 	for i = ndmx - ndm, ndmx - 1 do begin
 	    a(i) = 1
 	    b = - a
 	    tarr = tarr + $
 	    shift(abar,a(0),a(1),a(2),a(3),a(4),a(5),a(6)) + $
 	    shift(abar,b(0),b(1),b(2),b(3),b(4),b(5),b(6))
 	    a(i) = 0
 	endfor
 	abar = reform(abar,asiz(ndmx-ndm+1:ndmx))
 	tarr = reform(tarr,asiz(ndmx-ndm+1:ndmx))/(2.^ndm)
 	if dir then fset = where(tarr gt thresh*abar,cnt) $
 	else fset =  where(abar gt thresh*tarr,cnt)
 	for i = 0, cnt - 1 do res(fset(i)) = $
 	total(res(Neighbors(fset(i),siz,count=con)))/con
     endif
 
     return, FPU_fix(res)
 end
 
                                *** DIAGOARR ***                        

 Function Diagoarr, vec
 
 ;+
 ; NAME:
 ;	DIAGOARR
 ; VERSION
 ;	3.3
 ; PURPOSE:
 ;	Creates a diagonal square matrix with the elements of a given vector on
 ;	the diagonal.
 ; CATEGORY:
 ;	Array Manipulation.
 ; CALLING SEQUENCE:
 ;	Result = DIAGOARR(VEC)
 ; INPUTS:
 ;    VEC
 ;	Vector.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Return a square N*N (N is the vector's dimension) matrix, with the
 ;	elements of VEC on the diagonal and zeroes elsewhere.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Calls TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 20-MAY-1993 by Mati Meron.
 ;-
 
     on_error, 1
     n = n_elements(vec)
     arr = make_array(n, n, type = Type(vec))
     arr((n+1)*indgen(n)) = vec
     return, arr
 
 end
 
                                *** DIAGOVEC ***                        

 Function Diagovec, arr
 
 ;+
 ; NAME:
 ;	DIAGOVEC
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Extracts the diagonal of a square matrix as a vector.
 ; CATEGORY:
 ;	Array Manipulation.
 ; CALLING SEQUENCE:
 ;	Result = DIAGOVEC(ARR)
 ; INPUTS:
 ;    ARR
 ;	Array, 2-dimensional, square.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	If ARR is a square matrix, returns the diagonal as a vector, else
 ;	generates an error message.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.
 ; MODIFICATION HISTORY:
 ;	Created 20-DEC-1991 by Mati Meron.
 ;-
 
     on_error, 1
     siz = size(arr)
     if siz(0) ne 2 then message, 'Not a matrix!' else $
     if siz(1) ne siz(2) then message, 'Not a square matrix!' else $
     return, arr((siz(1) + 1)*indgen(siz(1)))
 
 end
 
                                *** ELLIPSE ***                         

 Pro Ellipse, center = cent, radii = rd, arc = ar, degrees = deg, $
     rotate = rot, rotation_center = rocent, fill = fil, $
     device = dev, normal = nor, no_show = nsh, shapeout = elli, _extra = _e
 
 ;+
 ; NAME:
 ;	ELLIPSE
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Draws an ellipse, around CENTER, with radii given by RADII, optionally
 ;	rotating it by angle ROT.  The drawing is done in the currently
 ;	defined plot area.  Alternatively, a *SHAPE* representation (see
 ;	SHAPE_VER for definition) of the ellipse may be returned through the
 ;	SHAPEOUT keyword.  DATA coordinate system is assumed unless specified
 ;	otherwise by one of the keywords /DEVICE or /NORMAL.
 ; CATEGORY:
 ;	General Graphics.
 ; CALLING SEQUENCE:
 ;	ELLIPSE, CENTER = CENT, RADII = RD, [, optional keywords]
 ; INPUTS:
 ;	None.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    CENTER
 ;	2 dimensional vector, ellipse center location, format [x,y], mandatory.
 ;    RADII
 ;	2 dimensional vector, contains the x and y radii (in order), mandatory.
 ;    ARC
 ;	Optional.  Allows to draw an elliptical arc.  Accepts a vector of
 ;	length 2 containing the start and end angles for the arc.  If only one
 ;	value is provided, the arc is drown from angle 0 to this value if it is
 ;	positive, or from this value to 0 if it is negative.  The angles are
 ;	assumed to be in radians unless DEGREES is set.
 ;    /DEGREES
 ;	Switch.  Specifies that the rotation (and arc) angles are given in
 ;	degrees.
 ;    ROTATE
 ;	Optional.  Angle of rotation in the mathematical positive direction.
 ;	Assumed in radians, unless DEGREES is set.
 ;    ROTATION_CENTER
 ;	Optional.  Accepts a two element vector specifying the center of
 ;	rotation.  Ignored if ROTATE is not given.  Defaults to center of shape.
 ;    /FILL
 ;	Switch.  Causes the ellipse to be filled with a solid pattern.
 ;    /DEVICE
 ;	Standard IDL plotting interpretation.
 ;    /NORMAL
 ;	Ditto.
 ;    /NO_SHOW
 ;	Switch.  If set, no plotting is done, but the shape is generated and
 ;	may be returned through SHAPEOUT.
 ;    SHAPEOUT
 ;	Optional output, see below.
 ;    _EXTRA
 ;       A formal keyword used to pass all plotting keywords.  Not to be used
 ;       directly.  See comment in RESTRICTIONS.
 ; OUTPUTS:
 ;	None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    SHAPEOUT
 ;	When provided with the name of a variable,on return the variable
 ;	contains the *SHAPE* representation of the ellipse.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	If the DATA coordinate system is used and the plot area is defined with
 ;	nonlinear (logarithmic) axes, the shape won't look like an ellipse.
 ;	ELLIPSE calls either PLOTS or (when /FILL is used) POLYFILL.  Since
 ;	some graphics keywords work only with PLOTS, or only with POLYFILL,
 ;	some care must be exercised.
 ; PROCEDURE:
 ;	Uses calls to DEFAULT, ONE_OF, SHAPE_COCON and SHAPE_TRANS from MIDL.
 ;	Generates a (2,N) array containing a sufficient number of ellipse
 ;	points to yield a smooth curve.  N is variable, depending both on the
 ;	ellipse size and on the pixel size of the current output device.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Modified 15-DEC-1991 by Mati Meron.  Added size and device dependence
 ;	of the number of plot points.
 ;	Modified 15-OCT-1992 by Mati Meron.  Added rotation.
 ;       Modified 15-DEC-1993 by Mati Meron.  Now ELLIPSE takes advantage of the
 ;       keyword inheritance property and accepts all IDL plotting keywords.
 ;	Modified 1-MAY-1995 by Mati Meron.  Added capability to draw an
 ;	elliptical arc.
 ;	Modified 25-JUL-1999 by Mati Meron.  Added keyword SHAPEOUT.
 ;-
 
     on_error, 1
     posib = ['DATA', 'DEVICE', 'NORMAL']
     sor = posib(1 + One_of(dev,nor))
 
     rsor = transpose([[[0,rd(0)] + cent(0)], [[0,rd(1)] + cent(1)]])
     rdev = Shape_cocon(rsor, from = sor, to = 'dev')
     dang = !pi/(2*ceil(!pi/4*sqrt(max(abs(rdev(*,1) - rdev(*,0))))))
 
     war = (1+keyword_set(deg)*(!dtor-1))*Default(ar,0.,/dtype)
     war = (war/(2*!pi) mod 1)*(2*!pi)
     if n_elements(war) eq 1 then war = [war < 0., war > 0.]
     if war(1) le war(0) then war(1) = war(1) + 2*!pi
     tem = war(0) + dang*lindgen(round((war(1) - war(0))/dang) + 1l)
     elli = transpose([[cent(0) + rd(0)*cos(tem)], [cent(1) + rd(1)*sin(tem)]])
     if n_elements(rot) ne 0 then begin
 	rocent = Default(rocent,cent,low=4)
 	elli = Shape_trans(elli,0,1,-rocent)
 	elli = Shape_trans(elli,rot,1,rocent,degrees=deg)
     endif
 
     if not keyword_set(nsh) then if keyword_set(fil) then $
     polyfill, elli, device = dev, normal = nor, _extra = _e $
     else plots, elli, device = dev, normal = nor, _extra = _e
 
     return
 end
 
                                *** ERRBARS ***                         

 Pro Errbars, x, y, xerr = xer, yerr = yer, _extra = _e
 
 ;+
 ; NAME:
 ;	ERRBARS
 ; VEERSION:
 ;	3.3
 ; PURPOSE:
 ;	Overplots error bars over an existing plot.  More general than the
 ;	library routines ERRPLOT and PLOTERR, since it allows to independently
 ;	vary both X and Y errors, and allows for nonsymmetric error bars.
 ; CATEGORY:
 ;	Plotting.
 ; CALLING SEQUENCE:
 ;	ERRBARS, [X,] Y [, XERR = XER, YERR = YER]
 ; INPUTS:
 ;    X, Y
 ;	Vectors containing the data points' coordinates.  If only one is given
 ;	it is taken to be Y, same as in the PLOT command.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    XERR
 ;	Either a vector or a (2,N) array where N is the number of the data
 ;	points.  Contains the X-errors.  If given as a 2 dimensional array, the
 ;	entries XERR(0,i) and XERR(1,i) are taken as the errors of X(i) in the
 ;	negative and positive directions, respectively.  If given as a vector,
 ;	the entry XERR(i) serves as both the negative and positive error of
 ;	X(i) and therefore symmetric error bars are drawn.  If not provided,
 ;	the default is no X-errors.
 ;    YERR
 ;	Same as above, for the Y-errors.
 ;    _EXTRA
 ;       A formal keyword used to pass all plotting keywords.  Not to be used
 ;       directly.  See comment in RESTRICTIONS.
 ; OUTPUTS:
 ;	None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;       The keywords passed through _EXTRA are transferred to the PLOTS
 ;	routine.  No keyword verification is performed by ERRBARS.
 ; PROCEDURE:
 ;	Straightforward.  Uses DEFAULT from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 10-DEC-1991 by Mati Meron.
 ;       Modified 15-DEC-1993 by Mati Meron.  Now ERRBARS takes advantage of the
 ;       keyword inheritance property and accepts most of IDL plotting keywords.
 ;-
 
     on_error, 1
     len = n_elements(x)
     xp = x
     if n_params() eq 1 then begin
 	yp = x
 	xp = findgen(len)
     endif else yp = y
 
     wxer = Default(xer,fltarr(2,len))
     dum = size(wxer)
     if dum(0) eq 1 then wxer = transpose([[wxer],[wxer]])
     wyer = Default(yer,fltarr(2,len))
     dum = size(wyer)
     if dum(0) eq 1 then wyer = transpose([[wyer],[wyer]])
 
     xlh = transpose([[xp - wxer(0,*)],[xp + wxer(1,*)]])
     ylh = transpose([[yp - wyer(0,*)],[yp + wyer(1,*)]])
 
     for i = 0l, len - 1 do begin
 	plots, xlh(*,i), [yp(i),yp(i)], _extra = _e
 	plots, [xp(i),xp(i)], ylh(*,i), _extra = _e
     endfor
 
     return
 end
 
                               *** ERRORF_MM ***                       

 Function Errorf_mm, x, complementary = comp
 
 ;+
 ; NAME:
 ;	ERRORF_MM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the error function.  Replacement for the IDL ERRORF function
 ;	which accepts only real input.
 ; CATEGORY:
 ;	Mathematical function (general).
 ; CALLING SEQUENCE:
 ;	Result = ERRORF_MM (X [, /COMPLEMENTARY)]
 ; INPUTS:
 ;    X
 ;	Numeric, otherwise arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /COMPLEMENTARY
 ;	Switch.  If set, 1 - ERRORF(X) is returned.
 ; OUTPUTS:
 ;	Returns the error function of X or, if /COMPLEMENTARY is set,
 ;	1 - error_function.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	For very large (in absolute value) complex values of x, with
 ;		pi/4 < |abs(phase(x))| < 3*pi/4
 ;	the results may be meaningless.  A warning will be issued in this case.
 ; PROCEDURE:
 ;	Uses CAST IGAMMA_MM and IMAGINARY_MM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 20-MAR-1996 by Mati Meron as M_ERRORF.
 ;	Renamed 25-SEP-1999 by Mati Meron, to ERRORF_MM.
 ;-
 
     zex = 0*x
     sn = long(zex + 1)
     tem = double(zex)
     dum = where(Imaginary_mm(x) ne 0, ndum)
     if ndum gt 0 then tem(dum) = atan(dcomplex(x(dum)))
     dum = where(tem gt !dpi/2 or tem le -!dpi/2, ndum)
     if ndum gt 0 then sn(dum) = -1l
     wx = Cast(x,4)
 
     return, sn*Igamma_mm(wx^2, 0.5d, comp = comp) + keyword_set(comp)*(1 - sn)
 end
 
                              *** EXTEND_ARRAY ***                    

 Function extend_array, arr, off, newsize = nsiz, value = val, edge_extend = ext
 
 ;+
 ; NAME:
 ;	EXTEND_ARRAY
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Extends an array to a larger size, filling the blanks according to
 ;	keyword specifications.
 ; CATEGORY:
 ;	Array function.
 ; CALLING SEQUENCE:
 ;	Result = EXTEND_ARRAY( ARR, [, OFF] [,keywords]])
 ; INPUTS:
 ;    ARR
 ;	Array, arbitrary.
 ;    OFF
 ;	Vector containing the offset of ARR into the result array.  Defaults
 ;	to zero(s).  If the number of entries is smaller then the dimension
 ;	(either of ARR or of the result) missing entries are replaced with 0,
 ;	from left.  Thus if the result has dimensions of (4,5,6) but offset
 ;	is given as [2,2], an offset of [0,2,2] is used.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    NEWSIZE
 ;	A vector, containing the parameters of the result array, in the format
 ;	of the output of the IDL SIZE function.  If not given, the size used is
 ;	the minimal size capable of containing the original array with the
 ;	specified offset.
 ;    VALUE
 ;	A scalar value used to fill the blanks in the result array.  Defaults
 ;	to 0.  Warning:  VALUE and EDGE_EXTEND cannot be specified at the same
 ;	time
 ;    /EDGE_EXTEND
 ;	Switch.  If set, the blanks in the result array are filled with the
 ;	adjoining edge values of ARR.  Warning:  EDGE_EXTEND and VALUE cannot
 ;	be specified at the same time
 ; OUTPUTS:
 ;	Returns an array of size specified either by NEWSIZE or combination of
 ;	the original size and offset.  The original arry is imbedded in the
 ;	result, and the blanks are filled according to the keywords VALUE or
 ;	EDGE_EXTEND.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	The new size, as provided by NEWSIZE, must be large enough to contain
 ;	the original array with the offset.
 ; PROCEDURE:
 ;	Straightforward.  Calls DEFAULT and ONE_OF from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 20-JAN-1997 by Mati Meron.
 ;-
 
     on_error, 1
     ndm = 7
 
     siz = size([arr])
     nda = siz(0)
     if nda lt ndm then sir = [ndm,replicate(1l,ndm-nda),siz(1:*)] else sir = siz
 
     nof = n_elements(off)
     if nof eq 0 then l = replicate(0l,ndm) else $
     if nof lt ndm then l = [replicate(0l,ndm-nof),off] else $
     if nof eq ndm then l = off else message, 'Offset dimension error!'
     h = l + sir(1:ndm) - 1
     nds = nda > nof
 
     if n_elements(nsiz) gt 0 then begin
 	nds = nsiz(0)
 	if nds ge nda then begin
 	    sir(ndm-nds+1:ndm) = nsiz(1:nds)
 	    sir(ndm + 1) = sir(ndm+1) > nsiz(nds+1)
 	endif else message, 'Insufficient number of result dimensions!'
 	dum = where((sir(1:ndm) - h) lt 1, ndum)
 	if ndum gt 0 then message, 'Insufficient new size!'
     endif else sir(1:ndm) = h + 1
     s = sir(1:ndm) - h - 1
 
     prod = 1l
     for i = 1, ndm do prod = prod*sir(i)
     sir(ndm + 2) = prod
 
     exfl = One_of(val,ext) > 0
     val = Default(val,0)
 
     res = make_array(size = sir, value = val)
     res(l(0):h(0),l(1):h(1),l(2):h(2),l(3):h(3),$
 	l(4):h(4),l(5):h(5),l(6):h(6)) = arr
 
     if exfl then begin
 
 	if l(0) gt 0 then $
 	res(0:l(0)-1,*,*,*,*,*,*) = res(replicate(l(0),l(0)),*,*,*,*,*,*)
 	if s(0) gt 0 then $
 	res(h(0)+1:*,*,*,*,*,*,*) = res(replicate(h(0),s(0)),*,*,*,*,*,*)
 
 	if l(1) gt 0 then $
 	res(*,0:l(1)-1,*,*,*,*,*) = res(*,replicate(l(1),l(1)),*,*,*,*,*)
 	if s(1) gt 0 then $
 	res(*,h(1)+1:*,*,*,*,*,*) = res(*,replicate(h(1),s(1)),*,*,*,*,*)
 
 	if l(2) gt 0 then $
 	res(*,*,0:l(2)-1,*,*,*,*) = res(*,*,replicate(l(2),l(2)),*,*,*,*)
 	if s(2) gt 0 then $
 	res(*,*,h(2)+1:*,*,*,*,*) = res(*,*,replicate(h(2),s(2)),*,*,*,*)
 
 	if l(3) gt 0 then $
 	res(*,*,*,0:l(3)-1,*,*,*) = res(*,*,*,replicate(l(3),l(3)),*,*,*)
 	if s(3) gt 0 then $
 	res(*,*,*,h(3)+1:*,*,*,*) = res(*,*,*,replicate(h(3),s(3)),*,*,*)
 
 	if l(4) gt 0 then $
 	res(*,*,*,*,0:l(4)-1,*,*) = res(*,*,*,*,replicate(l(4),l(4)),*,*)
 	if s(4) gt 0 then $
 	res(*,*,*,*,h(4)+1:*,*,*) = res(*,*,*,*,replicate(h(4),s(4)),*,*)
 
 	if l(5) gt 0 then $
 	res(*,*,*,*,*,0:l(5)-1,*) = res(*,*,*,*,*,replicate(l(5),l(5)),*)
 	if s(5) gt 0 then $
 	res(*,*,*,*,*,h(5)+1:*,*) = res(*,*,*,*,*,replicate(h(5),s(5)),*)
 
 	if l(6) gt 0 then $
 	res(*,*,*,*,*,*,0:l(6)-1) = res(*,*,*,*,*,*,replicate(l(6),l(6)))
 	if s(6) gt 0 then $
 	res(*,*,*,*,*,*,h(6)+1:*) = res(*,*,*,*,*,*,replicate(h(6),s(6)))
 
     endif
 
     return, reform(res,sir(ndm-nds+1:ndm))
 end
 
                                *** EXTREMA ***                         

 Function Extrema, x, min_only = mino, max_only = maxo, ceiling = ceil, $
     threshold = tre, signature = sig, number = num
 
 ;+
 ; NAME:
 ;	EXTREMA
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Finding all local minima and maxima in a vector.
 ; CATEGORY:
 ;	Mathematical Function (array).
 ; CALLING SEQUENCE:
 ;	Result = EXTREMA( X [, keywords])
 ; INPUTS:
 ;    X
 ;	Numerical vector, at least three elements.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /MIN_ONLY
 ;	Switch.  If set, EXTREMA finds only local minima.
 ;    /MAX_ONLY
 ;	Switch.  If set, EXTREMA finds only local maxima.
 ;    THRESHOLD
 ;	A nonnegative value.  If provided, entries which differ by less then
 ;	THRESHOLD are considered equal.  Default value is 0.
 ;    /CEILING
 ;	Switch.  Determines how results for extended extrema (few consecutive
 ;	elements with the same value) are returned.  See explanation in OUTPUTS.
 ;    SIGNATURE
 ;	Optional output, see below.
 ;    NUMBER
 ;	Optional output, see below.
 ; OUTPUTS:
 ;	Returns the indices of the elements corresponding to local maxima
 ;	and/or minima.  If no extrema are found returns -1.  In case of
 ;	extended extrema returns midpoint index.  For example, if
 ;	X = [3,7,7,7,4,2,2,5] then EXTREMA(X) = [2,5].  Note that for the
 ;	second extremum the result was rounded downwards since (5 + 6)/2 = 5 in
 ;	integer division.  This can be changed using the keyword CEILING which
 ;	forces upward rounding, i.e. EXTREMA(X, /CEILING) = [2,6] for X above.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    SIGNATURE
 ;	The name of the variable to receive the signature of the extrema, i.e.
 ;	+1 for each maximum and -1 for each minimum.
 ;    NUMBER
 ;	The name of the variable to receive the number of extrema found.  Note
 ;	that if MIN_ONLY or MAX_ONLY is set, only the minima or maxima,
 ;	respectively, are counted.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Calls ARREQ, DEFAULT and ONE_OF from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-FEB-1995 by Mati Meron.
 ;	Modified 15-APR-1995 by Mati Meron.  Added keyword THRESHOLD.
 ;-
 
     on_error, 1
     siz = size(x)
     if siz(0) ne 1 then message, 'X must be a vector!' else $
     if siz(1) lt 3 then message, 'At least 3 elements are needed!'
 
     len = siz(1)
     res = replicate(0l,len)
     sig = res
     both = One_of(mino,maxo) eq -1
     cef = keyword_set(ceil)
     tre = Default(tre,0.,/dtype) > 0
 
     xn = [0, x(1:*) - x(0:len-2)]
     if tre gt 0 then begin
 	tem = where(abs(xn) lt tre, ntem)
 	if ntem gt 0 then xn(tem) = 0
     endif
     xp = shift(xn,-1)
     xn = xn(1:len-2)
     xp = xp(1:len-2)
 
     if keyword_set(mino) or both then begin
 	fir = where(xn lt 0 and xp ge 0, nfir) + 1
 	sec = where(xn le 0 and xp gt 0, nsec) + 1
 	if nfir gt 0 and Arreq(fir,sec) then begin
 	    res(fir) = fir
 	    sig(fir) = -1
 	endif else begin
 	    if nfir le nsec then begin
 		for i = 0l, nfir-1 do begin
 		    j = (where(sec ge fir(i)))(0)
 		    if j ne -1 then begin
 			ind = (fir(i) + sec(j) + cef)/2
 			res(ind) = ind
 			sig(ind) = -1
 		    endif
 		endfor
 	    endif else begin
 		for i = 0l, nsec-1 do begin
 		    j = (where(fir le sec(i), nj))((nj-1) > 0)
 		    if j ne -1 then begin
 			ind = (sec(i) + fir(j) + cef)/2
 			res(ind) = ind
 			sig(ind) = -1
 		    endif
 		endfor
 	    endelse
 	endelse
     endif
 
     if keyword_set(maxo) or both then begin
 	fir = where(xn gt 0 and xp le 0, nfir) + 1
 	sec = where(xn ge 0 and xp lt 0, nsec) + 1
 	if nfir gt 0 and Arreq(fir,sec) then begin
 	    res(fir) = fir
 	    sig(fir) = 1
 	endif else begin
 	    if nfir le nsec then begin
 		for i = 0l, nfir-1 do begin
 		    j = (where(sec ge fir(i)))(0)
 		    if j ne -1 then begin
 			ind = (fir(i) + sec(j) + cef)/2
 			res(ind) = ind
 			sig(ind) = 1
 		    endif
 		endfor
 	    endif else begin
 		for i = 0l, nsec-1 do begin
 		    j = (where(fir le sec(i), nj))((nj-1) > 0)
 		    if j ne -1 then begin
 			ind = (sec(i) + fir(j) + cef)/2
 			res(ind) = ind
 			sig(ind) = 1
 		    endif
 		endfor
 	    endelse
 	endelse
     endif
 
     res = where(res gt 0, num)
     sig = sig(res > 0)
 
     return, res
 end
 
                                *** FPU_FIX ***                         

 Function FPU_fix, x, no_abs = nab
 
 ;+
 ; NAME:
 ;	FPU_FIX
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Clears Floating Point Underflow errors, setting the offending values to
 ;	zero.
 ; CATEGORY:
 ;	Programming.
 ; CALLING SEQUENCE:
 ;	Result = FPU_FIX( X)
 ; INPUTS:
 ;    X
 ;	Arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /NO_ABS
 ;	Switch.  If set, uses value instead of absolute value for comparison
 ;	with machine minimum.  For internal use only.
 ; OUTPUTS:
 ;	If the input is of any numeric type, returns the input, with the
 ;	possible substitution of 0 for all occurences of Floating Point
 ;	Underflow.  A non-numeric input is returned as is.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Uses the system routines CHECK_MATH and MACHAR.  Also
 ;	calls ABS_MM and ISNUM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 30-AUG-1998 by Mati Meron.
 ;-
 
     on_error, 1
     fpucod = 32
     matherrs = ['Integer divided by zero','Integer overflow','','',$
 		'Floating-point divide by zero','Floating-point underflow',$
 		'Floating-point overflow','Floating-point operand error']
 
     chem = check_math()
     if Isnum(x,type = typ) and chem gt 0 then begin
 	if chem eq fpucod then begin
 	    sinf = machar(double = Isnum(x,/double))
 	    if keyword_set(nab) then dum = where(x lt sinf.xmin, nuf) $
 	    else dum = where(Abs_mm(x) lt sinf.xmin, nuf)
 	    if nuf gt 0 then x(dum) = 0
 	endif else message, matherrs(round(alog(chem)/alog(2)))
     endif
 
     return, x
 end
 
                              *** FRESNEL_INT ***                     

 Function Fresnel_int, x, sine = sin, complementary = comp
 
 ;+
 ; NAME:
 ;	FRESNEL_INT
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the Fresnel Integrals, C(x) or S(X).
 ; CATEGORY:
 ;	Mathematical function (general).
 ; CALLING SEQUENCE:
 ;	Result = FRESNEL_INT (X [, keywords])
 ; INPUTS:
 ;    X
 ;	Numeric, otherwise arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /SINE
 ;	Switch.  If set, the Fresnel sine integral, S(X), is returned.
 ;    /COMPLEMENTARY
 ;	Switch.  If set, 1/2 - C(X) (or S(X)) is returned.
 ; OUTPUTS:
 ;	Returns the Fresnel Cosine integral C(X) or, if /COMPLEMENTARY is set,
 ;	the sine integral S(X).  If /COMPLEMENTARY is set, the output is
 ;	1/2 (the value at infinity) - C(X) (or S(X)).
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	While the function is defined also for complex values of X, large
 ;	complex values may cause calculational instabilities.  A warning is
 ;	issued in this case.
 ; PROCEDURE:
 ;	Uses the function ERRORF_MM from MIDL, as well as CAST and TYPE, also
 ;	from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 20-MAR-1996 by Mati Meron.
 ;-
 
     on_error, 1
     typ = Type(x)
     cof = 2*sqrt(!dpi)
     opi = 0.25d*dcomplex(1, 1)
     oni = 0.25d*dcomplex(1,-1)
 
     if keyword_set(sin) $
 	then res = oni*Errorf_mm(cof*oni*x, comp = comp) + $
 		opi*Errorf_mm(cof*opi*x, comp = comp) $
 	else res = opi*Errorf_mm(cof*oni*x, comp = comp) + $
 		oni*Errorf_mm(cof*opi*x, comp = comp)
 
     return, Cast(res,4,typ,/fix)
 end
 
                                *** GAMMA_MM ***                        

 Function Gamma_mm, x
 
 ;+
 ; NAME:
 ;	GAMMA_MM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the gamma function.  Replacement for the IDL GAMMA function
 ;	which accepts only real input.
 ; CATEGORY:
 ;	Mathematical, general.
 ; CALLING SEQUENCE:
 ;	Result = GAMMA_MM (X)
 ; INPUTS:
 ;    X
 ;	Numeric, otherwise arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the gamma function of X.  Output type is same as input (but no
 ;	lower than FLOAT), form is same as input.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	The real part of X should be greater than 0.
 ; PROCEDURE:
 ;	Calls LNGAMMA_MM
 ; MODIFICATION HISTORY:
 ;	Created 30-MAR-1996 by Mati Meron as M_GAMMA.
 ;	Renamed 25-SEP-1999 by Mati Meron, to GAMMA_MM.
 ;-
 
     return, exp(Lngamma_mm(x))
 end
 
                                  *** HEAD ***                            

 Pro Head, a, b, c, d, e, f, g, h, nr = nr, nc = nc, row = ro, column = co,$
     transpose = trn, show_index = shin, nowrap = now, format = efor, _extra = _e
 
 ;+
 ; NAME:
 ;	HEAD
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Displays the beginning ("head") or, optionally, a selected part of an
 ;	1-2D array.
 ; CATEGORY:
 ;	Input/Output.
 ; CALLING SEQUENCE:
 ;	HEAD, A [,B ...H] [,keywords]
 ; INPUTS:
 ;    A [,B ...H]
 ;	One or more arrays, of arbitrary type.  If more than one array is
 ;	provided, all the arrays have to be 1D.  A single array can have 1 or
 ;	2 dimensions, but no more than 2.
 ; OPTIONAL INPUT PARAMETERS:
 ;	All but the first input are optional.
 ; KEYWORD PARAMETERS:
 ;    NR
 ;	The number of rows to be displayed.  Default value is 10 (except for
 ;	the case of a single 1D array in wrapping mode (see keyword NO_WRAP,
 ;	below), when it is 12).  If explicit values for the starting and ending
 ;	row numbers are provided through the keyword ROW (see below), NR is
 ;	ignored.
 ;    NC
 ;	Same as NR, for columns.  Default value is 6, maximal value is 8.
 ;	In the case of a single 1D array in wrapping mode, NC is
 ;	interchangeable with NR and, if both are provided, NC is ignored.
 ;    ROW
 ;	Specifies the first (and possibly last) row of the displayed array
 ;	part.  For an array with N rows, the possibilities are as follows:
 ;
 ;	    1)	No value provided: display area is from row #0 through row
 ;		#(NR - 1) or last row, whichever comes first.
 ;	    2)	Scalar value r0:  display area is from row #r0 through row
 ;		#(r0 + NR - 1) or last row, whichever comes first.
 ;	    3)  Single vector value r0 (for example, ROW = [4]):  this is
 ;		interpreted as a vector input, ROW = [r0,r0] (see case 4 below)
 ;		and a single row (#r0) is output.
 ;	    4)	Two element vector of the form ROW = [r0,r1]:  In this case
 ;		display area is from row #r0 through row #r1.
 ;
 ;	In the case of a single 1D array in the default wrapping mode (see
 ;	keyword NO_WRAP, below), ROW is interchangeble with COLUMN and
 ;	specifies the first (and, possibly, last) element to be displayed).
 ;    COLUMN
 ;	Same as ROW, for columns of the display area.  For a 2D array the
 ;	default number of displayed columns is the smaller of 6 and the actual
 ;	number of columns in the data.  For 1D arrays COLUMN is ignored,
 ;	except for the case of a single 1D array in wrapping mode.  In this
 ;	case COLUMN is interchangeable with ROW (see above) and ignored if ROW
 ;	is provided.
 ;	Maximal possible number of displayed columns is 8.
 ;    /TRANSPOSE
 ;	Switch.  If set and the input array is 2D, the transpose of the array
 ;	is used.  Thus HEAD, A, /TRANSPOSE is equivalent to HEAD, TRANSPOSE(A).
 ;	Ignored for multiple 1D inputs.
 ;    /SHOW_INDEX
 ;	Switch.  If set, the indices of the rows and columns shown are
 ;	displayed, on the right (for rows) and top (for columns).
 ;    /NO_WRAP
 ;	Switch.  Turns off wrapping mode which is on, by default for single 1D
 ;	arrays.  In the wrapping mode the array is displayed over as many lines
 ;	as needed, same as when being displayed using the PRINT statement.  In
 ;	a non-wrapping mode only a portion of a 1D array that fits on a single
 ;	line may be displayed.  If the input consists of a 2D array or multiple
 ;	1D arrays, the wrapping mode is off.
 ;    FORMAT
 ;	Character array, containing format specifications for the columns.
 ;	If not provided, default TABULATE formats are used.  If only a single
 ;	entry provided, it'll be used for all columns.  For more details see
 ;	TABULATE.
 ;	If multiple entries are provided in the wrapping mode, only the first
 ;	one is used.
 ;    _EXTRA
 ;	A formal keyword used to pass keywords to TABULATE.  Not to be used
 ;	directly.  All TABULATE keywords are available.
 ; OUTPUTS:
 ;	None, other then the printed output.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	As mentioned above:
 ;	    1)	Arrays with more then 2 dimensions not accepted.
 ;	    2)	For 2D, only a single array is allowed.
 ;	    3)	For 1D, up to 8 arrays allowed.  They can be of different
 ;		types but must have same length.
 ;	    4)  Wrapping is only possible with a single 1D array.
 ; PROCEDURE:
 ;	HEAD serves as a front end to TABULATE.  It selects a part of the
 ;	input, based on the row and column settings, and passes it to TABULATE
 ;	which displays it.  In addition to TABULATE, HEAD calls DEFAULT,
 ;	HOW_MANY, STRPARSE_MM and TYPE from MIDL.
 ;	In the wrap mode, HEAD bypasses TABULATE and uses PRINT, directly.
 ; MODIFICATION HISTORY:
 ;	Created 1-NOV-1997 by Mati Meron.
 ;	Modified 5-OCT-1998 by Mati Meron.  Added wrap mode for 1D arrays.
 ;-
 
     on_error, 1
     nwadef = 12l
     nrodef = 10l
     ncodef = 6l
     ncomax = 8l
     wrafl = 0
     cnams = [ 'A',  'B',  'C',  'D',  'E',  'F',  'G',  'H']
     wnams = ['WA', 'WB', 'WC', 'WD', 'WE', 'WF', 'WG', 'WH']
 
     wnr = Default(nr,nrodef,/dtype)
     wnc = Default(nc,ncodef,/dtype) < ncomax
     shofl = keyword_set(shin)
 
     nco = (n_params() < ncomax)
     if nco gt 0 then begin
 	if nco eq 1 then begin
 	    tem = [a]
 	    if keyword_set(trn) then tem = transpose(tem)
 	    siz = size(tem)
 	    if siz(0) gt 2 then begin
 		tem = reform(tem)
 		siz = size(tem)
 		if siz(0) gt 2 then message, 'Dims > 2 not supported!'
 	    endif
 	    if siz(0) eq 1 then begin
 		if keyword_set(now) then begin
 		    tem = reform(tem,siz(1),1)
 		    siz = size(tem)
 		endif else wrafl = 1
 	    endif
 	    if wrafl then begin
 		nro = siz(1)
 		ndum = How_many(fir = nr,sec = nc)
 		if ndum eq 0 then wnr = nwadef else wnr = Default(nr,nc) > 0l
 		ndum = How_many(fir = ro, sec = co)
 		if ndum eq 0 then wro = 0l else wro = Default(ro,co) > 0l
 	    endif else begin
 		wco = Default(co,0l,/dtype) > 0
 		if (size(wco))(0) eq 0 then wco = [wco,wco+wnc-1] else $
 		if n_elements(wco) eq 1 then wco = [wco,wco]
 		wco = wco(0) > wco < (((wco(0) + ncomax) < siz(1)) - 1)
 		nco = wco(1) - wco(0) + 1
 		nro = siz(2)
 		for i = wco(0), wco(1) do id = $
 		execute(wnams(i-wco(0)) + ' = reform(tem(' + string(i) + ',*))')
 		if shofl then begin
 		    lfor = floor(alog10(wco(1) > 1)) + 1
 		    hfor = strcompress('(I' + string(lfor) + ')', /remove_all)
 		    head = string(wco(0) + lindgen(nco), form = hfor)
 		endif
 	    endelse
 	endif else begin
 	    idim = lonarr(nco)
 	    nro = idim
 	    for i = 0, nco - 1 do begin
 		id = execute('typ = Type(' + cnams(i) + ')')
 		if typ gt 0 then begin
 		    id = execute(wnams(i) + ' = reform([' + cnams(i) + '])')
 		    id = execute('siz = size(' + wnams(i) + ')')
 		    idim(i) = siz(0)
 		    nro(i) = siz(1)
 		endif else nco = nco < i
 	    endfor
 	    if max(idim) gt 1 then message, 'multiple arrays must be 1D!'
 	    nro = min(nro(0:nco-1), max = nrox)
 	    if nro ne nrox then message, 'Unequal column lengths!'
 	endelse
     endif else message, 'No data!'
 
     if not wrafl then wro = Default(ro,0l,/dtype) > 0l
     if (size(wro))(0) eq 0 then wro = [wro,wro+wnr-1] else $
     if n_elements(wro) eq 1 then wro = [wro,wro]
     wro = wro(0) > wro < (nro - 1)
 
     if n_elements(efor) ne 0 then begin
 	wefor = efor
 	if wrafl then begin
 	    dum = Strparse_mm(wefor(0),'()',lis)
 	    wefor = lis(0)
 	    dum = Strparse_mm(wefor,'.0123456789',lis)
 	    fpos = strpos(wefor,lis(0))
 	    if fpos eq 0 then wefor = strcompress(string(nro),/remove) + wefor
 	    wefor = '(' + wefor +')'
 	endif else if n_elements(wefor) eq 1 then wefor = replicate(wefor,nco)
     endif
 
     if wrafl then print, a(wro(0):wro(1)), form = wefor else $
     Tabulate, wa, wb, wc, wd, we, wf, wg, wh, from = wro(0), to = wro(1), $
     index = shofl, head = head, nohead = 1 - shofl, format = wefor, _extra = _e
 
     return
 end
 
                                *** HOW_MANY ***                        

 Function How_many, first = v_0, second = v_1, third = v_2, fourth = v_3, $
     fifth = v_4, sixth = v_5, seventh = v_6, eighth = v_7, $
     nozero = noz, low = lo, high = hi, which_ones = bcod
 
 ;+
 ; NAME:
 ;	HOW_MANY
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Called with up to 8 keyword parameters, HOW_MANY checks how many and
 ;	which of the corresponding variables are defined and (optionally)
 ;	within given type limits.
 ; CATEGORY:
 ;	Programming.
 ; CALLING SEQUENCE:
 ;	Result = HOW_MANY ([FIRST ... ] [LOW =LO] [HIGH = HI] [/NOZERO] $
 ;		[WHICH_ONES = BCOD])
 ; INPUTS:
 ;	None.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    FIRST	|
 ;    SECOND	|
 ;    THIRD	|
 ;    FOURTH	|	Each of these keywords accept an arbitrary input,
 ;    FIFTH	|	including no input or undefined input.
 ;    SIXTH	|
 ;    SEVENTH	|
 ;    EIGHTH	|
 ;
 ;    /NOZERO
 ;	Switch.  If set, specifies that only non zero (or non null string)
 ;	values are to be recognized as existing.
 ;    LOW
 ;	Optional numeric input, specifying the lowest limit of type code that
 ;	is recognized.  For example, if LOW is set to 3, variables of type BYTE
 ;	and INTEGER will not be recognized as defined.  Default value is 1,
 ;	i.e. everything is recognized.
 ;    HIGH
 ;	Same as LOW for the upper limit.  Default value is 12, i.e. everything
 ;	is recognized.
 ;    WHICH_ONES
 ;	Optional output, see below.
 ; OUTPUTS:
 ;	Returns the number of defined keyword variables, regardless of their
 ;	types and values.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    WHICH_ONES
 ;	The name of a variable to receive a a binary representation of the
 ;	defined variables, as a long integer.  For example, if the variables
 ;	corresponding to FIRST, FIFTH and SIXTH are defined, the result is
 ;	2^0 + 2^4 + 2^5 = 49.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	Currently HOW_MANY is restricted to a maximum of 8 variables.  If
 ;	needed, the number can be increased.
 ; PROCEDURE:
 ;	Straightforward.  Calls DEFAULT and TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-AUG-1994 by Mati Meron, as a more general version of ONE_OF.
 ;-
 
     on_error, 1
     nmax = 8
     vnams = ['v_0','v_1','v_2','v_3','v_4','v_5','v_6','v_7']
     nozf = keyword_set(noz)
     lo = Default(lo,1,/dtype) > 1
     hi = Default(hi,12,/dtype) < 12
 
     exlist = lonarr(nmax)
     for i = 0, nmax - 1 do begin
 	idum = execute('typ = Type(' + vnams(i) + ')')
 	ityp = typ ge lo and typ le hi
 	if ityp and nozf then idum = execute('ityp=keyword_set('+vnams(i)+')')
 	exlist(i) = ityp
     endfor
     bcod = long(total(exlist*2l^lindgen(nmax)))
 
     return, long(total(exlist))
 end
 
                               *** IGAMMA_MM ***                       

 Function Igamma_mm, x, a, eps, complementary = comp
 
 ;+
 ; NAME:
 ;	IGAMMA_MM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the incomplete gamma function.  Replacement for the IDL
 ;	IGAMMA function which accepts only real input.
 ; CATEGORY:
 ;	Mathematical function (general).
 ; CALLING SEQUENCE:
 ;	Result = IGAMMA_MM (X, A [,EPS ] [,/COMPLEMENTARY ])
 ; INPUTS:
 ;    X
 ;	Numeric, otherwise arbitrary.
 ;    A
 ;	Numeric scalar, non-complex, positive.
 ; OPTIONAL INPUT PARAMETERS:
 ;    EPS
 ;	Specifies precision level.  Default is machine precision.
 ; KEYWORD PARAMETERS:
 ;    /COMPLEMENTARY
 ;	Switch.  If set, 1 - IGAMMA(X) is returned.
 ; OUTPUTS:
 ;	Returns the incomplete gamma function of x, unless /COMPLEMENTARY is
 ;	set in which case returns 1 - the incomplete gamma function.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	For reasons having to do with machine limits on sizes of numbers, the
 ;	parameter A cannot be too big.  The limit is roughly given by
 ;
 ;	A < P + (Ln(2*P))/2
 ;
 ;	Where P is the (natural) logarithm of the largest number the machine
 ;	can process.  The limit is machine dependent.
 ;
 ;	Also, for values of X with large negative real part the calculation
 ;	cannot converge and the result is replaced with a very large number
 ;	(machine limit).  A warning is displayed in this case.
 ; PROCEDURE:
 ;	Uses series expansion for small ABS(X) and continued fraction
 ;	expansion for larger values.  Calls ABS_MM, CAST, CONFRAC, DEFAULT,
 ;	IMAGINARY_MM, ISNUM, LNGAMMA_MM and TOLER, from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-MAR-1996 by Mati Meron as M_IGAMMA.
 ;	Modified 20-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;	Renamed 25-SEP-1999 by Mati Meron, to IGAMMA_MM.
 ;-
 
     on_error, 1
     sinf = machar(double=Isnum(x,/double,typ=typ))
     teps = Default(eps,Toler(x),/dtype)
     compf = keyword_set(comp)
     lp = alog(2d)*sinf.maxexp
     ln = alog(2d)*sinf.minexp
 
     philim = !dpi/2
     if a le 0 then message, 'A must be greater then 0!'
     if (a + 1)*(alog(a + 1) - cos(philim)) - Lngamma_mm(a + 2) ge lp then $
 	message, 'A value of A = ' + string(a, form = '(f8.4)') + ' is too big!'
     da = double(a)
     bound = (da + 1) > sqrt(-alog(teps) > 1)
 
     dx = dcomplex(x)
     ddx = double(dx)
     res = 0*dx
     sran = long(res)
     tem = dx + bound
     dum = where(Abs_mm(tem) le 2*bound, ndum)
     if ndum gt 0 then sran(dum) = 1
     lran = long(res)
     tem = (da - 1)*alog(Abs_mm(dx) > 1) - ddx - Lngamma_mm(da)
     dum = where(tem gt ln and tem lt lp, ndum)
     if ndum gt 0 then lran(dum) = 1
     phas = 0*ddx
     dum = where(Imaginary_mm(dx) ne 0, ndum)
     if ndum ne 0 then phas(dum) = atan(dx(dum))
 
     dum = where(dx eq 0, ndum)
     if ndum gt 0 and compf then res(dum) = 1
 
     dum = where (sran and lran and dx ne 0, ndum)
     if ndum gt 0 then begin
 	tex = dx(dum)
 	tres = exp(da*alog(tex) - tex - Lngamma_mm(da + 1))
 	tem = tres
 	ltem = lindgen(ndum)
 	ntem = ndum
 	n = 0l
 	while ntem gt 0 do begin
 	    n = n + 1
 	    tem = tem*tex(ltem)/(da + n)
 	    tres(ltem) = tres(ltem) + tem
 	    em = Abs_mm(tex(ltem)/(da + n + 1))
 	    lltem = where(Abs_mm(tem*em*(1+em)) gt teps*Abs_mm(tres(ltem)), ntem)
 	    if ntem gt 0 then begin
 		ltem = ltem(lltem)
 		tem = tem(lltem)
 	    endif
 	endwhile
 	if compf then res(dum) = 1 - tres else res(dum) = tres
     endif
 
     dum = where(not sran and lran, ndum)
     if ndum gt 0 then begin
 	len = ceil (-alog(teps)*(4/sqrt(da + 1) > sqrt(da + 1)/4))
 	alist = double([1l,1 + lindgen(len)/2])
 	tlist = 1l + 2*lindgen(len/2)
 	alist(tlist) = alist(tlist) - da
 	blist = dblarr(len + 1, 2)
 	blist(tlist,0) = 1
 	blist([0, tlist + 1],1) = 1
 	tex = dx(dum)
 	tres = exp((da - 1)*alog(tex) - tex - Lngamma_mm(da))* $
 	    (tex*Confrac(alist,blist,tex,eps = teps, /rel))
 	if compf then res(dum) = tres else res(dum) = 1 - tres
     endif
 
     dum = where(not sran and not lran and Abs_mm(phas) le philim, ndum)
     if ndum gt 0 then if compf then res(dum) = 0 else res(dum) = 1
 
     dum = where(not sran and not lran and Abs_mm(phas) gt philim, ndum)
     if ndum gt 0 then begin
 	message, 'Cannot calculate for large negative values,', /continue
 	message, 'replacing with machine maximum = ' + $
 	    string (sinf.xmax, form = '(e14.7)'), /continue
 	res(dum) = sinf.xmax
     endif
 
     return, Cast(res,4,typ,/fix)
 end
 
                              *** IMAGINARY_MM ***                    

 Function Imaginary_mm, x
 
 ;+
 ; NAME:
 ;	IMAGINARY_MM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Returns imaginary values.
 ; CATEGORY:
 ;	Mathematical, general.
 ; CALLING SEQUENCE:
 ;	Result = IMAGINARY_MM (X)
 ; INPUTS:
 ;    X
 ;	Numerical, otherwise arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the imaginary part of the input, i.e. 0 if the input is real
 ;	the imaginary part in FLOAT format for COMPLEX and the imaginary part
 ;	in DOUBLE format for DCOMPLEX.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Calling FPU_FIX and ISNUM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 5-MAY-1996 by Mati Meron as M_IMAGINARY.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;	Renamed 25-SEP-1999 by Mati Meron, to IMAGINARY_MM.
 ;-
 
     on_error, 1
     if not Isnum(x) then message, 'Not numeric!"
 
     if Isnum(x, /complex) then return, FPU_fix(imaginary(x)) $
     else if n_elements(x) gt 1 then return, make_array(size = size(x)) $
     else return, 0b*x
 end
 
                                 *** INTEG ***                           

 Function Integ, x, y, delta = dex, value_only = val
 
 ;+
 ; NAME:
 ;	INTEG
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Integrates a function provided as an array of points.
 ; CATEGORY:
 ;	Mathematical Function (array).
 ; CALLING SEQUENCE:
 ;	Result = INTEG([X,] Y [, keywords])
 ; INPUTS:
 ;    Y
 ;	A vector containing the Y coordinates of the data.
 ; OPTIONAL INPUT PARAMETERS:
 ;    X
 ;	A vector containing the X coordinates of the data.  If not provided,
 ;	it is assumed that the X coordinates are equally spaced, with a default
 ;	default spacing of 1. (unless changed by the DELTA keyword).
 ; KEYWORD PARAMETERS:
 ;    DELTA
 ;	Sets the spacing of the X coordinates of the data.  If the X coord.
 ;	are explicitly provided (see X input above) DELTA is ignored.
 ;    /VALUE_ONLY
 ;	Switch.  Normally INTEG returns the integral function of Y, as a vector
 ;	(see OUTPUTS below).  If VALUE_ONLY is set, only the full value of the
 ;	integral is returned as scalar.  This makes the execution faster.
 ; OUTPUTS:
 ;	Normally returns the integral function of Y, i.e. a vector whose i-th
 ;	entry is the integral of Y from X(0) to X(i) (and therefore the last
 ;	entry is the full integral of Y.  If the optional keyword VALUE_ONLY is
 ;	set, only the full integral is returned, as a scalar.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	The Y vector (and the X vector, if provided) must be of length >= 3.
 ; PROCEDURE:
 ;	Simpson integration, where the mid-interval points are obtained from
 ;	cubic interpolation using Neville's algorithm.
 ;	Uses DEFAULT, FPU_FIX and TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 20-FEB-1992 by Mati Meron.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     nv = n_elements(x)
     if nv lt 3 then message, 'Insufficient data!'
     dtyp = Type(x) > 4
 
     if n_elements(y) eq 0 then begin
 	dex = Default(dex,1.,low = dtyp)
 	xw = dex*(findgen(nv+2) - 1)
 	yw = [0., x, 0.]
     endif else begin
 	dtyp = Type(y) > dtyp
 	if n_elements(y) ne nv then message, 'Incompatible array lenghts!'
 	xw = [2*x(0) - x(1), x, 2*x(nv-1) - x(nv-2)]
 	yw = [0., y, 0.]
     endelse
 
     p = make_array(4, type = dtyp)
     q = p
     nw = nv + 1
     for i = 1, 3 do begin
 	k = nw - i
 	p(i) = yw(i)
 	q(i) = yw(k)
 	for j = i - 1, 1, - 1 do begin
 	    l = nw - j
 	    p(j) = ((xw(0)-xw(i))*p(j) + (xw(j)-xw(0))*p(j+1))/(xw(j)-xw(i))
 	    q(j) = ((xw(nw) - xw(k))*q(j) + (xw(l)-xw(nw))*q(j+1))/(xw(l)-xw(k))
 	endfor
     endfor
     yw(0) = p(1)
     yw(nw) = q(1)
 
     xc = .5*(xw(2:nv) + xw(1:nv-1))
     q = make_array(nv - 1, 4, type = dtyp)
     for i = 0, 3 do begin
 	k = nv - 2 + i
 	q(*,i) = yw(i:k)
 	for j = i - 1, 0, -1 do begin
 	    l = nv - 2 + j
 	    q(*,j) = ((xc - xw(i:k))*q(*,j) + (xw(j:l) - xc)*q(*,j+1)) $
 		     /(xw(j:l) - xw(i:k))
 	endfor
     endfor
 
     res = [0,(yw(1:nv-1) + yw(2:nv) + 4*q(*,0))*(xw(2:nv) - xw(1:nv-1))/6.]
     if keyword_set(val) then res = total(res) else $
     for i = 2l, nv - 1 do res(i) = res(i) + res(i-1)
 
     return, FPU_fix(res)
 end
 
                                 *** ISNUM ***                           

 Function Isnum, x, double = doub, complex = comp, type = typ
 
 ;+
 ; NAME:
 ;	ISNUM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Checks whether the input is a number.
 ; CATEGORY:
 ;	Programming.
 ; CALLING SEQUENCE:
 ;	Result = ISNUM(X)
 ; INPUTS:
 ;    X
 ;	Arbitrary, doesn't even have to exist.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /DOUBLE
 ;	Switch.  If set the result is 1 only if X is DOUBLE or DCOMPLEX.
 ;    /COMPLEX
 ;	Switch.  If set the result is 1 only if X is COMPLEX or DCOMPLEX.
 ;    TYPE
 ;	Optional output.  See below.
 ; OUTPUTS:
 ;	Returns 1 if X is number, 0 otherwise.  Output type is byte.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    TYPE
 ;	The name of the variable to receive the numeric code of the type of X.
 ;	Included for convenience to save an additional call to TYPE.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Using TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUN-1995 by Mati Meron.
 ;	Modified 5-MAY-1996 by Mati Meron.  Added keywords DOUBLE, COMPLEX and
 ;	TYPE.
 ;-
 
     numtyps = [1,2,3,4,5,6,9]
     typ = Type(x)
     res = (where(numtyps eq typ))(0) ge 0
     if keyword_set(doub) then res = res and (typ eq 5 or typ eq 9)
     if keyword_set(comp) then res = res and (typ eq 6 or typ eq 9)
 
     return, res
 end
 
                                 *** LABELS ***                          

 Pro Labels, x, y, labs, align = aln, _extra = _e
 
 ;+
 ; NAME:
 ;	LABELS
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Multiple XYOUTS interface.
 ; CATEGORY:
 ;	General Graphics.
 ; CALLING SEQUENCE:
 ;	LABELS, X, Y, LABS [ ,ALIGN = ALN] [, optional keywords]
 ; INPUTS:
 ;    X
 ;	The X coordinates of the labels.  Can be given either as a scalar (in
 ;	which case all the labels will have the same x coordinate) or as a
 ;	vector of the same length as the LABS vector.
 ;    Y
 ;	Same as above for the Y coordinates.
 ;    LABS
 ;	A character vector containing the labels to be drawn.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    ALIGN
 ;	The allignment parameter for LABS (see ALIGN graphics keyword in the
 ;	IDL manual.  Can be given as a vector, thus providing individual
 ;	allignment parameter to each string in LABS.
 ;    _EXTRA
 ;       A formal keyword used to pass all plotting keywords.  Not to be used
 ;       directly.  See comment in RESTRICTIONS.
 ; OUTPUTS:
 ;       None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;       None.
 ; COMMON BLOCKS:
 ;       None.
 ; SIDE EFFECTS:
 ;	If any of X, Y or ALIGN is given as a scalar variable, it is converted
 ;	to a vector of the same length as LABS.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straigtforward.  Calls DEFAULT from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 10-DEC-1991 by Mati Meron.
 ;	Modified 15-DEC-1993.  Incorporated keyword inheritance, allowing for
 ;	using all the XYOUTS keywords.
 ;-
 
     on_error, 1
     nlab = n_elements(labs)
     if n_elements(x) eq 1 then x = replicate(float(x),nlab)
     if n_elements(y) eq 1 then y = replicate(float(y),nlab)
     aln = Default(aln,fltarr(nlab))
     if n_elements(aln) eq 1 then aln = replicate(float(aln),nlab)
 
     for i = 0l, nlab-1 do xyouts, x(i), y(i), labs(i), align= aln(i), _extra= _e
 
     return
 end
 
                               *** LAPLACIAN ***                       

 Function Laplacian, arr, delta
 
 ;+
 ; NAME:
 ;	LAPLACIAN
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the Laplacian of a function represented as an array of
 ;	values.  Works for 1-7 dimensions.
 ; CATEGORY:
 ;	Array Manipulation.
 ; CALLING SEQUENCE:
 ;	Result = LAPLACIAN( ARR [, DELTA])
 ; INPUTS:
 ;    ARR
 ;	Array, numeric, number of dimensions can be 1 through 7
 ; OPTIONAL INPUT PARAMETERS:
 ;    DELTA
 ;	Size of step used to calculate the numeric derivatives.  The approx.
 ;	second partial derivative in the i-th direction is calculated as
 ;	 (ARR(...,I + DELTA,...) + ARR(...,I - DELTA,...) - 2*ARR(...,I,...)) $
 ;	 /DELTA^2
 ;	The default value of DELTA is 1l.  If provided, it is rounded to a long
 ;	integer on input.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the absolute value of the gradient as an array of the same size
 ;	as ARR.  If ARR is not an array, returns 0.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	Due to current limitations of the MAKE_ARRAY system routine, 8
 ;	dimensions are not allowed.
 ; PROCEDURE:
 ;	Creates an 7-dimensional array, with dummy leading dimensions,
 ;	containing the original array.  Generates the differences using the
 ;	SHIFT system routine and strips the dummy dimensions at the end.
 ;	Uses the functions DEFAULT and FPU_FIX from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-NOV-1991 by Mati Meron.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     ndmx = 7
     idel = abs(Default(delta,1l,/dtype))
     siz = size(arr)
     ndm = siz(0)
     if ndm eq 0 then begin
 	message, 'Not an Array!', /continue
 	return, 0
     endif else if ndm lt ndmx then siz = [ndmx,replicate(1,ndmx-ndm),siz(1:*)]
     res = make_array(size = siz)
     tarr = make_array(size = siz) + arr
 
     a = intarr(ndmx)
     for i = ndmx - ndm, ndmx - 1 do begin
 	a(i) = idel
 	b = - a
 	if idel mod siz(i+1) ne 0 then res = res + $
 	shift(tarr,a(0),a(1),a(2),a(3),a(4),a(5),a(6)) + $
 	shift(tarr,b(0),b(1),b(2),b(3),b(4),b(5),b(6)) - 2*tarr
 	a(i) = 0
     endfor
 
     return, FPU_fix(reform(res,siz(ndmx-ndm+1:ndmx))/idel^2)
 end
 
                              *** LEGENDRE_POL ***                    

 Function Legendre_pol, x, l, m
 
 ;+
 ; NAME:
 ;	LEGENDRE_POL
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates Legendre polynomials Pl and associated polynomials Plm.
 ; CATEGORY:
 ;	Mathematical function.
 ; CALLING SEQUENCE:
 ;	Result = LEGENDRE_POL( X, L [, M])
 ; INPUTS:
 ;    X
 ;	Numeric, absolute values must be <= 1, otherwise arbitrary.
 ;    L
 ;	Nonnegative scalar, rounded to integer on input.  Defaults to 0
 ; OPTIONAL INPUT PARAMETERS:
 ;    M
 ;	Nonnegative scalar, rounded to integer on input.  Defaults to 0.  Must
 ;	be <= L.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the values of the Legendre polynomial P(l,x) or (when M is not
 ;	zero) of the associated Legendre polynomial P(l,m,x).
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None other then the restrictions on X, L and M as mentioned above.
 ; PROCEDURE:
 ;	Using the recurrence relation from Numerical Recipies, Sec. 6.6.
 ;	Calling CAST, DEFAULT, and TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 20-DEC-1994 by Mati Meron.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     wl = Default(l,0l,/dtype)
     wm = Default(m,0l,/dtype)
 
     if wl lt 0 or wm lt 0 then message, 'L and M must be nonnegative!'
     if wm gt l then message, 'Must have M <= L !'
     if max(abs(x)) gt 1 then message, 'Absolute value of X must be <=1 !'
 
     res = (-1d)^wm*(1d - x^2)^(0.5d*wm)
     for i = 1l, wm - 1 do res = (2*i + 1)*res
 
     if wl gt wm then begin
 	lm1 = 0*res
 	for i = wm + 1, wl do begin
 	    lm2 = lm1
 	    lm1 = res
 	    res = (2d*i - 1d)/(i - wm)*(x*lm1 - lm2) + lm2
 	endfor
     endif
 
     return, Cast(res,4,Type(x),/fix)
 end
 
                                *** LINCROSS ***                        

 Function Lincross, fir, sec, lines = lin, cross = crp
 
 ;+
 ; NAME:
 ;	LINCROSS
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Finds the crossing point of two line segments or lines, in 2D.
 ; CATEGORY:
 ;	Geometry.
 ; CALLING SEQUENCE:
 ;	Result = LINCROSS( FIR, SEC [,LINES = LIN] [,CROSS = CRP])
 ; INPUTS:
 ;    FIR
 ;	First line/line_segment provided as a (2,2) array.  Two possible forms:
 ;	    1)	Segment:  Endpoints given by 2D vectors FIR(*,0) and FIR(*,1).
 ;	    2)  Line: Point on the line given by FIR(*,0), line direction by
 ;		FIR(*,1).
 ;	Whether FIR is interpreted as a line or a segment depends on the
 ;	value provided to LINES.  Default interpretation is segment.
 ;    SEC
 ;	Same as FIR, for the second line/line _segment.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    LINES
 ;	Numeric code specifying whether FIR and SEC should be considered lines
 ;	or segments.  Possible values are
 ;
 ;	LINES		FIR		SEC
 ;
 ;	0 or
 ;	undefined	segment		segment
 ;	1		line		segment
 ;	2		segment		line
 ;	3		line		line
 ;    CROSS
 ;	Optional output, see below.
 ; OUTPUTS:
 ;	Returns 1b if a crossing exists, 0b otherwise.  For lines a crossing
 ;	always exists, unless they happen to be parallel.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    CROSS
 ;	The name of a variable to receive the coordinates of the crossing point
 ;	as a 2D vector (X_cross,Y_cross).  If no crossing exists, both values
 ;	are set to the square root of the maximal floating value (machine
 ;	dependent).
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Calls DEFAULT, FPU_FIX and SOLVE_LINSYS from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 10-NOV-1997 by Mati Meron.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     sinf = machar()
     crp = sqrt(replicate(sinf.xmax, 2))
     lin =  0b > Default(lin,0b,/dtype) < 3b
     lfl = [lin mod 2b, lin/2b]
 
     if lfl(0) then begin
 	ap = fir(*,0)
 	ad = fir(*,1)
     endif else begin
 	ap = 0.5*(fir(*,1) + fir(*,0))
 	ad = fir(*,1) - fir(*,0)
     endelse
 
     if lfl(1) then begin
 	bp = sec(*,0)
 	bd = sec(*,1)
     endif else begin
 	bp = 0.5*(sec(*,1) + sec(*,0))
 	bd = sec(*,1) - sec(*,0)
     endelse
 
     if (ad(0)*bd(1) - ad(1)*bd(0)) ne 0 then begin
 	ctem = Solve_linsys([[ad],[-bd]], bp - ap, stat = isok)
 	isok = min(isok and (lfl or abs(ctem) le 0.5))
 	if isok then crp = FPU_fix(0.5*([[ad],[bd]]#ctem + ap + bp))
     endif else isok = 0b
 
     return, isok
 end
 
                               *** LINFIT_MM ***                       

 Function Linfit_mm, x, y, w, order = nord, residual = resid, $
     base = bas, params = pars, parmask = pmsk
 
 ;+
 ; NAME:
 ;	LINFIT_MM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Linear fitting with an arbitrary number of parameters.
 ; CATEGORY:
 ;	Mathematical Function.
 ; CALLING SEQUENCE:
 ;	Result = LINFIT_MM( X, Y [,W] [, keywords])
 ; INPUTS:
 ;    X
 ;	Numeric vector.  X coordinates of the data.
 ;    Y
 ;	Numeric vector.  Y coordinates of the data.  Same length as X.
 ; OPTIONAL INPUT PARAMETERS:
 ;    W
 ;	Numeric vector.  Weight parameters.  Same length as X.  Default is
 ;	constant weight (1).
 ; KEYWORD PARAMETERS:
 ;    ORDER
 ;	Specifies the order of the fit, i.e. one less than the number of free
 ;	parameters (or base functions).  If not given, the order will be read
 ;	from the number of entries in the BASE variable (see below).  If both
 ;	ORDER and BASE are specified, the higher one will determine the order.
 ;	Finally, if neither is specified, ORDER is set to 1 (meaning linear fit)
 ;    RESIDUAL
 ;	Optional output, see below.
 ;    BASE
 ;	Character array containing names of base functions.  Any blank entry
 ;	will be replaced by a power of X.  For example, if the third entry
 ;	(i = 2) is blank (or null string) the third base function will be X^2.
 ;    PARAMS
 ;	Array containing optional parameters (one per function) to be used in
 ;	the function calls.
 ;    PARMASK
 ;	Parameter mask, specifies which of the parameters are to be used.  A
 ;	nonzero entry means USE, zero means DON'T USE.  Default is USE for all
 ;	existing parameters.
 ; OUTPUTS:
 ;	Returns a vector containing the fit coefficients.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    RESIDUAL
 ;	The name of the variable to receive the residual Chi-Square value,
 ;	normalized to the number of degrees of freedom.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Standard linear optimization, using a Singular Value Decomposition
 ;	procedure to solve the linear system.  Uses DEFAULT, FPU_FIX,
 ;	SOLVE_LINSYS and TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 1-JUN-93 by Mati Meron.
 ;	Renamed from LINFIT to M_LINFIT to avoid clashes with an IDL library
 ;	routine bearing the same name.
 ;	Modified 20-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;	Renamed 25-SEP-1999 by Mati Meron, to LINFIT_MM.
 ;-
 
     on_error, 1
     nv = n_elements(x)
     if n_elements(y) ne nv then message, 'X ,Y lengths must be equal!'
     wei = Default(w,replicate(1.,nv),/dtype)
     if n_elements(wei) ne nv then message, 'X ,W lengths must be equal!'
 
     nord = Default(nord,1)
     bas = Default(bas, strarr(nord + 1))
     if Type(bas) ne 7 then message, 'Function names must be strings!'
     nbas = n_elements(bas)
     if nord gt (nbas-1) then begin
 	bas = [bas,strarr(nord-nbas+1)]
 	nbas = nord + 1
     endif else nord = nbas - 1
     bmsk = strtrim(bas) ne ''
 
     npars = n_elements(pars) < nbas
     if npars gt 0 then begin
 	pmsk = Default(pmsk,replicate(1,npars)) ne 0
 	npmsk = n_elements(pmsk) < npars
 	if npmsk lt nbas then pmsk = [pmsk,replicate(0,nbas-npmsk)]
     endif else pmsk = replicate(0,nbas)
 
     farr = make_array(nv, nord + 1, type = ((Type(x) > Type(y)) > 4))
     for i = 0l, nord do begin
 	if bmsk(i) then begin
 	    if pmsk(i) then farr(*,i) = call_function(bas(i),x,pars(i)) $
 	    else farr(*,i) = call_function(bas(i),x)
 	endif else farr(*,i) = x^i
 	farr(*,i) = FPU_fix(farr(*,i)*wei)
     endfor
     yw = FPU_fix(y*wei)
 
     res = Solve_linsys(farr,yw,/svd)
     resid = FPU_fix(sqrt(total((yw - farr#res)^2)/(nv - nbas)))
     return, res
 end
 
                               *** LNGAMMA_MM ***                      

 Function Lngamma_mm, x
 
 ;+
 ; NAME:
 ;	LNGAMMA_MM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the natural log of the gamma function.  Replacement for the
 ;	IDL LNGAMMA function which accepts only real input.
 ; CATEGORY:
 ;	Mathematical function (general).
 ; CALLING SEQUENCE:
 ;	Result = LNGAMMA_MM (X, A [,EPS ] [,/COMPLEMENTARY ])
 ; INPUTS:
 ;    X
 ;	Numeric, otherwise arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the natural logarithm of the gamma function of X.  Output type
 ;	and form are identical to those of the input (but output type is never
 ;	lower than FLOAT).
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	The real part of X should be positive.
 ; PROCEDURE:
 ;	Uses a continued fraction expansion.  Calls CAST, CONFRAC, DEFAULT,
 ;	TOLER and TYPE, from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 30-MAR-1996 by Mati Meron as M_LNGAMMA.
 ;	Renamed 25-SEP-1999 by Mati Meron, to LNGAMMA_MM.
 ;-
 
     on_error, 1
 
     nex = Default(nex,0d,/dtype)
     a = [1d/12d, 1d/30d, 53d/210d, 195d/371d, 22999d/22737d, $
 	29944523d/19733142d, 109535241009d/48264275462d, $
 	2.95520928d,3.34489801d,2.40361667d,1.19320621d,0.40123515d,0.07143468d]
 
     b = dblarr(n_elements(a),2)
     b(*,1) = 1d
     xpo = x + 1d
 
     res = 0.5d*alog(2d*!dpi) + (xpo - 0.5d)*alog(xpo) - xpo - alog(x) + $
 	Confrac(a,b,xpo,eps = Toler(x), /rel)
 
     return, Cast(res,4,Type(x))
 end
 
                               *** MAKE_GRID ***                       

 Function Make_grid, span, npoints, stepsize= stes, dimvec= wpoin, funarr = fnarr
 
 ;+
 ; NAME:
 ;	MAKE_GRID
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Generates a 1-6 dimensional grid of points within a specified range.
 ; CATEGORY:
 ;	Array manipulation.
 ; CALLING SEQUENCE:
 ;	Result = MAKE_GRID( SPAN, [ NPOINTS] [keywords])
 ; INPUTS:
 ;    SPAN
 ;	A (2,N) numeric array, where N <= 6 is the number of grid dimensions.
 ;	The pair of entries in SPAN(*,i) represents the coordinate minimum and
 ;	maximum in the i-th dimension of the grid.
 ; OPTIONAL INPUT PARAMETERS:
 ;    NPOINTS
 ;	A numeric vector containing the number of points along each dimension.
 ;	If not provided, the same number of points will be assigned to each
 ;	dimension.  This default number depends on the number of dimensions, as
 ;	follows:
 ;	    dimensions	|    points per dimension
 ;		1 		2^20
 ;		2		2^10
 ;		3		2^6
 ;		4		2^4
 ;		5		2^3
 ;		6		2^3
 ;	If NPOINTS has less entries then the number of dimensions, the missing
 ;	entries will be assigned the value of the last existing one.  If some
 ;	of the entries (but not the first) are 0 or 1, they'll be replaced by
 ;	the value of the preceding non-zero entry.
 ;
 ;	The meaning of NPOINTS changes if the optional keyword STEPSIZE is set.
 ;	In this case the entries in NPOINTS represent the step sizes along each
 ;	dimension (if not provided, stepsizes are set so as to yield the
 ;	default number of points per dimension as mentioned above).  If some of
 ;	the step sizes are bigger then the corresponding spans, they will be
 ;	adjusted to the span size.  Again, If some of the entries (but not the
 ;	first) are 0 or missing, they'll be replaced by the value of the
 ;	preceding non-zero entry.
 ;
 ;	Comment:  A NPOINTS entry of 1 is allowed if /STEPSIZE isn't set and
 ;	the corresponding minimum and maximum in SPAN are the same.
 ; KEYWORD PARAMETERS:
 ;    /STEPSIZE
 ;	Switch.  Specifies that the entries in NPOINTS are to be treated as
 ;	step sizes.
 ;    DIMVEC
 ;	Optional output, see below.
 ;    FUNARR
 ;	Optional output, see below.
 ; OUTPUTS:
 ;	Returns an array with the dimensions (NDIM,NPOINTS(0),...) where NDIM
 ;	is the number of dimensions of the grid, such that Result(*,i0,i1,...)
 ;	is a vector containing the cartesian coordinates of the point at
 ;	location (i0,i1,...) within the grid.  The output type is FLOAT (or
 ;	DOUBLE if SPAN is of type DOUBLE).
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    DIMVEC
 ;	The name of the variable to receive the vector (NPOINTS(0),
 ;	NPOINTS(1),...), containing the number of points along each dimension
 ;	in the result.
 ;    FUNARR
 ;	The name of the variable to receive a blank array of dimensions
 ;	(NPOINTS(0),NPOINTS(1),...).  This array can be used to receive the
 ;	values of a function evaluated over the grid.  The output type is FLOAT
 ;	(or DOUBLE if SPAN is of type DOUBLE).
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	The number of dimensions must not exceed 6.
 ; PROCEDURE:
 ;	Straightforward.  Uses CAST, DEFAULT, FPU_FIX and TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-JAN-1992 by Mati Meron.
 ;	Modified 15-AUG-1994 by Mati Meron.  Added the STEPSIZE option.  Also,
 ;	from now on, if SPAN is of type DOUBLE, the outputs are of type DOUBLE.
 ;	Modified 20-JAN-1997 by Mati Meron to allow for a single point along
 ;	dimension with a zero span.
 ;	Modified 15-SEP-1998 by Mati Meron.  Added keyword DIMVEC to return the
 ;	number of points used along each dimension (especially useful with the
 ;	/STEP option.  Also added underflow filtering.
 ;-
 
     on_error, 1
     ndmax = 6
     siz = size(span)
     if siz(1) ne 2 then message, 'Wrong span dimensions!'
     if siz(0) eq 1 then ndim = 1 else $
     if siz(0) eq 2 then ndim = siz(2) $
     else message, 'Wrong span dimensions!'
     if ndim gt ndmax then message, 'Too many dimensions!'
 
     wspan = Cast([span(0,*),span(1,*) - span(0,*)],4,5)
     dipt = 2l^fix((21 - alog(ndim + 1)/alog(2))/ndim)
 
     if keyword_set(stes) then begin
 	if wspan(1,0) eq 0 then message, 'Illegal span input!'
 	for i = 1, ndim - 1 do if wspan(1,i) eq 0 then wspan(1,i) = wspan(1,i-1)
 	wpoin = Default(npoints,FPU_fix(wspan(1,*)/(dipt-1)),low=4)
 	if wpoin(0) eq 0 then message, 'illegal stepsize input!'
 	npo = n_elements(wpoin)
 	if npo lt ndim then wpoin = [wpoin,replicate(0.,ndim-npo)]
 	for i = 1, ndim - 1 do if wpoin(i) eq 0 then wpoin(i) = wpoin(i-1)
 	wpoin = (reform(round(abs(wspan(1,*)/wpoin))) > 1) + 1
     endif else begin
 	wpoin = abs(Default(npoints,replicate(dipt,ndim),/dtype))
 	if wpoin(0) lt 1 then message, 'Illegal npoints input!'
 	npo = n_elements(wpoin)
 	if npo lt ndim then wpoin = [wpoin,replicate(0l,ndim-npo)]
 	for i = 1, ndim - 1 do if wpoin(i) eq 0 then wpoin(i) = wpoin(i-1)
 	dum = where(wpoin eq 1 and wspan(1,*) ne 0, ndum)
 	if ndum gt 0 then message, 'Cannot have nonzero span with one point!'
     endelse
 
     grarr = make_array(size = [ndim + 1,ndim,wpoin,Type(wspan),0])
     fnarr = reform(make_array(size = [ndim,wpoin,Type(wspan),0]),[wpoin])
 
     for i = 0, ndim - 1 do begin
 	if wpoin(i) eq 1 then tem = wspan(0,i) else $
 	tem = wspan(0,i) + wspan(1,i)/(wpoin(i) - 1)*findgen(wpoin(i))
 	case i of
 	    0:	for j = 0l, wpoin(i) - 1 do grarr(i,j,*,*,*,*,*) = tem(j)
 	    1:	for j = 0l, wpoin(i) - 1 do grarr(i,*,j,*,*,*,*) = tem(j)
 	    2:	for j = 0l, wpoin(i) - 1 do grarr(i,*,*,j,*,*,*) = tem(j)
 	    3:	for j = 0l, wpoin(i) - 1 do grarr(i,*,*,*,j,*,*) = tem(j)
 	    4:	for j = 0l, wpoin(i) - 1 do grarr(i,*,*,*,*,j,*) = tem(j)
 	    5:	for j = 0l, wpoin(i) - 1 do grarr(i,*,*,*,*,*,j) = tem(j)
 	endcase
     endfor
 
     grarr = FPU_fix(grarr)
     if ndim eq 1 then return, reform(grarr) else $
 	return, reform(grarr,[ndim,wpoin])
 end
 
                                 *** M_ABS ***                           

 Function M_abs, x
 
 ;+
 ; NAME:
 ;	M_ABS
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates absolute values.  A temporary fix needed since the IDL ABS
 ;	function fails with very large or very small complex numbers.
 ; CATEGORY:
 ;	Mathematical, general.
 ;	Obsolete, replaced by ABS_MM.
 ; PROCEDURE:
 ;	Calling ABS_MM and OBSTAT from MIDL.  See ABS_MM for details.
 ; MODIFICATION HISTORY:
 ;	Created 15-MAR-1996 by Mati Meron.
 ;	Modified 30-AUG-1998 by Mati Meron.  Underflow filtering added.
 ;	Replaced by ABS_MM on 30-SEP-1999.
 ;-
 
     Obstat
 
     return, Abs_mm(x)
 end
 
                                *** M_CONVOL ***                        

 Function M_Convol, far, gar, nocenter = noc, reverse = rev, clip = cli, $
     edge_val = edv, edge_truncate = edt
 
 ;+
 ; NAME:
 ;	M_CONVOL
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the convolution of two functions represented by arrays.
 ; CATEGORY:
 ;	Mathematical, array function.
 ;	Obsolete, replaced by CONVOL_MM.
 ; PROCEDURE:
 ;	Calls CONVOL_MM and OBSTAT from MIDL.  See CONVOL_MM for details.
 ; MODIFICATION HISTORY:
 ;	Created 15-NOV-1996 by Mati Meron.
 ;	Modified 20-JAN-1997 by Mati Meron.  Streamlined (through the use of
 ;	EXTEND_ARRAY and added keyword EDGE_TRUNCATE.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;	Replaced by CONVOL_MM on 30-SEP-1999.
 ;-
 
     Obstat
 
     return, Convol_mm(far,gar, nocenter = noc, reverse = rev, clip = cli, $
     edge_val = edv, edge_truncate = edt)
 end
 
                                *** M_ERRORF ***                        

 Function M_errorf, x, complementary = comp
 
 ;+
 ; NAME:
 ;	M_ERRORF
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the error function.  Replacement for the IDL ERRORF function
 ;	which accepts only real input.
 ; CATEGORY:
 ;	Mathematical function (general).
 ;	Obsolete, replaced by ERRORF_MM.
 ; PROCEDURE:
 ;	Calls ERRORF_MM and OBSTAT from MIDL.  SEE ERRORF_MM for details.
 ; MODIFICATION HISTORY:
 ;	Created 20-MAR-1996 by Mati Meron.
 ;	Replaced by ERRORF_MM on 30-SEP-1999.
 ;-
 
     Obstat
 
     return, Errorf_mm(x, complementary = comp)
 end
 
                                *** M_GAMMA ***                         

 Function M_gamma, x
 
 ;+
 ; NAME:
 ;	M_GAMMA
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the gamma function.  Replacement for the IDL GAMMA function
 ;	which accepts only real input.
 ; CATEGORY:
 ;	Mathematical, general.
 ;	Obsolete, replaced with GAMMA_MM.
 ; PROCEDURE:
 ;	Calls GAMMA_MM and OBSTAT from MIDL.  See GAMMA_MM for details.
 ; MODIFICATION HISTORY:
 ;	Created 30-MAR-1996 by Mati Meron.
 ;	Replaced by GAMMA_MM on 30-sep-1999.
 ;-
 
     Obstat
 
     return, Gamma_mm(x)
 end
 
                                *** M_IGAMMA ***                        

 Function M_Igamma, x, a, eps, complementary = comp
 
 ;+
 ; NAME:
 ;	M_IGAMMA
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the incomplete gamma function.  Replacement for the IDL
 ;	IGAMMA function which accepts only real input.
 ; CATEGORY:
 ;	Mathematical function (general).
 ;	Obsolete, replaced by IGAMMA_MM.
 ; PROCEDURE:
 ;	Calls IGAMMA_MM and OBSTAT from MIDL.  See IGAMMA_MM for details.
 ; MODIFICATION HISTORY:
 ;	Created 15-MAR-1996 by Mati Meron.
 ;	Modified 20-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;	Replaced by IGAMMA_MM on 30-SEP-1999.
 ;-
 
     Obstat
 
     return, Igamma_mm(x, a, eps, complementary = comp)
 end
 
                              *** M_IMAGINARY ***                     

 Function M_imaginary, x
 
 ;+
 ; NAME:
 ;	M_IMAGINARY
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Returns imaginary values.
 ; CATEGORY:
 ;	Mathematical, general.
 ;	Obsolete, replaced by IMAGINARY_MM.
 ; PROCEDURE:
 ;	Calls IMAGINARY_MM and OBSTAT from MIDL.  See IMAGINARY_MM for details.
 ; MODIFICATION HISTORY:
 ;	Created 5-MAY-1996 by Mati Meron.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;	Replaced by IMAGINARY_MM on 30-SEP-1999.
 ;-
 
     Obstat
 
     return, Imaginary_mm(x)
 end
 
                                *** M_LINFIT ***                        

 Function M_Linfit, x, y, w, order = nord, residual = resid, $
     base = bas, params = pars, parmask = pmsk
 
 ;+
 ; NAME:
 ;	M_LINFIT
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Linear fitting with an arbitrary number of parameters.
 ; CATEGORY:
 ;	Mathematical Function.
 ;	Obsolete, replaced by LINFIT_MM.
 ; CALLING SEQUENCE:
 ;	Result = M_LINFIT( X, Y [,W] [, keywords])
 ; PROCEDURE:
 ;	Calls LINFIT_MM and OBSTAT from MIDL.  See LINFIT_MM for details.
 ; MODIFICATION HISTORY:
 ;	Created 1-JUN-93 by Mati Meron.
 ;	Renamed from LINFIT to M_LINFIT to avoid clashes with an IDL library
 ;	routine bearing the same name.
 ;	Modified 20-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;	Replaced by LINFIT_MM on 30-SEP-1999.
 ;-
 
     Obstat
 
     Return, Linfit_mm(x, y, w, order = nord, residual = resid, $
     base = bas, params = pars, parmask = pmsk)
 end
 
                               *** M_LNGAMMA ***                       

 Function M_lngamma, x
 
 ;+
 ; NAME:
 ;	M_LNGAMMA
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the natural log of the gamma function.  Replacement for the
 ;	IDL LNGAMMA function which accepts only real input.
 ; CATEGORY:
 ;	Mathematical function (general).
 ;	Obsolete.  Replaced by LNGAMMA_MM.
 ; PROCEDURE:
 ;	Calls LNGAMMA_MM and OBSTAT from MIDL.  See LNGAMMA_MM for details.
 ; MODIFICATION HISTORY:
 ;	Created 30-MAR-1996 by Mati Meron.
 ;	Replaced by LNGAMMA_MM on 30-SEP-1999.
 ;-
 
     Obstat
 
     return, Lngamma_mm(x)
 end
 
                                *** M_NERFC ***                         

 Function M_nerfc, x
 
 ;+
 ; NAME:
 ;	M_NERFC
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates A renormalized complementary error function.
 ; CATEGORY:
 ;	Mathematical function.
 ;	Obsolete, replaced by NERFC_MM.
 ; PROCEDURE:
 ;	Calls NERFC_MM and OBSTAT from MIDL.  See NERFC_MM for details.
 ; MODIFICATION HISTORY:
 ;	Created 20-DEC-1994 by Mati Meron, under the name RENERF_FUN.
 ;	Renamed M_NERFC and completely rewritten 15-JAN-1996, by Mati Meron,
 ;	in order to enhance range and accuracy.
 ;	Modified 25-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;	Replaced by NERFC_MM on 30-SEP-1999.
 ;-
 
     Obstat
 
     return, Nerfc_mm(x)
 end
 
                                 *** M_REAL ***                          

 Function M_real, x
 
 ;+
 ; NAME:
 ;	M_REAL
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Returns real values.
 ; CATEGORY:
 ;	Mathematical, general.
 ;	Obsolete.  Replaced by REAL_MM.
 ; PROCEDURE:
 ;	Calls OBSTAT and REAL_MM from MIDL.  See REAL_MM for details.
 ; MODIFICATION HISTORY:
 ;	Created 5-MAY-1996 by Mati Meron.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;	Replaced by REAL_MM on 30-SEP-1999.
 ;-
 
     Obstat
 
     return, Real_mm(x)
 end
 
                                *** M_SMOOTH ***                        

 Function M_Smooth, arr, wid, deriv = nder, edge_truncate = edt
 
 ;+
 ; NAME:
 ;	M_SMOOTH
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Non broadening data smoothing.
 ; CATEGORY:
 ;	Array function.
 ;	Obsolete.  Replaced by SMOOTH_MM.
 ; PROCEDURE:
 ;	Calls OBSTAT and SMOOTH_MM from MIDL.  See SMOOTH_MM for details.
 ; MODIFICATION HISTORY:
 ;	Created 25-JAN-1997 by Mati Meron.
 ;	Replaced by SMOOTH_MM on 30-SEP-1999.
 ;-
 
     Obstat
 
     return, Smooth_mm( arr, wid, deriv = nder, edge_truncate = edt)
 end
 
                                 *** NATAN ***                           

 Function Natan, x, n, hyper = hyp
 
 ;+
 ; NAME:
 ;	NATAN
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the function /int{(1 + x^2)^(-n-1)}, or, optionally,
 ;	/int{(1 - x^2)^(-n-1)}
 ; CATEGORY:
 ;	Mathematical function.
 ; CALLING SEQUENCE:
 ;	Result = NATAN( X [, N [, /HYPER]])
 ; INPUTS:
 ;    X
 ;	Numerical, otherwise arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;    N
 ;	Integer scalar, defaults to 0.
 ; KEYWORD PARAMETERS:
 ;    /HYPER
 ;	Switch, turns on the "hyperbolic" option.
 ; OUTPUTS:
 ;	Returns /int{(1 + x^2)^(-n-1)} (for N = 0 it amounts to ATAN(X)), or,
 ;	if /HYPER is set, /int{(1 - x^2)^(-n-1)} (for N = 0 this is the
 ;	hyperbolic ATAN).  The result is of the same form as X, of type FLOAT
 ;	or higher (if X is of a higher type).
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	N must be >= 0, otherwise it is taken to be 0.
 ; PROCEDURE:
 ;	Exact evaluation in powers of 1/(1 + x^2).  Uses CAST, DEFAULT, FPU_FIX
 ;	and TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 30-MARCH-1994 by Mati Meron.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     n = Default(n,0,/dtype)
     if keyword_set(hyp) then begin
 	sgn = -1.
 	res = 0.5*alog((1. + x)/(1. - x))
     endif else begin
 	sgn = 1.
 	res = atan(x)
     endelse
 
     if n gt 0 then begin
 	xsiz = size(x)
 	xtyp = Type(x) > 4
 	ndim = xsiz(0)
 	nelm = xsiz(ndim+2)
 	xtem = Cast(reform([x],nelm),xtyp)
 	ytem = reform(make_array(nelm*n,type=xtyp),nelm,n)
 	ytem(*,0) = 1./(1. + sgn*xtem^2)
 	coef = 0.5
 	for i = 1l, n - 1 do begin
 	    ytem(*,i) =  2.*i/(2.*i + 1.)*ytem(*,0)*ytem(*,i-1)
 	    coef = (2.*i + 1.)/(2.*i + 2)*coef
 	endfor
 	ytem = xtem*total(ytem,2)
 	if ndim eq 0 then ytem = ytem(0) else ytem = reform(ytem,xsiz(1:ndim))
 	res = coef*(res + ytem)
     endif
 
     return, FPU_fix(res)
 end
 
                               *** NEIGHBORS ***                       

 Function Neighbors, ind, siz, count = cnt
 
 ;+
 ; NAME:
 ;	NEIGHBORS
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Finding the nearest neighbors of an array element.
 ; CATEGORY:
 ;	Array function.
 ; CALLING SEQUENCE:
 ;	Result = NEIGHBORS( IND, SIZ [, COUNT])
 ; INPUTS:
 ;    IND
 ;	Index of an array element.  Provided either in contracted (1-dim) or
 ;	expanded version.  In the second case IND has to be a vector the length
 ;	of which equals the number of dimension of the array (given by SIZ(0)).
 ;    SIZ
 ;	Vector in the form of the standard output of the system function SIZE.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    COUNT
 ;	An optional output parameter.  See below.
 ; OUTPUTS:
 ;	Returns a vector containing the indices of the nearest neighbors of the
 ;	element corresponding to IND.  If no neighbors exist returns -1.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    COUNT
 ;	The name of the variable to receive the number of neighbors.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Calls ARRLOC from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 30-MARCH-1994 by Mati Meron.
 ;-
 
     on_error, 1
     res = [-1l]
     ndim = siz(0)
 
     if ndim gt 0 then begin
 	nel = n_elements(ind)
 	if not (nel eq 1 or nel eq ndim) then message, 'Dimensional mismatch!'
 	if nel eq 1 then begin
 	    cind =ind
 	    eind = Arrloc(ind,siz,/expand)
 	endif else begin
 	    cind = Arrloc(ind,siz,/contract)
 	    eind = ind
 	endelse
 	if min([cind,eind]) ge 0 then begin
 	    nmult = replicate(1l,ndim)
 	    for i = 1, ndim - 1 do nmult(i) = nmult(i-1)*siz(i)
 	    for j = 0, ndim - 1 do begin
 		if eind(j) gt 0 then res = [res,cind - nmult(j)]
 		if eind(j) lt siz(j+1) - 1 then res = [res,cind + nmult(j)]
 	    endfor
 	    if n_elements(res) gt 1 then res = res(1:*)
 	endif
     endif
     dum = where(res ge 0,cnt)
 
     return, res
 end
 
                                *** NERFC_MM ***                        

 Function Nerfc_mm, x
 
 ;+
 ; NAME:
 ;	NERFC_MM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates A renormalized complementary error function.
 ; CATEGORY:
 ;	Mathematical function.
 ; CALLING SEQUENCE:
 ;	Result = NERFC_MM( X )
 ; INPUTS:
 ;    X
 ;	Numeric, otherwise arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ; OUTPUTS:
 ;	Returns the values of exp(x^2)*(1 - errorf(x)).  For larger values
 ;	of ;	X, above ~4, this values cannot be calculated directly from the
 ;	error function due to cancellation errors.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	For large and negative values of Real(x) an overflow may result.  A
 ;	warning is issued in such case.
 ; PROCEDURE:
 ;	Using direct calculation for small values of abs(x) and continued
 ;	fraction expansion for larger values.  Call ABS_MM, CAST, CONFRAC,
 ;	ERRORF_MM, ISNUM and REAL_MM, from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 20-DEC-1994 by Mati Meron, under the name RENERF_FUN.
 ;	Renamed M_NERFC and completely rewritten 15-JAN-1996, by Mati Meron,
 ;	in order to enhance range and accuracy.
 ;	Modified 25-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;	Renamed 25-SEP-1999 by Mati Meron, to NERFC_MM.
 ;-
 
     on_error, 1
     len = 32
 
     sinf = machar(double = Isnum(x,/double))
     cbound = alog(2d)*(sinf.maxexp - 4)
     hbound = alog(2d)*(sinf.maxexp - 1)
     isc = Isnum(x,/complex,type=typ)
     if isc then z = Cast(x,9) else z = Cast(x,5)
     res = 0*z
 
     tm = where(Abs_mm(z) lt sqrt(cbound), ntm)
     if ntm ne 0 then res(tm) = exp((z(tm))^2)*Errorf_mm(z(tm),/comp)
 
     tm = where(Abs_mm(z) ge sqrt(cbound), ntm)
     if ntm ne 0 then begin
 	a = 0.5d*dindgen(len)
 	a(0) = 1d/sqrt(!dpi)
 	b = dblarr(len,2)
 	b(*,1) = 1d
 	tz = z(tm)
 	tr = res(tm)
 	comp = Real_mm(tz^2)
 
 	sm = where(Real_mm(tz) ge 0, nsm)
 	if nsm ne 0 then tr(sm) = Confrac(a,b,tz(sm),/rel)
 	sm = where(Real_mm(tz) lt 0 and comp lt hbound, nsm)
 	if nsm ne 0 then tr(sm) = 2*exp((tz(sm))^2) - Confrac(a,b,-tz(sm),/rel)
 	sm = where(Real_mm(tz) lt 0 and comp ge hbound, nsm)
 	if nsm ne 0 then begin
 	    message, 'Function overflows for large negative values', /continue
 	    message, 'Replacing with machine maximum', /continue
 	    tr(sm) = sinf.xmax
 	endif
 
 	res(tm) = tr
     endif
 
     return, Cast(res,4,typ,/fix)
 end
 
                                 *** NOISE ***                           

 Function Noise, dat, poisson = pois, seed = sed
 
 ;+
 ; NAME:
 ;	NOISE
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Adds Gaussian or Poissonian noise to data.
 ; CATEGORY:
 ;	Mathematical function.
 ; CALLING SEQUENCE:
 ;	Result = NOISE( DAT [, keywords])
 ; INPUTS:
 ;    DAT
 ;	numerical, nonnegative.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /POISSON
 ;	Switch.  If set, Poisson noise is generated.  The default is gaussian.
 ;    SEED
 ;	Can be used to provide a randomization seed.  Optional but highly
 ;	recommended (with an uninitialized variable) when doing repeated calls
 ;	to NOISE.  See RESTRICTIONS below.
 ; OUTPUTS:
 ;	Returns the input data with noise added to it.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	NOISE relies on the IDL routines RANDOMU and RANDOMN which, in the
 ;	absence of externally provided seed generate one using the system
 ;	time.  When consecutive calls to NOISE are made on a fast machine,
 ;	they may occur within a single "clock tick" yielding the same random
 ;	series.  This is highly undesirable.  The problem can be avoided if
 ;	NOISE is always called with SEED = S when S is an uninitialized
 ;	variable.
 ; PROCEDURE:
 ;	Generates Gauss-distributed (with sigma = square_root(dat)) random
 ;	numbers for gaussian noise.  Uses the rejection method for Poisson
 ;	noise.  Calls CAST, DEFAULT and FPU_FIX from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 25-JAN-1997 by Mati Meron.
 ;	Modified 10-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     neld = n_elements(dat)
     if neld eq 0 then message, 'No data!'
     mult = Default(mult,1.,/dtype)
     wdat = Cast(dat,3,3) > 0
 
     if keyword_set(pois) then begin
 	slim = long(2d^31 - 2)
 	sdat = sqrt(2*wdat)
 	res = -wdat
 	a = where(res lt 0, ndo)
 
 	while ndo gt 0 do begin
 	    kres = wdat(a) + sdat(a)*tan(!pi*(randomu(sed,ndo) - 0.5))
 	    kres = floor(-slim > kres < slim)
 	    b = where (kres ge 0, ndo)
 	    if ndo gt 0 then begin
 		ab = a(b)
 		u = wdat(ab)
 		su = sdat(ab)
 		v = kres(b) + 0.5
 		rat = exp(v*(1 + alog(u/(v - 1./(24*v)))) - u)* $
 		      su/(2*u + 1./6)/atan(su, (v - u)^2 + 2*u - 0.25)
 		c = where(rat ge randomu(sed,ndo), ndo)
 		if ndo gt 0 then res(ab(c)) = kres(b(c))
 	    endif
 	    a = where(res lt 0, ndo)
 	endwhile
     endif else res = wdat + round(sqrt(dat)*randomn(sed,neld))
 
     return, FPU_fix(res)
 end
 
                                 *** OBSTAT ***                          

 Pro Obstat, reset = res
 
 ;+
 ; NAME:
 ;	OBSTAT
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Providing informational messages about obsolete routines.
 ; CATEGORY:
 ;	Utility.
 ; CALLING SEQUENCE:
 ;	OBSTAT [,/RESET]
 ; INPUTS:
 ;	None.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /RESET
 ;	Switch.  Normally OBSTAT issues a warning message only once per session
 ;	for each called obsolete routine.  Calling OBSTAT with RESET set,
 ;	resets the message counter.
 ; OUTPUTS:
 ;	None other than screen output.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	MERON_OBSOLETE_ROUTINES
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	OBSTAT maintains a list of obsolete routines and their replacements.
 ;	When called from MAIN, OBSTAT diplays the full list.  When called from
 ;	within a specific routine, OBSTAT checks whether this routine is on the
 ;	obsolete list.  If yes, the action taken is one of the following:
 ;
 ;	If the routine, though obsolete, is still maintained, a warning message
 ;	to the effect is issued, together with the name of the replacement
 ;	routine.  Program execution then proceeds normally.  The message is
 ;	issued only once per IDL section (on the first call to the routine).
 ;
 ;	If the routine is no longer maintained, an error message is issued,
 ;	together with the name of the replacement routine.  The program then
 ;	quits and returns to the calling routine.  The message is issued on
 ;	every call to the obsolete routine.
 ;
 ;	OBSTAT Calls STRMATCH_MM, STRPARSE_MM and TABULATE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 30-SEP-1999 by Mati Meron.
 ;-
 
     common meron_obsolete_routines, exs, mor_inf
 
     on_error, 2
 
     blank = {routstat, old_name: '', new_name: '', stat: 0, checked: 0}
 
     old = ['BESELK', 'M_ABS', 'M_CONVOL', 'M_ERRORF', $
 	'M_GAMMA', 'M_IGAMMA', 'M_IMAGINARY', 'M_LINFIT', $
 	'M_LNGAMMA', 'M_NERFC', 'M_REAL', 'M_SMOOTH', $
 	'STRMATCH', 'STRPARSE']
 
     new = ['BESELK_MM', 'ABS_MM', 'CONVOL_MM', 'ERRORF_MM', $
 	'GAMMA_MM', 'IGAMMA_MM', 'IMAGINARY_MM', 'LINFIT_MM', $
 	'LNGAMMA_MM', 'NERFC_MM', 'REAL_MM', 'SMOOTH_MM', $
 	'STRMATCH_MM', 'STRPARSE_MM']
 
     stat = [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1]
 
     stmesg = ['		Old routine is no longer supported', $
 	'		Old routine is still temporarily supported']
 
     if N_elements(exs) eq 0 or keyword_set(res) then begin
 	nr = n_elements(stat)
 	if n_elements(old) ne nr or n_elements(new) ne nr then $
 	message, 'Lists are screwed up!'
 	mor_inf = replicate(blank,nr)
 	for i = 0, nr - 1 do begin
 	    mor_inf(i).old_name = old(i)
 	    mor_inf(i).new_name = new(i)
 	    mor_inf(i).stat = stat(i)
 	endfor
 	exs = 1
     endif
 
     help, /traceback, output = out
     snum = Strparse_mm(out(1),' 	',list)
     rname = list(1)
     kr = Strmatch_mm(rname,mor_inf.old_name)
 
     if kr ge 0 then begin
 	if not mor_inf(kr).checked then begin
 	    print, string(7b)
 	    mesg = '	The routine ' + rname + ' has been replaced by ' + $
 	    mor_inf(kr).new_name + string([10b,13b]) + stmesg(mor_inf(kr).stat)
 	    message, mesg, continue = mor_inf(kr).stat
 	    mor_inf(kr).checked = mor_inf(kr).stat
 	endif
     endif else begin
 	if strpos(rname,'MAIN') ge 0 then Tabulate, $
 	mor_inf.old_name, mor_inf.new_name, tit= 'MIDL Routine replacements', $
 	head = ['Old routine', 'New routine']
     endelse
 
     return
 end
 
                                 *** ONE_OF ***                          

 Function One_of, v_0, v_1, v_2, v_3, v_4, v_5, v_6, v_7, value = val
 
 ;+
 ; NAME:
 ;	ONE_OF
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Called with up to 8 variables V_0 through V_7 , ONE_OF checks which
 ;	variable is defined (only one is supposed to be).
 ; CATEGORY:
 ;	Programming.
 ; CALLING SEQUENCE:
 ;	Result = ONE_OF( V_0 [,V_1, ... V_7] [, VALUE = VAL])
 ; INPUTS:
 ;    V_0 through V_7
 ;	Arbitrary, all are optional.
 ; OPTIONAL INPUT PARAMETERS:
 ;	See above.
 ; KEYWORD PARAMETERS:
 ;    VALUE
 ;	Optional output, see below.
 ; OUTPUTS:
 ;	Returns the serial number (range 0 through 7) of the defined variable,
 ;	or -1 if none is defined.  If more than one variable is defined, ONE_OF
 ;	issues an error message and returns to the main level.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    VALUE
 ;	The name of the variable to receive the value of the single defined
 ;	variable, or a null string if none is defined.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	Currently ONE_OF is restricted to a maximum of 8 variables.  If needed,
 ;	the number can be increased.
 ; PROCEDURE:
 ;	Straightforward.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Modified 30-JUL-1991 by Mati Meron.  The dependence of the original
 ;	code on the EXECUTE system routine has been eliminated in order to
 ;	assure compatibility with the OUTPUT routine.
 ;	Modified 15-NOV-1993 by Mati Meron.  Since IDL now allows for recursive
 ;	calls to EXECUTE, the original code has been restored.
 ;-
 
     on_error, 1
     vnams = ['v_0','v_1','v_2','v_3','v_4','v_5','v_6','v_7']
     exlist = lonarr(8)
     exind = -1l
     val = ''
 
     for i = 0, n_params() - 1 do idum = $
 	execute('exlist(i) = n_elements(' + vnams(i) + ')')
     wex = where(exlist gt 0, nex)
     if nex eq 1 then begin
 	 exind = wex(0)
 	idum = execute('val = ' + vnams(exind))
     endif else if nex gt 1 then message, 'Only one variable may be defined!'
     return, exind
 end
 
                                 *** OUTPUT ***                          

 Pro Output, comm, que = qu, file = fil, option = opt, keep = kp, beep = bp, $
     mail = nam, subst = sub, v_0, v_1, v_2, v_3, v_4, v_5, v_6, v_7
 
 ;+
 ; NAME:
 ;	OUTPUT
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Generic output interface.  Allows sending the results of virtually any
 ;	IDL command or file to any predefined hard copy device.  In detail,
 ;	OUTPUT executes the provided command, writes the output to a file and
 ;	sends the file to a printout que.  Currently a VMS routine only.
 ; CATEGORY:
 ;	Input/Output.
 ; CALLING SEQUENCE:
 ;	OUTPUT, COMM [, keywords] [,optional input parameters]
 ; INPUTS:
 ;    COMM
 ;	Character value representing a valid IDL command.  Can be (and usually
 ;	is) a procedure or function call.
 ; OPTIONAL INPUT PARAMETERS:
 ;    V_0 through V_7
 ;	Serve to pass variables which are used in the command COMM.  Since COMM
 ;	is passed to output as a single string, OUTPUT is not receiving the
 ;	values of any variables used by COMM.  If such values are needed they
 ;	have to be passed separately.  This is done using the variables V_0
 ;	through V_7 in combination with the keyword SUBST (see below), which
 ;	accepts a string made of the names of the variables separated by spaces
 ;	or commas.
 ;	Example:
 ;	    Assume a routine named NEWPLOT which is called using the syntax
 ;		NEWPLOT, I, X, SCOPE = Y
 ;	    If at the time of call I, X, and Y have known values, say 3, 12.4
 ;	    and [12,95] then it is possible to issue the command
 ;		OUTPUT, 'NEWPLOT, 3, 12.4, SCOPE = [12,95]'
 ;	    If, on the other hand one would want to pass NEWPLOT to output
 ;	    using the variables K, E and RANG for I, X, Y, the command can be
 ;		OUTPUT, 'NEWPLOT, I, X, SCOPE = Y', $
 ;		SUBST = 'I,X   Y', K, E, RANG
 ;	    The order in which the variable names appear in SUBST is arbitrary
 ;	    but it has to be in a one-to-one correspondence with the order in
 ;	    which the actual arguments are given.  Therefore, the following is
 ;	    equally valid
 ;		OUTPUT, 'NEWPLOT, I, X, SCOPE = Y', $
 ;		SUBST = 'Y, I, X', RANG, K, E
 ; KEYWORD PARAMETERS:
 ;    QUE
 ;	Accepts a string and sets the printout queue.  Currently accepted
 ;	values and the queues they represent are as follows:
 ;	    'LN03'	-  The LN03 printer at the X26.
 ;	    'SIXEL'	-  The SIXEL printer in 901.
 ;	    'EPS'	-  Writes an encapsulated PostScript file, no printout.
 ;	    'FILE'	-  Writes a PostScript file, no printout.
 ;	    'PHASER'	-  Phaser color printer.  Valid only in BNL.
 ;	    'TRANSP'	-  Phaser Printer with LEGAL sized paper.  Use this
 ;			   one for transparencies.
 ;	    'CARS1'	-  The PostScript printer at CARS1.
 ;	    'SYS$PRINT'	-  Generic PostScript.  This is the initial Default.
 ;	This is by no means the final list, as new queues keep being added from
 ;	time to time.  For all queues on this list only the first three
 ;	characters of the name are needed as input.
 ;	If a queue name not on the list is entered, OUTPUT will use this name
 ;	with the parameters of the default queue, SYS$PRINT.  If no queue name
 ;	is entered, output will use SYS$PRINT when first called, and the name
 ;	of the last queue used subsequently.
 ;    FIL
 ;	Accepts a string representing a valid VMS file name.
 ;	Extension isn't necessery.  Default is 'IDL'.
 ;    /KEEP
 ;	Switch.  Specifies file disposition.  If set, the file is kept after
 ;	printout.  The default is 'DELETE', unless the queue is 'EPS' or 'FILE'.
 ;    /BEEP
 ;	Switch.  If set, a beep will sound when OUTPUT finishes processing the
 ;	file, and another beep sounds when the printout is complete.  Useful
 ;	for long files.  Also, if set, the VAX verifies that the printer is on.
 ;    OPTION
 ;	Accepts a string representing a valid IDL command.  If given, this
 ;	command will be executed BEFORE COMM.  If the command in OPTION
 ;	includes variables, their values can be passed using the same mechanism
 ;	as the one used for COMM (see above).
 ;    MAIL
 ;	Name of a recipient to whom the resulting file is mailed.  Optional.
 ;    SUBST
 ;	Accepts a string containing the names of the variables which are to
 ;	receive the values V_0 through V_7 (or part of them) for substitution
 ;	purposes.  Commas and/or spaces are valid delimiters.
 ; OUTPUTS:
 ;	None, other then the file that's created and whatever outputs are
 ;	generated by COMM.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	M_OUT_PREFS.  Contains the name of the last queue used.
 ; SIDE EFFECTS:
 ;	OUTPUT tries to avoid any side effects, as far as possible.
 ;	Specifically, the values of all the system variables are reset at exit
 ;	from OUTPUT to the values they had before output was called.  Still,
 ;	since COMM can be any possible command, side effects cannot be totally
 ;	avoided.
 ;	A currently known side effect has to do with PostScript printers.  If
 ;	either COMM or OPTION change the postscipt settings, the new settings
 ;	will remain in effect after OUTPUT exits.
 ; RESTRICTIONS:
 ;    1) With IDL before version 3.1, the commands in COMM and OPTION (if used)
 ;	are not allowed to use calls to the EXECUTE system routine, either
 ;	directly or indirectly.  This is so since OUTPUT itself relies on
 ;	EXECUTE and since EXECUTE (in older versions of IDL) could not be
 ;	called recursively.
 ;    2) Currently the number of substitution variables is limited to 8.  If
 ;	it'll turn out that this number isn't sufficient it can be easily
 ;	increased.  Let me know.
 ;    3) The commands in COMM (and OPTION) shouldn't change the output device
 ;	(i.e. NO using SET_PLOT, DEVICE/CLOSE, etc., all this is taken care of
 ;	by OUTPUT).  If they do, no error will result but the outcome will be
 ;	unpredictable.
 ;    4) In order to make the best use of OUTPUT it is recommended that the
 ;	commands in COMM will be totally device independent (i.e. no using
 ;	explicit device coordinates etc.).  This allows to send the output of
 ;	the same procedure to the various printers and get consistent results.
 ;	If one finds it necessery to use some device specific commands (like
 ;	setting a color table for the Phaser printer), they should be put in
 ;	OPTION (that's really the whole purpose of having OPTION)
 ; PROCEDURE:
 ;	OUTPUT contains a list of the appropriate device opening and closing
 ;	commands for the ques it recognizes.  When called, it does the
 ;	following.
 ;	1)  Checks QUE and if recognizable generates the appropriate OPEN,
 ;	CLOSE and PRINTOUT commands.  If QUE isn't recognized, OUTPUT assumes
 ;	SYS$PRINT.
 ;	2)  Performs variable substitution if so specified (by a non-blank
 ;	value of SUBST)
 ;	3)  Opens device.
 ;	4)  Executes OPTION, if given.
 ;	5)  Executes COMM
 ;	6)  Closes device.
 ;	7)  Optionally mails the file to the specified recipient.
 ;	8)  Spawns PRINT command to the appropriate que (unless que = 'EPS' or
 ;	'FILE' is specified).
 ;	9)  Deletes the file unless specified otherwise.
 ;
 ;	OUTPUT uses various routines from MIDL, namely:
 ;	DEFAULT, PLVAR_KEEP, STREQ, STRMATCH_MM, STRPARSE_MM and TYPE.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Modified 15-SEP-1991 by Mati Meron.  Added Phaser and Sixel support.
 ;	Modified 15-NOV-1991 by Mati Meron.  Added the 'TRANSP' que and the
 ;	/BEEP keyword.
 ;	Modified 28-DEC-1991 by Mati Meron.  Now any changes made to the color
 ;	table of PostScript devices by either COMM or OPTION are undone before
 ;	OUTPUT exits.
 ;	Modified 15-MAY-1993 by Mati Meron.  Added 'EPS', 'FILE' and 'CARS1'
 ;	queues.
 ;	Modified 20-NOV-1993 by Mati Meron.  Introduced SYS$PRINT as default
 ;	queue and maintenance of last que as current default.
 ;-
 
     common m_out_prefs, outque
 
     posib = ['LN03','SIXEL', 'EPS','FILE','PHASER','TRANSP','CARS1','SYS$PRINT']
     ext   = [ '.LN','.SXL.','.EPS', '.PS',   '.PS',   '.PS',  '.PS',      '.PS']
     fcod =  [0,0,1,1,0,0,0,0]
     opcom = ['ln03, outfile', $
 	     'set_plot, ''SIXEL'' &device, /landscape, file = outfile', $
 	     'set_plot, ''PS'' &device, /encapsulated, file = outfile', $
 	     'set_plot, ''PS'' &device, /landscape, file = outfile', $
 	     'set_plot, ''PS'' &device, /landscape, /color, file = outfile', $
 	     'set_plot, ''PS'' &device, /landscape, /color, file = outfile', $
 	     'set_plot, ''PS'' &device, /landscape, file = outfile', $
 	     'set_plot, ''PS'' &device, /landscape, file = outfile']
     clcom = ['ln03','device, /close', 'device, /close', 'device, /close', $
     	    'device, /close','device, /close','device, /close','device, /close']
     npos = n_elements(posib)
 
     on_error, 1
     if Type(comm) ne 7 then message, 'No command on line!'
     outque = Default(qu,Default(outque,'SYS$PRINT'),/strict)
     nqu = (StrMatch_mm(outque,posib,3) + npos) mod npos
     outfile = Default(fil,'IDL', /strict)
     if Strparse_mm(outfile,'.') eq 0 then outfile = outfile + ext(nqu)
     if (fcod(nqu) or keyword_set(kp)) then disp = ' ' else disp = '/delete '
     if keyword_set(bp) then disp = '/notify' + disp
 
     if Type(sub) eq 7 then begin
 	snams = ['v_0','v_1','v_2','v_3','v_4','v_5','v_6','v_7']
 	vnum = Strparse_mm(sub,' ,',vlist)
 	if n_params() gt vnum then begin
 	    for i_v = 0, vnum do idum = execute(vlist(i_v) + ' = ' + snams(i_v))
 	endif else message, 'Insuficient number of substitution variables!'
     endif
 
     Plvar_keep, action = 'save'
 
     dum = execute(opcom(nqu))
     if !d.name eq 'PS' then tvlct, red, gre, blu, /get
     if Type(opt) ne 7 then comstat = 1 else comstat = execute(opt)
     if comstat then comstat = execute(comm)
     print, ''
     if !d.name eq 'PS' then tvlct, red, gre, blu
     dum = execute(clcom(nqu))
 
     Plvar_keep, action = 'restore'
 
     if comstat then begin
 	if n_elements(nam) ne 0 then spawn, 'mail ' + outfile + ' ' + nam
 	if not fcod(nqu) then begin
 	    spawn, 'print/que=' + outque + disp + outfile, tem
 	    print, tem
 	    if Streq(tem(0),'%',1) then spawn, 'delete ' + outfile + ';'
 	endif
     endif else begin
 	message, 'Command errors, output file deleted!', /continue
 	spawn, 'delete ' + outfile + ';'
     endelse
 
     if keyword_set(bp) then print, string(007B)
     return
 end
 
                                 *** PARTOT ***                          

 Function Partot, farr, tod, low = lo, high = hi, lofringe = lf, hifringe = hf, $
     symedge = syme, symfringe = symf
 
 ;+
 ; NAME:
 ;	PARTOT
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Array summation.
 ; CATEGORY:
 ;	Array Function.
 ; CALLING SEQUENCE:
 ;	Result = PARTOT( FARR [, TOD] [, keywords])
 ; INPUTS:
 ;    FARR
 ;	Array, numeric, otherwise arbitrary (scalars accepted too).
 ; OPTIONAL INPUT PARAMETERS:
 ;    TOD
 ;	Totaling dimension.  Must be integer in the range of
 ;	[1, number of array dimensions]
 ; KEYWORD PARAMETERS:
 ;
 ;	warning!!!
 ;	The keywords are divided into two groups
 ;	1) regular mode:	LOW, HIGH, LOFRINGE, HIFRINGE
 ;	2) symmetric mode	SYMEDGE, SYMFRINGE
 ;
 ;	Either group (1) or (2) may be used.  Mixing will cause error.
 ;
 ;    LOW
 ;	Numeric vector (or scalar) containing starting channels for summation
 ;	for each dimension.  First entry corresponds to first dimension,
 ;	second to second dimension etc.  If number of entries is smaller then
 ;	number of dimensions, the remaining ones are replaced by 0.  If it is
 ;	larger then number of dimensions, the excess is ignored.  If absent,
 ;	all the values are replaced by 0.
 ;	Alternatively:  If TOD is used, LOW must be scalar (or vector of length
 ;	1), providing the summation start for the dimension specified by TOD.
 ;	Again, if absent, it is replaced by 0.
 ;    HIGH
 ;	Numeric vector (or scalar) containing starting channels for summation
 ;	for each dimension.  First entry corresponds to first dimension,
 ;	second to second dimension etc.  If number of entries is smaller then
 ;	number of dimensions, the remaining ones are replaced by 0.  If it is
 ;	larger then number of dimensions, the excess is ignored.  If absent,
 ;	all the values are replaced by 0.
 ;	Alternatively:  If TOD is used, LOW must be scalar (or vector of length
 ;	1), providing the summation start for the dimension specified by TOD.
 ;	Again, if absent, it is replaced by 0.
 ;    HIGH
 ;	Same as LOW for ending summation channel.  Missing values are replaced
 ;	by maximal value.  For example, if the array has dimensions [7,8,12]
 ;	and HIGH is given as [6,5] then internally [6,5,11] is used (maximal
 ;	value is always dimension - 1).
 ;    LOFRINGE
 ;	Numeric vector (or scalar) specifying partial counting of the value
 ;	in the first summation channel.  Acceptable values are in the
 ;	[-0.5, 0.5] range.  For example if the array has dimensions [6,8,10],
 ;	LOW is [2,1,5] and LOFRINGE = [0.2, 0.3,-0.4] then the beginning
 ;	elements in the first dimension, arr(2,*,*), will be multiplied by
 ;	(1 + 0.2) = 1.2 while the beginning elements in the third dimension,
 ;	arr(*,*,5) will be multiplied by (1 - 0.4) = 0.6.  If the number of
 ;	entries is shorter then the number of dimensions, it'll be padded with
 ;	zeros.  If it is larger, the excess will be ignored.  If absent
 ;	alltogether, zeros will be used.
 ;	Alternatively:  If TOD is used, LOFRINGE must be scalar (or vector of
 ;	length 1), and is applied to the summation dimension specified by TOD.
 ;	Again, if absent, it is replaced by 0.
 ;    HIFRINGE
 ;	Same as LOFRINGE but applied to the ending channel.
 ;
 ;    SYMEDGE
 ;	Used in a symmetrical mode.  IN this case the start and end channels
 ;	for each dimension are counted symmetrically from the center.  If the
 ;	number of channels in a specific dimension is odd then the center is
 ;	the middle channel.  For example for a vector of length 9 (indices
 ;	0 through 8) index of 4 (fifth element) gives the center.  For a vector
 ;	of length 8 (indices 0 through 7) the center is at the imaginary point
 ;	between indices 3 and 4.
 ;	Example:
 ;	Assume and array with dimensions [8,9,10] and SYMEDGE given as [3,3]
 ;	Thus:
 ;	On first dimension summation is from index 1 to index 6 (3 on each side
 ;	of the center, 6 total).
 ;	On second dimension summation is from index 1 to index 7 (3 on each
 ;	side, 7 total since the center is now also included).
 ;	On third dimension, since no data is provided, the summation is from
 ;	index 0 to index 9 (i.e full)
 ;	Alternatively:  If TOD is used, SYMEDGE must be scalar (or vector of
 ;	length 1), and is applied to the summation dimension specified by TOD.
 ;    SYMFRINGE
 ;	Same as LOFRINGE and HIFRINGE in the regular case.  Applied to both
 ;	summation limits, symmetrically.
 ; OUTPUTS:
 ;	Scalar equal the value of the summation, unless TOD is used, in which
 ;	case the output is an array with one less dimension then the original
 ;	one.  This is identical to the behavior of the IDL function TOTAL.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	1)  The array must be numerical.
 ;	2)  Mixing keywords from the regular and symmetrical group is not
 ;	    allowed.
 ;	3)  The value of TOD cannot exceed the number of dimensions.
 ;	4)  If TOD is used, all the edges and fringes provided by the
 ;	    keywords must have no more then one element.
 ;	5)  The values given by LOW mustn't exceed these given by HIGH.
 ; PROCEDURE:
 ;	A straightforward generalization on the IDL function TOTAL, making it
 ;	closer to a variable limit numerical integration.  Calling DEFAULT and
 ;	ISNUM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 30-OCT-1996 by Mati Meron.
 ;-
 
     on_error, 1
     ndmx = 7
 
     if not Isnum(farr) then message, 'Only numerical arrays allowed'
     siz = size(farr)
     dim = siz(0)
     tod = Default(tod,0l,/dtype)
     tofl = tod gt 0
 
     nlo = n_elements(lo) < dim
     nhi = n_elements(hi) < dim
     nlf = n_elements(lf) < dim
     nhf = n_elements(hf) < dim
     nse = n_elements(syme) < dim
     nsf = n_elements(symf) < dim
 
     syfl = max([nse,nsf]) gt 0
     if syfl and max([nlo,nhi,nlf,nhf]) gt 0 then $
     message, 'Either regular or symmetric mode must be used!'
 
     if tofl then begin
 	if tod gt dim then message, 'Invalid summation dimension!'
 	if (syfl and (max([nse,nsf]) gt 1)) or $
 	((not syfl) and (max([nlo,nhi,nlf,nhf]) gt 1)) then $
 	message, 'Only scalar limits and fringes allowed with 1D summation!'
     endif
 
     if dim gt 0 then begin
 	a = replicate(0l,ndmx)
 	b = [siz(1:dim)-1, a(dim:*)]
 	tem = b
 	lfr = replicate(0.,ndmx)
 	hfr = lfr
 
 	if syfl then begin
 	    if nse gt 0 then begin
 		if tofl then begin
 		    a(tod-1) = (tem(tod-1) + 1)/2 - syme
 		    b(tod-1) = tem(tod-1)/2 + syme
 		endif else begin
 		    a(0:nse-1) = (tem(0:nse-1) + 1)/2 - syme
 		    b(0:nse-1) = tem(0:nse-1)/2 + syme
 		endelse
 	    endif
 
 	    if nsf gt 0 then begin
 		if tofl then begin
 		    lfr(tod-1) = symf
 		    hfr(tod-1) = symf
 		endif else begin
 		    lfr(0:nsf-1) = symf
 		    hfr(0:nsf-1) = symf
 		endelse
 	    endif
 
 	endif else begin
 	    if nlo gt 0 then if tofl then a(tod-1) = lo else a(0:nlo-1) = lo
 	    if nhi gt 0 then if tofl then b(tod-1) = hi else b(0:nhi-1) = hi
 	    if nlf gt 0 then if tofl then lfr(tod-1) = lf else lfr(0:nlf-1) = lf
 	    if nhf gt 0 then if tofl then hfr(tod-1) = hf else hfr(0:nhf-1) = hf
 	endelse
 
 	a = a > 0 < tem
 	b = b > 0 < tem
 	tem = where(a gt b, ntem)
 	if ntem gt 0 then message, 'lower limits cannot exceed upper limits!'
 	lfr = lfr > (-0.5) < 0.5
 	hfr = hfr > (-0.5) < 0.5
 
 	res = farr $
 	(a(0):b(0),a(1):b(1),a(2):b(2),a(3):b(3),a(4):b(4),a(5):b(5),a(6):b(6))
 
 	b = b - a
 	a = a - a
 
 	if (size(res))(0) lt dim then res = reform(res,(b+1)(0:dim-1))
 	if tofl then s = [tod - 1] else s = dim - lindgen(dim) - 1
 
 	for i = 0, n_elements(s) - 1 do begin
 	    tres = total(res,s(i)+1)
 	    a(s(i)) = b(s(i))
 	    hcor = hfr(s(i))*res(a(0):b(0),a(1):b(1),a(2):b(2),a(3):b(3),$
 			a(4):b(4),a(5):b(5),a(6):b(6))
 	    a(s(i)) = 0
 	    b(s(i)) = 0
 	    lcor = lfr(s(i))*res(a(0):b(0),a(1):b(1),a(2):b(2),a(3):b(3),$
 			a(4):b(4),a(5):b(5),a(6):b(6))
 
 	    res = tres + lcor + hcor
 	endfor
 	if not tofl or dim eq 1 then res = res(0)
     endif else res = farr
 
     return, res
 end
 
                                 *** PLOTOT ***                          

 Pro Plotot, x, y, xtype = xtyp, ytype = ytyp, ynozero = ynz, $
     psym = psm, linestyle = linst, color = col, _extra = _e
 
 ;+
 ; NAME:
 ;	PLOTOT
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Plots multiple data sets on a single plot.
 ; CATEGORY:
 ;	Plotting.
 ; CALLING SEQUENCE:
 ;	PLOTOT, [X,] Y [, optional keywords]
 ; INPUTS:
 ;    Y
 ;	A numeric vector or 2 dimensional array containing the Y coordinates of
 ;	the data.  If Y is a vector PLOTOT operates same as PLOT.  If it is
 ;	a 2-dim.array, each row is ploted separately.  It is assumed that the
 ;	number of points per plot is larger than the number of plots so that if
 ;	Y is an (M*N) array with N > M, it will be transposed prior to plotting.
 ; OPTIONAL INPUT PARAMETERS:
 ;    X
 ;	A numeric vector containing the X coordinates of the data.  If absent
 ;	it is replaced by the vector [0, 1, 2 ...].
 ; KEYWORD PARAMETERS:
 ;    XTYPE
 ;	Standard IDL plotting interpretation.
 ;    YTYPE
 ;	Ditto.
 ;    /YNOZERO
 ;	Ditto.
 ;    PSYM
 ;	Ditto.  If given as a vector consecutive elements are applied to
 ;	consecutive plots.
 ;    LINESTYLE
 ;	Ditto.  If given as a vector consecutive elements are applied to
 ;	consecutive plots.
 ;    COLOR
 ;	Ditto.  If given as a vector consecutive elements are applied to
 ;	consecutive plots.
 ;    _EXTRA
 ;       A formal keyword used to pass all plotting keywords.  Not to be used
 ;       directly.
 ; OUTPUTS:
 ;	None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Uses calls to DEFAULT, SIGN and WHERINSTRUCT in MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 30-JUL-1991 by Mati Meron.
 ;       Modified 15-JAN-1994 by Mati Meron.  Now PLOTOT takes advantage of the
 ;       keyword inheritance property and accepts all IDL plotting keywords.
 ;-
 
     on_error, 1
     if n_elements(x) eq 0 then message, 'Missing data!'
 
     sdum = size(x)
     if n_elements(y) eq 0 then begin
 	py = x
 	case sdum(0) of
 	    1	:    len = sdum(1)
 	    2	:    len = max(sdum(1:2))
 	    else:    message, 'Bad data!'
 	endcase
 	px = indgen(len)
     endif else begin
 	len = sdum(1)
 	px = x
 	py = y
     endelse
 
     sdum = size(py)
     case sdum(0) of
 	1    :    plnum = 1
 	2    :    if sdum(2) eq len then begin
 			plnum = sdum(1)
 			py = transpose(py)
 		  endif else plnum = sdum(2)
 	else :    message, 'Bad data!'
     endcase
 
     xtyp = Default(xtyp,!x.type)
     ytyp = Default(ytyp,!y.type)
     ynz = Default(ynz,0)
     xmin = min(px, max = xmax)
     ymin = min(py, max = ymax)
     if ynz eq 0 then ymin = ytyp < ymin
     nth = Wherinstruct('thi',_e,thcon)
     if thcon eq 1 then thi = _e.(nth(0)) else thi = !p.thick
     psm = Default(psm,0)
     if n_elements(psm) eq 1 then psm = (psm + Sign(psm)*indgen(plnum)) mod 7
     linst = Default(linst,0)
     if n_elements(linst) eq 1 then linst = (linst + indgen(plnum)) mod 6
     col = Default(col,!p.color)
     if n_elements(col) eq 1 then col = (col + intarr(plnum))
 
     plot, px, py(*,0), xrange = [xmin,xmax], yrange = [ymin,ymax], $
 	xtype = xtyp, ytype = ytyp, ynozero = ynz, psym = psm(0), $
 	linestyle = linst(0), color = col(0), _extra = _e
     for i = 1, plnum - 1 do begin
 	oplot, px, py(*,i), thick = thi, psym = psm(i), $
 	linestyle = linst(i), color = col(i)
     endfor
 
     return
 end
 
                               *** PLOT_VER2 ***                       

 Pro Plot_ver2, x, y0, y1, $
     xmargin = xmar, ymargin = ymar, ratio = rat, gap = gp, $
     xtype = xtyp, ytype = ytyp, ynozero = ynz, xtitle = xtit, ytitle = ytit, $
     title = tit, psym = psm, linestyle = linst, color = col, _extra = _e
 
 ;+
 ; NAME:
 ;	PLOT_VER2
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Draws 2 plots, vertically spaced, with a possibility of multiple curves
 ;	on each plot.
 ; CATEGORY:
 ;	Plotting.
 ; CALLING SEQUENCE:
 ;	PLOT_VER2, [X,] Y0, Y1 [, optional keywords]
 ; INPUTS:
 ;    Y0
 ;	A numeric vector or 2 dimensional array containing the Y coordinates of
 ;	the data for the top plot.  If Y is a 2-dim.array, each row is ploted
 ;	separately.  It is assumed that the number of points per plot is larger
 ;	 than the number of plots so that if Y is an (M*N) array with N > M, it
 ;	 will be transposed prior to plotting.
 ;    Y1
 ;	Same as Y0 for the bottom plot.
 ; OPTIONAL INPUT PARAMETERS:
 ;    X
 ;	A numeric vector containing the X coordinates of the data.  If absent
 ;	it is replaced by the vector [0, 1, 2 ...].
 ; KEYWORD PARAMETERS:
 ;    RATIO
 ;	Size ratio between top and bottom plot.  Default is 1.
 ;    GAP
 ;	Width of the gap between the plots in character units.  Default is 0.1
 ;    XMARGIN
 ;	Standard IDL plotting interpretation.
 ;    YMARGIN
 ;	Ditto.
 ;    XTYPE
 ;	Ditto.
 ;    YTYPE
 ;	Ditto.  If given as 2-element vector, elements 0 and 1 apply to top and
 ;	bottom plots, respectively.
 ;    YNOZERO
 ;	Ditto.  If given as 2-element vector, elements 0 and 1 apply to top and
 ;	bottom plots, respectively.
 ;    TITLE
 ;	Ditto.
 ;    XTITLE
 ;	Ditto.
 ;    YTITLE
 ;	Ditto.  If given as 2-element vector, elements 0 and 1 apply to top and
 ;	bottom plots, respectively.
 ;    PSYM
 ;	Ditto.  If given as a vector consecutive elements are applied to
 ;	consecutive curves on each plot.
 ;    LINESTYLE
 ;	Ditto.  If given as a vector consecutive elements are applied to
 ;	consecutive curves on each plot.
 ;    COLOR
 ;	Ditto.  If given as a vector consecutive elements are applied to
 ;	consecutive curves on each plot.
 ;    _EXTRA
 ;       A formal keyword used to pass all plotting keywords.  Not to be used
 ;       directly.
 ; OUTPUTS:
 ;	None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Uses calls to DEFAULT, PLOTOT and PLVAR_KEEP, from
 ;	MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 30-JUL-1991 by Mati Meron.
 ;       Modified 15-JAN-1994 by Mati Meron.  Now PLOT_VER2 takes advantage of
 ;	the keyword inheritance property and accepts all IDL plotting keywords.
 ;-
 
     on_error, 1
     if n_elements(y1) eq 0 then begin
 	py1 = y0
 	py0 = x
 	sdum = size(x)
 	case sdum(0) of
 	    1	:    len = sdum(1)
 	    2	:    len = max(sdum(1:2))
 	    else:    message, 'Bad data!'
 	endcase
 	px = indgen(len)
     endif else begin
 	py1 = y1
 	py0 = y0
 	px = x
     endelse
 
     xtyp = Default(xtyp,!x.type)
     ytyp = Default(ytyp,!y.type)
     if n_elements(ytyp) eq 1 then ytyp = [ytyp,ytyp]
     xex = Default(xex,0)
     ynz = Default(ynz,0)
     if n_elements(ynz) eq 1 then ynz = [ynz,ynz]
     tit = Default(tit,!p.title)
     xtit = Default(xtit,!x.title)
     ytit = Default(ytit,!y.title)
     if n_elements(ytit) eq 1 then ytit = [ytit,ytit]
     psm = Default(psm,0)
     linst = Default(linst,0)
     col = Default(col,!p.color)
 
     scaf = float(!d.y_ch_size)/!d.y_size
     ymar = Default(ymar,!y.margin)
     rat = float(Default(rat,1))
     gp = Default(gp,0.1)*scaf
     bm = ymar(0)*scaf
     tm = ymar(1)*scaf
     pp = (1 - tm - bm - gp)/(1 + rat)
     botop = bm + pp
     tobot = botop + gp
 
     Plvar_keep, action = 'save'
     !p.multi = [0,1,2]
     !x.margin = Default(xmar,!x.margin)
     !x.thick = 2
     !y.thick = 2
 
     tlen = !p.ticklen
     !p.region = [0,tobot,1,1]
     !y.margin = [0,ymar(1)]
     !x.tickname = ' '
     Plotot, px, py0, xtype = xtyp, ytype = ytyp(0), ynozero = ynz(0), $
     title = tit, ytitle = ytit(0), psym = psm, linestyle = linst, color = col,$
     _extra = _e
     !p.ticklen = tlen*(1 - 6*scaf)/(1 - tobot - tm)
     axis, xaxis = 1
 
     !p.ticklen = tlen
     !p.region = [0,0,1,botop]
     !y.margin = [ymar(0),0]
     !x.tickname = ''
     Plotot, px, py1, xtype = xtyp, ytype = ytyp(1), ynozero = ynz(1), $
     xtitle = xtit, ytitle = ytit(1), psym = psm,linestyle = linst,color = col,$
     _extra = _e
     !p.ticklen = tlen*(1 - 6*scaf)/(botop - bm)
     !x.tickname = ' '
     axis, xaxis = 0
 
     Plvar_keep, action = 'restore'
 
     return
 end
 
                               *** PLVAR_KEEP ***                      

 Pro Plvar_Keep, action = what, reset = rs
 
 ;+
 ; NAME:
 ;	PLVAR_KEEP
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Saves or restores the values of system variables.
 ; CATEGORY:
 ;	Input/output.
 ; CALLING SEQUENCE:
 ;	PLVAR_KEEP, ACTION = ACT [, /RESET]
 ; INPUTS:
 ;	None.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    ACTION
 ;	Specifies the action to take.  Two possible values, 'SAVE' and
 ;	'RESTORE' (only first three characters count).
 ;    /RESET
 ;	Switch.  Protection bypass.  Normally multiple calls to PLVAR_KEEP are
 ;	counted but no action is taken after the first.  For example, if 3
 ;	consecutive calls with ACTION = 'SAVE' were issued then the system
 ;	variables are saved on the first call and nothing happens on the next
 ;	two.  Then, when calls with ACTION = 'RESTORE' are issued, only the
 ;	third call will have an effect.  This mechanism allows using 'SAVE' and
 ;	'RESTORE' calls as pairs of braces around program sections.  For the
 ;	(rare) cases when one wants to save or restore regardless of previously
 ;	issued calls, setting RESET disables the protection mechanism.
 ; OUTPUTS:
 ;	None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	M_PLVARS
 ; SIDE EFFECTS:
 ;	None when used properly.  If the numbers of SAVEs and RESTOREs are not
 ;	equal, either due to an omission or to an error in a called routine,
 ;	the settings won't be restored to their initial state.  In this case
 ;	the cure is to execute
 ;		PLVAR_KEEP, ACTION = 'RESTORE', /RESET
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses a common block (M_PLVARS) to save and restore the values of:
 ;	!P, !X, !Y, !Z, !D.NAME.  Also uses the routines DEFAULT, STRMATCH_MM
 ;	and TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created by 15-JUL-1991 by Mati Meron.
 ;-
 
     common m_plvars, devnam, pbak, xbak, ybak, zbak, savflag
 
     on_error, 1
     if Type(what) ne 7 then message, 'No action specified!'
     posib = ['SAVE', 'RESTORE']
     nwhat = StrMatch_mm(what,posib,3)
     if nwhat eq -1 then message, 'Unknown Action!'
     savflag = Default(savflag,0)
     if keyword_set(rs) then savflag = nwhat
 
     case nwhat of
 	0 : begin
 		if savflag eq 0 then begin
 		    devnam = !d.name
 		    pbak = !p
 		    xbak = !x
 		    ybak = !y
 		    zbak = !z
 		endif
 		savflag = savflag + 1
 	    end
 	1 : begin
 		savflag = savflag - 1
 		if savflag eq 0 then begin
 		    set_plot, devnam
 		    !p = pbak
 		    !x = xbak
 		    !y = ybak
 		    !z = zbak
 		endif
 	    end
     endcase
 
     savflag = savflag > 0
     return
 end
 
                                *** POLEVAL ***                         

 Function Poleval, x, coef, quotient = qcoef
 
 ;+
 ; NAME:
 ;	POLEVAL
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Evaluates a polynomial function according to the formula:
 ;	    F = c(0) + c(1)*X + ... + c(n)*X^N
 ;	Similar to the library routine POLY.  The difference is that when the
 ;	keyword QUOTIENT is used, the routine returns, in QCOEF, the values of
 ;	the coefficients of the quotient polynomial.  In other words, given the
 ;	coefficients of a polynomial P, and a value Xc, the function returns
 ;	the value P(Xc), and in QCOEF are returned the coefficients of the
 ;	polynomial Q(X) = P(X)/(X - Xc).  Note that unless P(Xc) is 0, the
 ;	division has a remainder.
 ; CATEGORY:
 ;	Mathemetical function (general).
 ; CALLING SEQUENCE:
 ;	Result = POLEVAL( X, COEF [, QUOTIENT = QCOEF])
 ; INPUTS:
 ;    X
 ;	Numeric, otherwise arbitrary.
 ;    COEF
 ;	Numeric vector.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    QUOTIENT
 ;	An optional output parameter.  See below.
 ; OUTPUTS:
 ;	Returns the value of the polynomial at X.  The result has the same
 ;	structure and number of elements as X and the same type as the higher
 ;	of X and COEF.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    QUOTIENT
 ;	The name of the variable to receive the quotient polynomial.  The
 ;	quotient is an array with one more dimension than X.  For example, if
 ;	X is given as an array with dimensions (10,8,64) and the order of the
 ;	polynomial is 4 then the dimensions of the quotient will be (10,8,64,4).
 ;	QCOEF(4,5,6,*) will then contain the coefs. of P(X)/(X - X(4,5,6)), etc.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Standard Horner evaluation.  Uses the functions DEFAULT and FPU_FIX
 ;	from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-NOV-1991 by Mati Meron.
 ;	Modified 10-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     coef = Default(coef,0)
     np = n_elements(coef) - 1
     lq = np > 1
     xsiz = size(x)
     nd = xsiz(0)
     nx = xsiz(nd+2)
 
     if nd eq 0 then begin
 	qsiz = [1,lq,xsiz(1),nx*lq]
 	res = coef(np)
     endif else begin
 	qsiz = [nd + 1, xsiz(1:nd), lq, xsiz(nd+1), nx*lq]
 	res = coef(np)*make_array(size = xsiz, value = 1)
     endelse
     qcoef = make_array(size = qsiz)
 
     for i = np - 1, 0, -1 do begin
 	qcoef(nx*i:nx*(i+1)-1) = res
 	res = res*x + coef(i)
     endfor
 
     return, FPU_fix(res)
 end
 
                                *** PRINUMS ***                         

 Function Prinums, nlo, nhi, bypass = byp
 
 ;+
 ; NAME:
 ;	PRINUMS
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates a table of prime numbers in the range NLO - NHI.
 ; CATEGORY:
 ;	Mathematical function (general).
 ; CALLING SEQUENCE:
 ;	List = PRINUMS( [NLO,] NHI)
 ; INPUTS:
 ;    NHI
 ;	Upper limit of the range of the primes table.  Converted to long
 ;	integer on input.
 ; OPTIONAL INPUT PARAMETERS:
 ;    NLO
 ;	Lower limit of the prime table range.  Converted to long integer on
 ;	input.If not provided, i.e. if only one input parameter is provided,
 ;	NLO defaults to 1.
 ; KEYWORD PARAMETERS:
 ;    /BYPASS
 ;	Switch.  Used only on internal calls.
 ; OUTPUTS:
 ;	Returns the list of primes between NLO and NHI (inclusive), as long
 ;	integer.  If no primes are found, returns 0.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	Inputs must be positive.  If both NLO and NHI are given, NHI >= NLO.
 ; PROCEDURE:
 ;	Uses the Sieve of Erasthotenes algorithm.  Generates the primes table
 ;	calling itself recursively.
 ; MODIFICATION HISTORY:
 ;	Created 15-NOV-1991 by Mati Meron.
 ;	Modified 15-DEC-1993 by Mati Meron.  Combined previous PRIMES and
 ;	PR_SIEVE in a single routine.
 ;	Modified 20-JUN-1995 by Mati Meron.  Renamed PRINUMS to avoid conflict
 ;	with an IDL routine bearing the same name.
 ;-
 
     on_error, 1
 
     khi = long(nlo)
     if not keyword_set(byp) then begin
 	if n_params() eq 2 then begin
 	    khi = long(nhi)
 	    klo = ceil(nlo)
 	endif else klo = 1l
 	if klo lt 1 then message, 'Lower limit must be positive'
 	if khi lt klo then message, 'Upper limit must be >= than lower limit!'
 	pmax = 2 > long(sqrt(khi))
 	if pmax ge klo then pmax = khi
     endif else pmax = khi
 
     case pmax of
 	1   :	ptab = [0l]
 	2   :	ptab = [2l]
 	3   :	ptab = [2l,3l]
 	else:	begin
 		    ptab = Prinums(sqrt(pmax), /bypass)
 		    tem = lindgen(pmax + 1)
 		    for i = 0l, n_elements(ptab) - 1 do $
 			tem(ptab(i)*(1l + lindgen(pmax/ptab(i)))) = 0
 		    dum = where(tem gt 1, pcount)
 		    if pcount gt 0 then ptab = [ptab, tem(dum)]
 		end
     endcase
 
     if pmax lt khi then begin
 	tem = klo + lindgen(khi - klo + 1)
 	for i = 0l, n_elements(ptab) - 1 do begin
 	    p = ptab(i)
 	    pnum = khi/p - (klo - 1)/p
 	    poff = (klo + p - 1)/p*p - klo
 	    if pnum gt 0 then tem(p*lindgen(pnum) + poff) = 0
 	endfor
 	ptab = ([0l,tem])(where(tem ge klo > 2, pcount) + 1)
     endif
 
     return, ptab
 end
 
                                *** RANDISC ***                         

 Function Randisc, seed, d_0, d_1, d_2, d_3, d_4, d_5, d_6, d_7, $
     amplitude = amp, uniform = uni, binomial = bin, normalize = nor
 
 ;+
 ; NAME:
 ;	RANDISC
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Generates a set of discretely distributed random numbers.
 ; CATEGORY:
 ;	Mathematical function.
 ; CALLING SEQUENCE:
 ;	Result = RANDISC (SEED,  [,parameters] [,keywords])
 ; INPUTS:
 ;    SEED
 ;	A named variable containing the seed value for random number generation.
 ;	Does not need to be defined prior to call.  For details see IDL
 ;	routines RANDOMN and RANDOMU.
 ; OPTIONAL INPUT PARAMETERS:
 ;    D_0 through D_7
 ;	Dimensions of the result.  All default to 1.  Trailing dimensions of 1
 ;	are removed.
 ; KEYWORD PARAMETERS:
 ;    AMPLITUDE
 ;	Numerical value, rounded to long integer on input.  Specifies the
 ;	output range.  Output values are randomly spread among AMP + 1 possible
 ;	values ranging from -AMP to AMP (unless the keyword NORMALIZE is used),
 ;	with a spacing of 2.  Default value of AMP is 1.
 ;    /UNIFORM
 ;	Switch.  Specifies uniform distribution.  This is the default.
 ;    /BINOMIAL
 ;	Switch.  Specifies binomial distribution.  For large values of AMP the
 ;	result approaches a Gaussian with sigma = sqrt(AMP)
 ;    /NORMALIZE
 ;	Switch.  If set, the result is normalized to lie in the [-1,1] range,
 ;	with a spacing of -2/AMP
 ; OUTPUTS:
 ;	Returns number randomly distributed among the values
 ;	-AMP, -AMP + 2 ... AMP or, if the keyword NORMALIZE is set, among
 ;	-1, -1 + 2/AMP ... 1.  The distribution may be uniform (the default) or
 ;	binomial (quasi gaussian).  The result can have any number (up to 8) of
 ;	dimensions which are specified by the optional variables D_0, ... D_7.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	On return, SEED is replaced with the new value of the randomizer seed.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses the system routine RANDOMU.  Also uses DEFAULT and ONE_OF from
 ;	MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 20-APR-1995 by Mati Meron.
 ;-
 
     on_error, 1
     dnums = ['d_0', 'd_1', 'd_2', 'd_3', 'd_4', 'd_5', 'd_6', 'd_7']
     d = replicate(1l,8)
     for i = 0, n_params() - 2 do idum = execute('d(i) = ' + dnums(i))
     amp = Default(amp,1,/dtype) > 1
     wamp = 1 + amp + (1 - amp)*(One_of(uni,bin) > 0)
 
     dist = floor(wamp*randomu(seed,d(0),d(1),d(2),d(3),d(4),d(5),d(6),d(7)))
     for i = 0l, amp - wamp do dist = $
 	dist + floor(wamp*randomu(seed,d(0),d(1),d(2),d(3),d(4),d(5),d(6),d(7)))
 
     if keyword_set(nor) then return, 2.*dist/amp - 1 else return, 2.*dist - amp
 end
 
                                 *** RASCII ***                          

 Function Rascii, filnam, buffer = buf, double = doub, $
     npoints = ncr, header = head, show = sho, skip = skip, error_status = err
 
 ;+
 ; NAME:
 ;	RASCII
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Reads data from an ASCII file into an array.  It is assumed that the
 ;	file contains columns of numbers, with the same number of entries in
 ;	each row.  The numbers may be separated by commas, spaces and/or tabs.
 ;	The file may contain a header.  The first line in which the first
 ;	non-blank character is one of ".+-0123456789" will be considered the
 ;	beginning of the data.  Text lines imbedded in the data are skipped.
 ; CATEGORY:
 ;	Input/Output.
 ; CALLING SEQUENCE:
 ;	Result = RASCII( FILNAM [, optional keywords])
 ; INPUTS:
 ;    FILNAM
 ;	Char. value, the name of the data file.  Default extension is '.DAT'.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    BUFFER
 ;	Initial number of data rows.  Default is 256.  In any case the result
 ;	Is trimmed to the actual number.
 ;    /DOUBLE
 ;	If set, the data is input as DOUBLE.  Default is FLOAT.
 ;    /SHOW
 ;	If set, the header (if one exists) will be printed to the screen.
 ;    NPOINTS
 ;	Optional output, see below.
 ;    HEADER
 ;	Optional output, see below.
 ;    SKIP
 ;	Number of lines to skip at the beginning of the file.  This keyword can
 ;	be used if the header of the file contains lines beginning with
 ;	".+-0123456789" which would otherwise be read as data.  Default is 0.
 ; OUTPUTS:
 ;	Returns the data in a (NC,NR) floating (or double precision if DOUBLE
 ;	is set) array, where NC, NR, are the numbers of columns and rows,
 ;	respectively.  In case of error returns 0.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    NPOINTS
 ;	The name of a 2-dim vector to receive the values of NC, NR (see above).
 ;	Doesn't need to be defined prior to the call.  In case of an error
 ;	returns [0,0].
 ;    HEADER
 ;	The name of a character array to receive the header lines.  Doesn't
 ;	need to be defined prior to the call.  In case of an error, or if no
 ;	header exists, returns a zero length string.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Uses DEFAULT, STREQ and STRPARSE_MM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 25-JAN-1992 by Mati Meron.
 ;	Modified 25-MAY-1994 by Mati Meron.  Added buffering and DOUBLE option.
 ;	Modified 14-FEB-1995 by Mark Rivers.  Added keyword SKIP.
 ;	Modified 24-JUL-1995 by Mati Meron.  Removed a UNIX/VMS conflict in the
 ;	file OPENR statement.
 ;	Modified 10-JUL-1997 by Mati Meron.  Name changed from READ_ASCII to
 ;	RASCII to avoid conflict with the READ_ASCII routine in IDL ver. 5.
 ;	Modified 12-SEP-1997 by Mati Meron.  Added keyword ERROR_STATUS,
 ;	following a modification by Roger Dejus, XFD/APS.
 ;-
 
     err = 0l
     ncr = [0l,0l]
     bufsiz = (round(Default(buf,256)/256.) > 1l)*256l
     nrtem = bufsiz
     dtyp = 4 + keyword_set(doub)
     on_ioerror, file_no_good
     if Streq(!version.os,'vms',3) then begin
 	openr, datun, filnam, default = '.dat', /get_lun
     endif else openr, datun, filnam, /get_lun
 
     line = ''
     head = ''
     nc = 0l
     on_ioerror, data_no_good
     if n_elements(skip) ne 0 then for i = 0l, skip-1 do $
 	readf, datun, line, prompt = ''
     while nc eq 0 and not eof(datun) do begin
 	finf = fstat(datun)
 	readf, datun, line, prompt = ''
 	if line ne '' then begin
 	    bline = byte(strtrim(line,1))
 	    if Strparse_mm(' .+-0123456789 ',string(bline(0))) eq 0 then begin
 		head = [temporary(head),line]
 		if keyword_set(sho) then print, line
 	    endif else nc = 1l + Strparse_mm(line, '	, ')
 	endif
     endwhile
     head = transpose(head(n_elements(head) gt 1:*))
 
     if nc gt 0 then begin
 	point_lun, datun, finf.cur_ptr
 	datline = make_array(nc, type = dtyp)
 	data = make_array(nc,bufsiz, type = dtyp)
 	on_ioerror, next
 	nr = 0l
 	next:
 	while not eof(datun) do begin
 	    readf, datun, datline, prompt = ''
 	    data(*,nr) = datline
 	    nr = nr + 1l
 	    if nr eq nrtem then begin
 		data = [[data],[make_array(nc,bufsiz, type = dtyp)]]
 		nrtem = nrtem + bufsiz
 	    endif
 	endwhile
 	data = data(*,0:nr-1)
 	ncr = [nc,nr]
     endif else data = 0
 
     free_lun, datun
     return, data
 
     data_no_good:
     free_lun, datun
     file_no_good:
     print, !err_string
     err = !error
     return, 0
 
 end
 
                                *** REAL_MM ***                         

 Function Real_mm, x
 
 ;+
 ; NAME:
 ;	REAL_MM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Returns real values.
 ; CATEGORY:
 ;	Mathematical, general.
 ; CALLING SEQUENCE:
 ;	Result = REAL_MM (X)
 ; INPUTS:
 ;    X
 ;	Numerical, otherwise arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the real value of the input, i.e. the input itself if its real
 ;	the real part in FLOAT format for COMPLEX and the real part in DOUBLE
 ;	format for DCOMPLEX.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Calling CAST, FPU_FIX and ISNUM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 5-MAY-1996 by Mati Meron as M_REAL.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;	Renamed 25-SEP-1999 by Mati Meron, to REAL_MM.
 ;-
 
     on_error, 1
     if not Isnum(x) then message, 'Not numeric!"
 
     if Isnum(x, /complex, typ= xtyp) then return, FPU_fix(Cast(x,4,xtyp/2+ 1)) $
     else return, FPU_fix(x)
 end
 
                                 *** RECTAN ***                          

 Pro Rectan, xlims = xls, ylims = yls, radius = rad, relative = rel, $
     xwiggle = xwg, ywiggle = ywg, rotate = rot, rotation_center = rocent, $
     degrees = deg, fill = fil, device = dev, normal = nor, $
     no_show = nsh, shapeout = rect, _extra = _e
 
 ;+
 ; NAME:
 ;	RECTAN
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Draws a rectangle between the limits specified by XLIMS and YLIMS,
 ;	possibly rotated and/or rounded  The drawing is done in the currently
 ;	defined plot area.  Alternatively, a *SHAPE* representation (see
 ;	SHAPE_VER for definition) of the rectangle may be returned through the
 ;	SHAPEOUT keyword.  DATA coordinate system is assumed unless specified
 ;	otherwise by one of the keywords /DEVICE or /NORMAL.
 ; CATEGORY:
 ;	General Graphics.
 ; CALLING SEQUENCE:
 ;	RECTAN, XLIMS = XLS, YLIMS = YLS [, optional keywords]
 ; INPUTS:
 ;	None.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    XLIMS
 ;	2 dimensional vector, format [xmin,xmax], mandatory.
 ;    YLIMS
 ;	2 dimensional vector, format [xmin,xmax], mandatory.
 ;    RADIUS
 ;	Value of radius for rounded corners.
 ;    /RELATIVE
 ;	Switch.  Specifies that the radius value is relative to the shorter
 ;	side of the rectangle.
 ;    XWIGGLE
 ;	Optional.  Allows to change the two sides parallel to the X-axis
 ;	(before rotation, if any) into sinusoidal lines.  Can be given as
 ;	scalar, 2D or 3D vector.  The first parameter is number of periods,
 ;	the second is amplitude and the third phase (see the routine WIGGLINE
 ;	for explanation).  Number of periods is always rounded to nearest
 ;	integer or half integer and the phase is rounded to 0 or half period.
 ;	Default for amplitude is 1, for phase is 0.
 ;
 ;	Note:  If RADIUS (see above) is given, XWIGGLE is ignored.
 ;    YWIGGLE
 ;	Same as XWIGGLE, for the Y sides.
 ;    ROTATE
 ;	Optional.  Angle of rotation in the mathematical positive direction.
 ;	Assumed in radians, unless DEGREES is set.  Rotation center is the
 ;	center of the rectangle unless specified otherwise by the keyword
 ;	ROTATION_CENTER (see below).
 ;    ROTATION_CENTER
 ;	Optional.  Accepts a two element vector specifying the center of
 ;	rotation.  Ignored if ROTATE is not given.  Defaults to center of shape.
 ;    /DEGREES
 ;	Switch.  Specifies that the rotation angle is given in degrees.
 ;    /FILL
 ;	Switch.  Causes the rectangle to be filled with a solid pattern.
 ;    /DEVICE
 ;	Standard IDL plotting interpretation.
 ;    /NORMAL
 ;	Ditto.
 ;    /NO_SHOW
 ;	Switch.  If set, no plotting is done, but the shape is generated and
 ;	may be returned through SHAPEOUT.
 ;    SHAPEOUT
 ;	Optional output, see below.
 ;    _EXTRA
 ;	A formal keyword used to pass all plotting keywords.  Not to be used
 ;	directly.
 ; OUTPUTS:
 ;	None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    SHAPEOUT
 ;	When provided with the name of a variable, on return the variable
 ;	contains the *SHAPE* representation of the rectangle.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	RECTAN calls either PLOTS or (when /FILL is used) POLYFILL.  Since
 ;	some graphics keywords work only with PLOTS, or only with POLYFILL,
 ;	some care must be exercised.
 ; PROCEDURE:
 ;	Uses calls to DEFAULT, HOW_MANY, ONE_OF, SHAPE_CLOSE, SHAPE_COCON,
 ;	SHAPE_TRANS and WIGGLINE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Modified 15-OCT-1991 by Mati Meron.  Added keyword COLOR.
 ;	Modified 15-OCT-1992 by Mati Meron.  Added rotation capability.
 ;	Modified 30-OCT-1992 by Mati Meron.  Added corner rounding capability.
 ;	Modified 15-DEC-1993 by Mati Meron.  Now RECTAN takes advantage of the
 ;	keyword inheritance property and accepts all IDL graphics keywords.
 ;	Modified 25-JUL-1999 by Mati Meron.  Added keywords NO_SHOW and
 ;	SHAPEOUT.
 ;	Modified 20-SEP-1999 by Mati Meron.  Added possibility of wiggly
 ;	borders through the keywords XWIGGLE and YWIGGLE.
 ;-
 
     on_error, 1
     posib = ['DATA', 'DEVICE', 'NORMAL']
     sor = posib(1 + One_of(dev,nor))
 
     rls = transpose([[min(xls, max = sec), sec],[min(yls, max = sec), sec]])
     corn = rls([[2,3],[0,3],[0,1],[2,1]])
     dxy = rls[*,1] - rls[*,0]
     rad = Default(rad,0.,/dtype)
 
     if rad gt 0 then begin
 	radx = 0.5*min(dxy)
 	if keyword_set(rel) then rad = radx*rad
 	rad = rad < radx
 	cent = corn - rad*[[1,1],[-1,1],[-1,-1],[1,-1]]
 	rect = [0,0]
 	for i = 0, 3 do begin
 	    rsor = [[corn[*,i]],[cent[*,i]]]
 	    rdev = Shape_cocon(rsor, from = sor, to = 'dev')
 	    npoints = 1 + fix(!pi/4*sqrt(max(abs(rdev[*,1] - rdev[*,0]))))
 	    tem = !pi/(2*npoints)*(indgen(npoints + 1) + i*npoints)
 	    arc = transpose([[cent[0,i]+rad*cos(tem)],[cent[1,i]+rad*sin(tem)]])
 	    rect = [[rect],[arc]]
 	endfor
 	rect = Shape_close(rect[*,1:*])
     endif else begin
 	rect = Shape_close(corn)
 	nwig = How_many(fir=xwg,sec=ywg,which=whig)
 	if nwig gt 0 then begin
 	    ar = rect[*,0:1]
 	    br = rect[*,1:2]
 	    cr = rect[*,2:3]
 	    dr = rect[*,3:4]
 	    if (whig and 1) ne 0 then begin
 		wpar = [xwg,1,1]
 		Wiggline, from = ar[*,0], to = ar[*,1], /exact, /no_show, $
 		shap= ar, per = wpar[0], amp = wpar[1], pha = wpar[2]
 		cr = reverse(ar,2)
 		cr[1,*] = cr[1,*] - dxy(1)
 	    endif
 	    if (whig and 2) ne 0 then begin
 		wpar = [ywg,1,1]
 		Wiggline, from = br[*,0], to = br[*,1], /exact, /no_show, $
 		shap= br, per = wpar[0],amp = wpar[1], pha = wpar[2]
 		dr = reverse(br,2)
 		dr[0,*] = dr[0,*] + dxy(0)
 	    endif
 	    rect = [[ar],[br[*,1:*]],[cr[*,1:*]],[dr[*,1:*]]]
 	endif
     endelse
 
     if n_elements(rot) ne 0 then begin
 	rocent = Default(rocent,0.25*total(corn,2),low=4)
 	rect = Shape_trans(rect,0,1,-rocent)
 	rect = Shape_trans(rect,rot,1,rocent,degrees= deg)
     endif
 
     if not keyword_set(nsh) then if keyword_set(fil) then $
     polyfill, rect, device=dev, normal=nor, _extra = _e $
     else plots, rect, device = dev, normal = nor, _extra = _e
 
     return
 end
 
                                *** ROMBERG ***                         

 Function Romberg, fun, range, eps, relative = rel, params = pars, $
     try = ntry, error = erv, status = stat
 
 ;+
 ; NAME:
 ;    ROMBERG
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Performs high precision numerical integration.
 ; CATEGORY:
 ;	Mathematical function (general).
 ; CALLING SEQUENCE:
 ;	Result = ROMBERG( FUN, RANGE [, EPS [, keywords]])
 ; INPUTS:
 ;    FUN
 ;	Character value representing an existing IDL function.  The function
 ;	must comply with the IDL standard of being able to accept an array
 ;	input and return an array output.  The calling sequence for the
 ;	function must be either
 ;	    Result = FUN(x)
 ;	or
 ;	    Result = FUN(x, extra)
 ;	where X is the variable and EXTRA may be any single entity (scalar,
 ;	array, structure etc.) used to pass additional parameters to the
 ;	function.
 ;    RANGE
 ;	Two element vector, integration range.
 ; OPTIONAL INPUT PARAMETERS:
 ;    EPS
 ;	Allowed integration error.  Default is around 1e-7 for single-precision
 ;	integration and 2e-16 for double-precision.  EPS is understood to
 ;	represent absolute error unless the keyword RELATIVE is set.
 ; KEYWORD PARAMETERS:
 ;    /RELATIVE
 ;	If set, EPS represent the allowed relative integration error.
 ;    PARAMS
 ;	An arbitrary value or variable which is passed to the function FUN.
 ;    TRY
 ;	Normally ROMBERG exits, with STATUS = 2, if the calculation error
 ;	starts to grow before the convergence criterion is satisfied.  Setting
 ;	TRY to an integer > 0 specifies the number of additional attempts at
 ;	convergence before exit (useful with ill-conditioned functions).  The
 ;	default value is 0.
 ;    ERROR
 ;	Optional output, see below.
 ;    STATUS
 ;	Optional output, see below.
 ; OUTPUTS:
 ;	Returns the value of the integral.  The result is always a scalar. The
 ;	numerical type of the result (floating, double-precision or complex) is
 ;	determined by the type of values returned by FUN.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    ERROR
 ;	The name of the variable to receive the estimated integration error.
 ;	If RELATIVE is set the error returned is relative.
 ;    STATUS
 ;	The name of the variable to receive integration status information.
 ;	Possible values are:
 ;	    0 - Integration didn't converge.
 ;	    1 - OK.
 ;	    2 - Integration converged, but with precision worse then specified.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Enhanced Romberg integration, using the extended midpoint rule and
 ;	Neville's interpolation algorithm.  The process is iterated untill
 ;	either the desired accuracy is achieved, the maximal allowed number of
 ;	steps is exceeded or further iterations cause the error to grow instead
 ;	of diminishing (the last can be postponed using the TRY keyword).  The
 ;	procedure can handle functions with an integrable singularity at one
 ;	(or both) end of the integration interval.
 ;	Uses CAST, DEFAULT, FPU_FIX, ISNUM and TOLER from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-FEB-92 by Mati Meron.
 ;	Modified 20-JAN-1994 by Mati Meron.  Added keyword TRY.
 ;	Modified 5-OCT-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     stat = 0
 
     rex = Cast(range(1) - range(0),4)
     xc = range(0) + 0.5*rex
     relf = keyword_set(rel)
     ntr = Default(ntry,0,/dtype) > 0
     pflag = n_elements(pars) ne 0
     if pflag then fc = FPU_fix(rex/3*call_function(fun,xc,pars)) $
     else fc = FPU_fix(rex/3*call_function(fun,xc))
     isdob = Isnum(fc,/double,typ = ftyp)
     ftyp = ftyp > 4
     etyp = 4 + isdob
     sinf = machar(double = isdob)
     eps = abs(Default(eps,Toler(type = ftyp),/dtype))
     kmax = floor(-alog(Toler()*(0.5 + abs(xc/rex)))/alog(3)) > 0
 
     p = make_array(kmax + 1,type = ftyp)
     q = p
     res = p
     err = make_array(kmax + 1,type = etyp, value = sinf.xmax)
     k = 0
     kl = 1
 
     while (k lt kmax and err(k) ge eps) do begin
 	k = k + 1
 	rex = rex/3
 	xl = xc - rex
 	xr = xc + rex
 	if pflag then begin
 	    fl = total(FPU_fix(rex*call_function(fun,xl,pars)))
 	    fr = total(FPU_fix(rex*call_function(fun,xr,pars)))
 	endif else begin
 	    fl = total(FPU_fix(rex*call_function(fun,xl)))
 	    fr = total(FPU_fix(rex*call_function(fun,xr)))
 	endelse
 	xc = reform(transpose([[xl],[xc],[xr]]),3l^k)
 	p(k) = 2*fc - fl - fr
 	q(k) = fc + fl + fr
 	fc = q(k)/3
 
 	if p(k) eq 0 then begin
 	    res(k) = q(k)
 	    err(k) = 0
 	endif else begin
 	    l = k
 	    while l gt kl do begin
 		l = l - 1
 		if p(l) eq p(k) then q(l) = q(l+1) else $
 		q(l) = (p(l)*q(l+1) - p(k)*q(l))/(p(l) - p(k))
 		nerr = abs(q(l+1) - q(l))
 		if nerr gt err(k) then kl = l + 1 else err(k) = nerr
 	    endwhile
 	    res(k) = q(kl)
 	    if relf and err(k) lt abs(res(k)) then err(k) = err(k)/abs(res(k))
 	    if k gt kl + 1 then begin
 		if err(k-1) lt err(k) < err(k-2) and ntr eq 0 then begin
 		    k = k - 1
 		    kmax = k
 		    stat = 2
 		endif else ntr = ntr - 1
 	    endif
 	endelse
     endwhile
 
     erv = FPU_fix(err(k))
     if erv lt eps then stat = 1
     return, FPU_fix(res(k))
 end
 
                                  *** ROOT ***                            

 Function Root, fun, range, eps, relative = rel, params = pars, multi = mult, $
     error = ervl, status = stat, done = don
 
 ;+
 ; NAME:
 ;    ROOT
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Finds roots of real functions.
 ; CATEGORY:
 ;	Mathematical function (general).
 ; CALLING SEQUENCE:
 ;	Result = ROOT( FUN, RANGE [, EPS [, keywords]])
 ; INPUTS:
 ;    FUN
 ;	Character value representing an existing IDL function.  The function
 ;	must return scalar values.  It is not necessery for FUN to be able to
 ;	accept an array input and return an array output.  The calling sequence
 ;	for the function must be either
 ;	    Result = FUN(x)
 ;	or
 ;	    Result = FUN(x, extra)
 ;	where X is the variable and EXTRA may be any single entity (scalar,
 ;	array, or structure) used to pass additional parameters to the function.
 ;    RANGE
 ;	Two element vector, search range.
 ; OPTIONAL INPUT PARAMETERS:
 ;    EPS
 ;	Allowed error.  Default is machine precision, according to data type,
 ;	as given by TOLER.  EPS is understood to represent absolute error
 ;	unless the keyword RELATIVE is set.  The allowed error is dynamically
 ;	adjusted during calculation.
 ; KEYWORD PARAMETERS:
 ;    /RELATIVE
 ;	If set, EPS represent the allowed relative (to the size of RANGE) error.
 ;    PARAMS
 ;	An arbitrary value or variable which is passed to the function FUN.
 ;    MULTI
 ;	Specifies multiplicity of search (i.e. what is the maximal number of
 ;	roots to look for.  Default is 1.  If MULTI is set to -1 (or any
 ;	negative number) the search is unlimited.
 ;    ERROR
 ;	Optional output, see below.
 ;    STATUS
 ;	Optional output, see below.
 ;    DONE
 ;	Optional output, see below.
 ; OUTPUTS:
 ;	Returns a vector containing the location(s) of the root(s).  The
 ;	numerical type of the result (floating, or double) is determined by the
 ;	numerical type of RANGE.  If no root is found, returns machine max.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    ERROR
 ;	The name of the variable to receive the estimated error of the root
 ;	location.  Returned as vector, same length as the function output.
 ;    STATUS
 ;	The name of the variable to receive search status information.
 ;	Returned as vector, same length as the function output.
 ;	Possible values are:
 ;	    0 - No root found.
 ;	    1 - OK.
 ;	    2 - Search converged, but the result appears to be a singularity.
 ;		This may happen with nonsingular functions if the precision
 ;		demands are set to high.
 ;    DONE
 ;	The name of the variable to receive search completion information.
 ;	Possible values are:
 ;	    0 - Indicates that the number of roots prescribed by MULTI has been
 ;		found without all of RANGE being searched.  This does not
 ;		necesserily mean that there are more roots.  Disabled for
 ;		MULTI = 1, or negative.
 ;	    1 - Indicates that search has been completed, i.e. all the roots
 ;		that could be found have been found.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses Golden section search  for minima of ABS(FUN(X)).  When an
 ;	interval where F(X) changes sign is identified, uses weighted interval
 ;	halving to pinpoint the root.
 ;	Uses CAST, DEFAULT, FPU_FIX, ISNUM and TOLER from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-FEB-92 by Mati Meron.
 ;	Modified 15-APR-92 by Mati Meron.  Added Quadratic Interpolation to
 ;	speed up convergence for smooth functions.
 ;	Modified 25-JAN-94 by Mati Meron.  Added multi-root search capability.
 ;	Quadratic Interpolation replaced by a weighted halving to increase
 ;	robustness without loosing speed.
 ;	Modified 5-OCT-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
 
     if n_elements(range) ne 2 then message, 'Improper range!'
     rlis = Cast(range,4)
     if rlis(0) gt rlis(1) then rlis = reverse(rlis)
     sinf = machar(double = Isnum(rlis,/double,type=rtyp))
     deps = Toler(type=rtyp)
     weps = abs(Default(eps,deps,/dtype))
     if keyword_set(rel) then weps = weps*(rlis(1) - rlis(0))
     weps = weps > deps*max(abs(rlis))
 
     rlis = rlis + 2*[-weps,weps]
     ervl = [weps,weps]
     stat = intarr(2)
     pfl = n_elements(pars) ne 0
     cmul = Default(mult,1,/dtype)
     if cmul eq 1 then mfl = 0 else mfl = 1
     gold = (sqrt(Cast(5,rtyp,rtyp)) - 1)/2
     ncur = 1
 
     while ncur lt n_elements(rlis) and cmul ne 0 do begin
 	csta = 0
 	x = rlis(ncur-1:ncur) + (ervl(ncur-1:ncur) > weps)*[2,-2]
 	if (x(1) - x(0)) ge weps then begin
 	    f = x
 	    if pfl then begin
 		f(0) = FPU_fix(call_function(fun,x(0),pars))
 		f(1) = FPU_fix(call_function(fun,x(1),pars))
 	    endif else begin
 		f(0) = FPU_fix(call_function(fun,x(0)))
 		f(1) = FPU_fix(call_function(fun,x(1)))
 	    endelse
 	    x = x([0,1,1])
 	    f = f([0,1,1])
 	    if f(0)*f(1) gt 0 and mfl then begin
 		x(1) = (1 - gold)*x(0) + gold*x(2)
 		if pfl then f(1) = FPU_fix(call_function(fun,x(1),pars)) else $
 		    f(1) = FPU_fix(call_function(fun,x(1)))
 		if f(0)*f(1) gt 0 then begin
 		    repeat begin
 			x = x([0,0,1,2])
 			f = f([0,0,1,2])
 			x(1) = (1 - gold)*x(0) + gold*x(2)
 			if pfl then f(1)=FPU_fix(call_function(fun,x(1),pars)) $
 			    else f(1) = call_function(fun,x(1))
 			if f(0)*f(1) gt 0 then begin
 			    comp = f(2)/f(1)
 			    if stat(ncur-1) ne 0 then comp = $
 				comp*(x(1) - rlis(ncur-1))/(x(2) - rlis(ncur-1))
 			    if stat(ncur) ne 0 then comp = $
 				comp*(x(1) - rlis(ncur))/(x(2) - rlis(ncur))
 			    if comp gt 1 then ind = [0,1,2] else ind = [3,2,1]
 			    x = x(ind)
 			    f = f(ind)
 			endif else csta = 1
 		    endrep until csta or abs(x(2) - x(0)) lt weps
 		endif else csta = 1
 	    endif else csta = f(0)*f(1) le 0
 	endif
 
 	if csta then begin
 	    if f(0)*f(1) eq 0 then begin
 		if f(0) eq 0 then x(1) = x(0)
 		cerv = 0
 	    endif else begin
 		ceps = weps
 		cerv = abs(x(1) - x(0))
 		cfl = 0
 		pow = 0.5
 		while cerv ge ceps do begin
 		    ind =  [0,0,1] + cfl
 		    x = x(ind)
 		    f = f(ind)
 		    wf = abs(f([2,0]))^pow
 		    wfx = x([0,2])*wf
 		    x(1) = (wfx(0) + wfx(1))/(wf(0) + wf(1))
 		    if pfl then f(1) = FPU_fix(call_function(fun,x(1),pars)) $
 			else f(1) = FPU_fix(call_function(fun,x(1)))
 		    if f(1) ne 0 then begin
 			cfl = f(0)*f(1) gt 0
 			nerv = abs(x(cfl+1) - x(cfl))
 			erat = nerv/cerv
 			if erat lt 0.5 then pow = 2*pow < 1. else pow = pow/2
 			if erat eq 1 then ceps = 2*ceps
 			cerv = nerv
 		    endif else cerv = 0
 		endwhile
 		if f(1) ne 0 and (f(1) - f(0))*(f(1) - f(2)) gt 0 then csta = 2
 	    endelse
 	    rlis = FPU_fix([rlis(0:ncur-1),x(1),rlis(ncur:*)])
 	    ervl = FPU_fix([ervl(0:ncur-1),cerv,ervl(ncur:*)])
 	    stat = [stat(0:ncur-1),csta,stat(ncur:*)]
 	    cmul = cmul - 1
 	    if not mfl then ncur = 3
 	endif else ncur = ncur + 1
     endwhile
 
     if ncur lt n_elements(rlis) and cmul eq 0 then don = 0 else don = 1
     found = where(stat ne 0, nfound)
     if nfound gt 0 then begin
 	rlis = rlis(found)
 	ervl = ervl(found)
 	stat = stat(found)
     endif else begin
 	rlis = sinf.xmax
 	ervl = abs(range(1) - range(0))
 	stat = 0
     endelse
 
     return, rlis
 end
 
                                 *** SEQLIM ***                          

 Function Seqlim, svl, rvl, zero_pad = zpd, error = erv, status = stat
 
 ;+
 ; NAME:
 ;	SEQLIM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Estimates limits of infinite sequences.
 ; CATEGORY:
 ;	Mathematical Function (General).
 ; CALLING SEQUENCE:
 ;	Result = SEQLIM( SVL [, RVL ] [, keywords])
 ; INPUTS:
 ;    SVL
 ;	Numeric vector containing consecutive terms of the sequence.  At least
 ;	two terms are needed.
 ; OPTIONAL INPUT PARAMETERS:
 ;    RVL
 ;	Numeric vector, same length as SVL.  Contains estimates of the
 ;	deviations of the terms of SVL from the limit.  Usually RVL is
 ;	generated internally, since if good estimates of the deviations from
 ;	the limit do exist, SEQLIM is not needed.
 ; KEYWORD PARAMETERS:
 ;    /ZERO_PAD
 ;	Switch.  Used only when RVL is not provided, specifies how a difference
 ;	series is generated from the terms of SVL.  When ZERO_PAD is set, it
 ;	implies a zero term preceding the first term of SVL, i.e. SVL has the
 ;	form of [0, SVL(0), SVL(1),...], giving rise to a difference series of
 ;	the form [SVL(0), SVL(1) - SVL(0), ...].  If ZERO_PAD is not set, the
 ;	difference series is [SVL(1) - SVL(0), ...].  Therefore, at least four
 ;	sequence values are needed in the absence of ZERO_PAD but only 3 when
 ;	ZERO_PAD is set.
 ;    ERROR
 ;	Optional output, see below.
 ;    STATUS
 ;	Ditto.
 ; OUTPUTS:
 ;	Returns the limit estimate if one is found, otherwise returns machine
 ;	maximum.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    ERROR
 ;	The name of the variable to receive the estimated error of the returned
 ;	limit value.  If the sequence doesn't seem to converge, returns machine
 ;	maximum.
 ;    STATUS
 ;	The name of the variable to receive convergence status information.
 ;	Returns 1 if the sequence converges, 0 otherwise.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses Neville's interpolation algorithm.  Calls CAST, ISNUM and
 ;	SERIES_SUM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUN-1992 by Mati Meron.
 ;	Completely rewritten 30-SEP-1998 by Mati Meron.
 ;-
 
     on_error, 1
     sinf = machar(double=Isnum(svl,/double,typ=styp))
     if styp eq 6 then wtyp = 9 else wtyp = 5
     erv = sinf.xmax
     lim = erv
     stat = 0
 
     kl = n_elements(svl) - 1
     rl = n_elements(rvl) - 1
 
     if rl ge 0 then begin
 	if rl eq kl then begin
 	    ws = Cast(svl,wtyp)
 	    wr = Cast(rvl,wtyp)
 	    if kl ge 1 then begin
 		kf = (where([1,abs(wr(1:rl))- abs(wr(0:rl-1))] ge 0,nd))(nd-1)
 		if kf lt kl then begin
 		    q = ws
 		    lim = q(kl)
 		    l = kl
 		    while l gt kf do begin
 			l = l - 1
 			for k = l+1, kl do q(k) = $
 			    (wr(l)*q(k) - wr(k)*q(k-1))/(wr(l) - wr(k))
 			nerv = abs(q(kl) - lim)
 			if nerv le erv then begin
 			    lim = q(kl)
 			    erv = nerv
 			endif else kf = kl
 		    endwhile
 		    stat = 1
 		endif
 	    endif else begin
 		lim = ws(0)
 		stat = 3
 	    endelse
 	endif else message, 'incompatible data lengths'
     endif else begin
 	zpfl = keyword_set(zpd)
 	if kl ge (3 - zpfl) then begin
 	    if zpfl then lim = Series_sum(svl-[0,svl], err= terv, stat= stat) $
 	    else lim = svl(0) + Series_sum(svl(1:*)-svl, err= terv, stat= stat)
 	    erv = erv < terv
 	endif else begin
 	    if kl ge 1 and max(svl, min = mis) eq mis then begin
 		lim = svl(0)
 		stat = 3
 	    endif else message, 'insufficient data!', /continue
 	endelse
     endelse
 
     erv = Cast(erv,4,styp,/fix)
     return, Cast(lim,4,styp,/fix)
 end
 
                               *** SERIES_SUM ***                      

 Function Series_sum, ser, error = erv, status = stat
 
 ;+
 ; NAME:
 ;	SERIES_SUM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Estimates sums of infinite series.
 ; CATEGORY:
 ;	Mathematical Function (General).
 ; CALLING SEQUENCE:
 ;	Result = SERIES_SUM( SVL [, keywords])
 ; INPUTS:
 ;    SER
 ;	Numeric vector containing consecutive terms of the series.  At least
 ;	three terms are needed to get a result, 4 or more terms to get both
 ;	result and error estimate.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    ERROR
 ;	Optional output, see below.
 ;    STATUS
 ;	Ditto.
 ; OUTPUTS:
 ;	Returns the sum estimate if one is found, otherwise returns machine
 ;	maximum.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    ERROR
 ;	The name of the variable to receive the estimated error of the returned
 ;	sum value.  If the series doesn't seem to converge, returns machine
 ;	maximum.
 ;    STATUS
 ;	The name of the variable to receive convergence status information.
 ;	Returns 1 if the series converges, 0 otherwise.  If the data is
 ;	insufficient for error estimate, returns 3.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses the routine SEQLIM from MIDL.  Also uses CAST, ISNUM and TOLER.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUN-1992 by Mati Meron.
 ;	Completely rewritten 30-SEP-1998 by Mati Meron.
 ;-
 
     on_error, 1
     sinf = machar(double=Isnum(ser,/double,typ=styp))
     erv = sinf.xmax
     lim = erv
     stat = 0
 
     if styp eq 6 then atyp = 9 else atyp = 5
     a = Cast(ser,atyp)
 
     if n_elements(a) ge 3 then begin
 	dum = where(a ne 0, na)
 	if na ge 3 then begin
 	    a = a(dum)
 	    s = a
 	    for i = 1l, na - 1 do s(i) = s(i-1) + s(i)
 	    nt = (where(abs(a) ge [0,abs(a)], ndum))(ndum-1)
 	    s = s(nt:*)
 	    a = a(nt:*)
 	    na = na - nt
 	    if na ge 3 then begin
 		b = a - [0,a]
 		c = b - [0,b]
 		q = [0,0,(b^2-a*c)(2:*)/(b-c)(2:*)]
 		zlev = abs(2*[0,0,a(2:*)]*Toler(ser)*(1-a/b))
 		bq = [0,0,b(2:*)] + q
 		nz = (where(abs([0,0,b(2:*)] + q) le zlev, ndum))(ndum-1) + 1
 		if nz lt na then begin
 		    a = a(nz:*)
 		    b = b(nz:*)
 		    q = q(nz:*)
 		    svl = s(nz:*) - a*(a + q)/(b +q)
 		    na = na - nz
 		    if max(abs(q)) eq 0 then begin
 			lim = svl(na-1)
 			erv = 0
 			stat = 1
 		    endif else begin
 			lim = Seqlim(svl,q,error=terv,status=stat)
 			erv = erv < terv
 		    endelse
 		endif else message, 'Series not converging!', /continue
 	    endif else message, 'Not enough decreasing terms', /continue
 	endif else begin
 	    if na eq 0 then begin
 		lim = 0
 		erv = 0
 		stat = 1
 	    endif else message, 'At least 3 non zero terms required!, /continue
 	endelse
     endif else message, 'At least 3 terms required!', /continue
 
     erv = Cast(erv,styp,styp,/fix)
     return, Cast(lim,styp,styp,/fix)
 end
 
                               *** SHAPE_AREA ***                      

 Function Shape_area, shape
 
 ;+
 ; NAME:
 ;	SHAPE_AREA
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates the area enclosed by a 2-dimensional shape.
 ; CATEGORY:
 ;	Mathematical Array function.
 ; CALLING SEQUENCE:
 ;	Result = SHAPE_AREA( SHAPE)
 ; INPUTS:
 ;    SHAPE
 ;	A (2,*) numeric array.  3D shapes are not supported.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	0 for failure (improper or 3D shape) else returns the area of the shape.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	Limited to 2 dimensional shapes.
 ; PROCEDURE:
 ;	Straightforward.  Calls FPU_FIX and SHAPE_VER from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 10-NOV-1992 by Mati Meron.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     ndim = Shape_ver(shape, length = len)
     if ndim ne 2 then begin
 	if ndim eq 3 then message, 'Only 2-D shapes accepted!' $
     	else message, 'Improper or missing shape!'
     endif else begin
 	offs = [len - 1, indgen(len - 1)]
 	area = 0.5*total(shape(0,offs)*shape(1,*) - shape(0,*)*shape(1,offs))
     endelse
 
     return, FPU_fix(area)
 end
 
                              *** SHAPE_CLOSE ***                     

 Function Shape_close, shape
 
 ;+
 ; NAME:
 ;	SHAPE_CLOSE
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Closes the shape, i.e. appends the first point to the end of the shape,
 ;	unless the shape is already closed in which case nothing happens.
 ; CATEGORY:
 ;	Array Manipulation / General Graphics.
 ; CALLING SEQUENCE:
 ;	Result = SHAPE_CLOSE( SHAPE)
 ; INPUTS:
 ;    SHAPE
 ;	A (2,*) or (3,*) numeric array.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	0 for failure, i.e. a missing or invalid shape, otherwise returns the
 ;	closed shape.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Uses calls to ARREQ and SHAPE_VER in MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;-
 
     if (Shape_ver(shape, len = shlen)) eq 0 then begin
 	message, 'Missing or invalid shape!', /continue
 	return, 0b
     endif else begin
 	if Arreq(shape(*,0),shape(*,shlen-1)) then return, shape $
 	else return, [[shape],[shape(*,0)]]
     endelse
 end
 
                              *** SHAPE_COCON ***                     

 Function Shape_cocon, shape, from = sor, to = des
 
 ;+
 ; NAME:
 ;	SHAPE_COCON
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Converts 2 or 3 dimensional shapes from the FROM to the TO coordinate
 ;	system.  Allowed systems are DATA, DEVICE (only for 2-dim shapes) and
 ;	NORMAL.  In principle identical to the system routine CONVERT_COORD,
 ;	SHAPE_COCON is maintained for historical reasons.
 ; CATEGORY:
 ;	Plotting / General Graphics.
 ; CALLING SEQUENCE:
 ;	Result = SHAPE_COCON( SHAPE [,keywords])
 ; INPUTS:
 ;    SHAPE
 ;	A (2,*) or (3,*) array.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    FROM
 ;	Specifies input coordinate system.  Possible values are 'DATA',
 ;	'DEVICE' and 'NORMAL' (Only the first 3 characters matter).  Default
 ;	is 'DATA'.
 ;    TO
 ;	Same as FROM for the output coordinate system.
 ; OUTPUTS:
 ;	0 for failure (improper shape or bad keyword value) else returns the
 ;	transformed shape.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses calls to CAST, COO_CONV, DEFAULT and SHAPE_VER, from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Modified 30-JUL-1999 by Mati Meron.  Type conversion bug fixed.
 ;-
 
     ndim = Shape_ver(shape)
     if not ndim then begin
 	message, 'Missing or invalid shape!', /continue
 	return, 0
     endif else res = Cast(shape,4)
 
     sor = Default(sor,'DATA')
     des = Default(des,'DATA')
 
     if sor ne des then begin
 	for i = 0, ndim - 1 do begin
 	    res[i,*] = Coo_conv(res[i,*], axis = i, from = sor, to = des)
 	endfor
     endif
 
     return, res
 end
 
                               *** SHAPE_EDGE ***                      

 Function Shape_edge, shape, edge, segment = seg, close = clo, exists = exs
 
 ;+
 ; NAME:
 ;	SHAPE_EDGE
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Modifies a SHAPE (see SHAPE_VER for a definition) by cutting it along
 ;	a straight edge.
 ; CATEGORY:
 ;	General Graphics.
 ; CALLING SEQUENCE:
 ;	Result = SHAPE_EDGE( SHAPE, EDGE [, keywords])
 ; INPUTS:
 ;    SHAPE
 ;	Two dimensional shape i.e. a (2,*) numeric array.
 ;    EDGE
 ;	An (2,2) numeric array representing a straight line in the
 ;	[[point],[direction]] format, i.e. EDGE(*,0) is a point on the line,
 ;	EDGE(*,1) is a vector in the direction of the line.  This format can be
 ;	changed using the SEGMENT keyword (see below).
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /SEGMENT
 ;	Switch.  If set, the line provided by EDGE is assumed to be in a
 ;	[[point1],[point2]] format, i.e. EDGE(*,0) and EDGE(*,1) are two
 ;	different points on the line.
 ;    /CLOSE
 ;	Switch.  If set, forces closure of the output shape.  If the input
 ;	shape happens to be closed, the output one is being closed
 ;	automatically unless CLOSE is explicitly set to zero.
 ;    EXISTS
 ;	Optional output, see below.
 ; OUTPUTS:
 ;	Returns a new shape, made of the points of the original shape which
 ;	were not cut off by the edge, plus the points introduced by the edge
 ;	line cutting through line segments of the original shape.
 ;	Important:  The edge line is DIRECTED.  Its direction is the direction
 ;	of the direction vector.  The points to the left of the line (relative
 ;	to the line direction) are maintained, those to the right are cut off.
 ;	This is consistent with viewing the edge line as part of a mathematical
 ;	contour (in a mathematically positive direction) and keeping the points
 ;	inside the contour.
 ;	If there are no points left in the result shape, a single point (i.e.
 ;	2D vector) with X and Y coordinates equal to the square root of the
 ;	maximal floating value (machine dependent) is returned.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    EXISTS
 ;	The name of a variable to receive calculation status result.  Returns
 ;	1b if the result shape is non-empty, 0b otherwise.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses LINCROSS from MIDL to find crossing points of the EDGE line and
 ;	the shape and adjusts the shape appropriately.  Also calls ARREQ,
 ;	DEFAULT, FPU_FIX, SHAPE_CLOSE, SHAPE_VER, VINP and VNORM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 10-NOV-1997 by Mati Meron.
 ;	Modified 20-JUL-1999 by Mati Meron.  Added keywords SEGMENT and EXISTS.
 ;-
 
     on_error, 1
     sinf = machar()
     res = sqrt(reform(replicate(sinf.xmax,2),2,1))
     exs = 0b
 
     wedge = edge
     if keyword_set(seg) then wedge(*,1) = wedge(*,1) - wedge(*,0)
     ep = wedge(*,0)
     ed = wedge(*,1)
     if Vnorm(ed) eq 0 then begin
 	message, 'Line direction not defined!', /continue
 	return, 0
     endif
     en = [-ed(1),ed(0)]
 
     ndim = Shape_ver(shape,len = np)
     if ndim ne 2 then begin
 	if ndim eq 3 then message, 'Only 2-D shapes accepted!', /continue $
 	else message, 'Improper or missing shape!', /continue
 	return, 0
     endif
 
     pos = reform(en#shape - Vinp(en,ep)) ge 0
     a = where(pos gt [0,pos], nsec)
     if nsec gt 0 then begin
 	b = where(pos gt [pos(1:*),0])
 	for i = 0l, nsec - 1 do begin
 	    if a(i) ne 0 then begin
 		id = Lincross(wedge,shape(*,a(i)-1:a(i)),lin = 1,cross = cro)
 		if id and not Arreq([cro],shape(*,a(i))) then res=[[res],[cro]]
 	    endif
 	    res = [[res],[shape(*,a(i):b(i))]]
 	    if b(i) ne np - 1 then begin
 		id = Lincross(wedge,shape(*,b(i):b(i)+1),lin = 1,cross = cro)
 		if id and not Arreq([cro],shape(*,b(i))) then res=[[res],[cro]]
 	    endif
 	endfor
 	res = res(*,1:*)
 	if (size(res))(0) eq 1 then res = [[res],[res]]
 	if (Arreq(shape(*,0),shape(*,np-1)) and Default(clo,1) ne 0) $
 	or keyword_set(clo) then res = Shape_close(res)
 	exs = 1b
     endif
 
     return, FPU_fix(res)
 end
 
                             *** SHAPE_OVERLAP ***                   

 Function Shape_overlap, shape1, shape2, exists = exs
 
 ;+
 ; NAME:
 ;	SHAPE_OVERLAP
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Finds the SHAPE (see SHAPE_VER for a definition) resulting from the
 ;	overlap of two given shapes.
 ; CATEGORY:
 ;	General Graphics.
 ; CALLING SEQUENCE:
 ;	Result = SHAPE_OVERLAP( SHAPE1, SHAPE2[, EXISTS = EXS])
 ; INPUTS:
 ;    SHAPE1
 ;	Two dimensional shape i.e. a (2,*) numeric array.
 ;    SHAPE2
 ;	Ditto
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    EXISTS
 ;	Optional output, see below.
 ; OUTPUTS:
 ;	Returns a new shape, which is the overlap of the original two shapes.
 ;	Important:  For the purpose of the calculation the two shapes are
 ;	assumed to have the same direction (even if they don't)
 ;	If there are no points left in the result shape, a single point (i.e.
 ;	2D vector) with X and Y coordinates equal to the square root of the
 ;	maximal floating value (machine dependent) is returned.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    EXISTS
 ;	The name of a variable to receive calculation status result.  Returns
 ;	1b if the result shape is non-empty, 0b otherwise.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Performs cuts on one shape with the lines of the other, using the
 ;	routine SHAPE_EDGE from MIDL.  Also calls FPU_FIX, SHAPE_AREA,
 ;	SHAPE_CLOSE and SHAPE_VER, from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 20-JUL-1999 by Mati Meron.
 ;-
 
     on_error, 1
     exs = 0b
 
     wsh1 = Shape_close(shape1)
     wsh2 = Shape_close(shape2)
     nd1 = Shape_ver(wsh1,len = np1)
     nd2 = Shape_ver(wsh2,len = np2)
     if nd1 ne 2 or nd2 ne 2 then begin
 	message, 'Only 2-D shapes accepted!', /continue
 	return, 0b
     endif
 
     if np1 ge np2 then begin
 	fir = temporary(wsh1)
 	sec = temporary(wsh2)
 	np = np2
     endif else begin
 	fir = temporary(wsh2)
 	sec = temporary(wsh1)
 	np = np1
     endelse
     if Shape_area(fir)*Shape_area(sec) lt 0 then sec = reverse(sec)
 
 
     for i = 0l, np-2 do begin
 	fir = Shape_edge(fir,sec(*,i:i+1),/seg,exists=exs)
 	if exs eq 0 then i = np-1
     endfor
 
     return, FPU_fix(fir)
 end
 
                              *** SHAPE_TRANS ***                     

 Function Shape_trans, shape, ang, mag, roff, $
     degrees = deg, flip = ax, center = cen
 
 ;+
 ; NAME:
 ;	SHAPE_TRANS
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Performs a geometrical transformation of an arbitrary 2_dim shape.
 ;	The transformation may include (in order):
 ;	    1)	Magnification by MAG.  If MAG is a 2-dim vector, X and Y
 ;		coordinates are magnified by MAG(0) and MAG(1) respectively.
 ;		If FLIP is set, the magnification will include inversion in
 ;		the X or Y axis, according to the value of FLIP.
 ;	    2)	Rotation by the angle ANG.
 ;	    3)	Translation by ROFF.
 ; CATEGORY:
 ;	General Graphics.
 ; CALLING SEQUENCE:
 ;	Result = SHAPE_TRANS( SHAPE [,parameters] [,keywords])
 ; INPUTS:
 ;    SHAPE
 ;	A (2,*) numeric array.  Future support for 3D shapes is planned.
 ; OPTIONAL INPUT PARAMETERS:
 ;    ANG
 ;	Rotation angle, assumed to be measured in radians, unless /DEGREES is
 ;	set.  Default value is 0, i.e. no rotation.
 ;    MAG
 ;	Magnification factor, can be given as a scalar (in which case both
 ;	dimensions are multiplied by this scalar) or a 2 dimensional vector (in
 ;	which case the X and Y dimensions are multiplied by MAG(0) and MAG(1)
 ;	respectively.  Default value is 1, i.e. no magnification.
 ;    ROFF
 ;	Translation vector.  Can be given as a scalar (in which case same
 ;	translation is applied to both dimensions) or as a 2 dimensional
 ;	vector.  Default is [0,0], i.e. no translation.
 ; KEYWORD PARAMETERS:
 ;    /DEGREES
 ;	Switch.  If set, the angle value is given in degrees.
 ;    FLIP
 ;	Accepts a char value ('X' or 'Y').  Causes inversion in the
 ;	appropriate axis.
 ;    /CENTER
 ;	Switch.  If set, the transformations are performed relative to the
 ;	center of the shape, given by the average of the minimal and maximal
 ;	value in each dimension.  By default the transformation center is [0,0].
 ; OUTPUTS:
 ;	0 for failure (improper or 3D shape) else returns the transformed shape.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	Currently limited to 2 dimensional shapes.
 ; PROCEDURE:
 ;	Uses calls to DEFAULT, FPU_FIX, SHAPE_VER, STRMATCH_MM and TYPE from
 ;	MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Modified 10-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     ndim = Shape_ver(shape)
     if not ndim then begin
 	message, 'Improper or missing shape!', /continue
 	return, 0
     endif else begin
 	if ndim eq 3 then begin
 	    message, 'Only 2-dimensional shapes accepted!', /continue
 	    return, 0
 	endif
     endelse
 
     dang = Default(ang,0.,low = 4)
     if keyword_set(deg) then dang = !dtor*dang
     srot = [[cos(dang),sin(dang)],[-sin(dang),cos(dang)]]
     dmag = Default(mag,1.,low = 4)
     if n_elements(dmag) eq 1 then dmag = replicate(dmag,ndim)
     if Type(ax) eq 7 then begin
 	iflip = StrMatch_mm(ax,['X','Y','Z'],1)
 	dmag(iflip) = -dmag(iflip)
     endif
     droff = Default(roff,0.,low = 4)
     if n_elements(droff) eq 1 then droff = replicate(droff,ndim)
 
     res = float(shape)
     if keyword_set(cen) then begin
 	for i = 0, ndim - 1 do begin
 	    top = max(res(i,*), min = bot)
 	    pcen = (top + bot)/2
 	    droff(i) = droff(i) + pcen
 	    res(i,*) = res(i,*) - pcen
 	endfor
     endif
     for i = 0, ndim - 1 do begin
 	if dmag(i) ne 1 then res(i,*) = dmag(i)*res(i,*)
     endfor
     if dang ne 0 then res = srot#res
     for i = 0, ndim - 1 do begin
 	if droff(i) ne 0 then res(i,*) = droff(i) + res(i,*)
     endfor
 
     return, FPU_fix(res)
 end
 
                               *** SHAPE_VER ***                       

 Function Shape_ver, shape, length = len
 
 ;+
 ; NAME:
 ;	SHAPE_VER
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Checks whether SHAPE is a proper shape, i.e. a (2,*) or (3,*) , numeric
 ;	non-complex array.
 ; CATEGORY:
 ;	General Graphics.
 ; CALLING SEQUENCE:
 ;	Result = SHAPE_VER( SHAPE [, LENGTH = LEN])
 ; INPUTS:
 ;    SHAPE
 ;	Arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    LENGTH
 ;	Provides an optional output.  See below.
 ; OUTPUTS:
 ;	If SHAPE fits the definition of a proper shape (see above), returns the
 ;	number of dimensions (2 or 3) as floating, otherwise returns 0.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    LENGTH
 ;	The name of a variable to receive the length (number of points) of the
 ;	shape.  If the shape isn't defined or isn't proper, the value is 0.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses information provided by the system function SIZE.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron under the name IS_SHAPE.
 ;	Renamed SHAPE_VER, 25-NOV-1993 for consistency with other shape routines
 ;-
 
     siz = size(shape)
     if siz(0) eq 2 then begin
 	proper = (siz(1) eq 2 or siz(1) eq 3) and siz(3) lt 6
 	len = siz(2)*proper
 	return, float(siz(1))*proper
     endif else begin
 	len = 0
 	return, 0.
     endelse
 end
 
                                *** SHUFFLE ***                         

 Function Shuffle, arr, seed = sed
 
 ;+
 ; NAME:
 ;	SHUFFLE
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Randomizes an array.
 ; CATEGORY:
 ;	Array function.
 ; CALLING SEQUENCE:
 ;	Result = SHUFFLE( ARR [, SEED = SEED])
 ; INPUTS:
 ;    ARR
 ;	Array, arbitrary type.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    SEED
 ;	Randomization seed, optional.
 ; OUTPUTS:
 ;	Returns an array with the same values as the original one but in random
 ;	order.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Uses the system routine RANDOMU.
 ; MODIFICATION HISTORY:
 ;	Created 1-MAY-1995 by Mati Meron.
 ;-
 
     on_error, 1
     if n_elements(sed) ne 0 then wsed = sed
 
     return, arr(sort(randomu(wsed,n_elements(arr))))
 end
 
                                  *** SIGN ***                            

 Function Sign, x
 
 ;+
 ; NAME:
 ;	SIGN
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Gives the sign of X, i.e. 1 for positive, -1 for negative, 0 for 0.
 ; CATEGORY:
 ;	Mathematical Function (General).
 ; CALLING SEQUENCE:
 ;	Result = SIGN(X)
 ; INPUTS:
 ;    X
 ;	Numerical, otherwise arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the value of SIGN(X), see above, as an long integer.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	For complex X the result is SIGN(REAL(X)), the imaginary part is ignored
 ; PROCEDURE:
 ;	Straightforward.  Using CAST from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Modified 25-DEC-1991 by Mati Meron.
 ;	Modified 5-DEC-1993 by Mati Meron.  Output type changed to LONG.
 ;-
 
     temx = Cast(x,0,5)
     return, long((temx gt 0)) - (temx lt 0)
 end
 
                               *** SMOOTH_MM ***                       

 Function Smooth_mm, arr, wid, deriv = nder, edge_truncate = edt
 
 ;+
 ; NAME:
 ;	SMOOTH_MM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Non broadening data smoothing.
 ; CATEGORY:
 ;	Array function.
 ; CALLING SEQUENCE:
 ;	Result = SMOOTH_MM( ARR, WID [keywords])
 ; INPUTS:
 ;    ARR
 ;	Array, numeric, no more than six dimensions.
 ;    WID
 ;	The width of the smoothing window.  Can be given either as a scalar (in
 ;	which case it is applied to all the dimensions of the array, or as a
 ;	vector (in which case each entry applies to one dimension).  The WIDTH
 ;	entry(s) should be an odd number(s), if it is even the next higher odd
 ;	number(s) will be used.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    DERIV
 ;	Causes the smoothed derivative (first or second) of the data to be
 ;	returned instead of the data itself.  Currently valid only for 1D
 ;	arrays.
 ;    /EDGE_TRUNCATE
 ;	Switch.  Same as in the IDL version of SMOOTH.
 ; OUTPUTS:
 ;	Returns the smoothed array or (optionally) its first or second
 ;	derivative.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses a variation of the Savitzky-Golay procedure.  Superior to the IDL
 ;	provided SMOOTH routine in the sense that it doesn't introduce peak
 ;	broadening.  Note that:
 ;
 ;	1)  The width needed obtain a given degree of smoothing is about twice
 ;	    as big as with SMOOTH (which isn't a problem since this extra width
 ;	    doesn't cause broadening.
 ;	2)  Since the averaging kernel isn't positive definite, in some rare
 ;	    cases (high and very narrow peaks with little or no background)
 ;	    SMOOTH_MM may generate artifacts.
 ;
 ;	Calls CAST, CONVOL_MM, DEFAULT, DIAGOARR, MAKE_GRID, SOLVE_LINSYS and
 ;	TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 25-JAN-1997 by Mati Meron as M_SMOOTH.
 ;	Renamed 25-SEP-1999 by Mati Meron, to SMOOTH_MM.
 ;-
 
     on_error, 1
     ndmx = 6
 
     siz = size(reform([arr]))
     ndm = siz(0)
     if ndm gt ndmx then message, 'At most six dimensions are allowed'
     nder = Default(nder,0,/dtype)
 
     if nder gt 0 then begin
 	if ndm gt 1 then message, 'Derivatives allowed only with 1D data'
 	wwid = Default(wid,3l,/dtype) > 3l
     endif else begin
 	wwid = Default(wid,1l,/dtype) > 1l
 	if n_elements(wwid) eq 1 then wwid = replicate(wwid,ndm) else $
 	if n_elements(wwid) ne ndm then message, 'Improper width dimension!'
     endelse
 
     m = Cast(floor(wwid/2.),4,Type(arr))
     if nder gt 0 then k = findgen(2*m+1) - m
     if min(siz(1:ndm) - 2*m - 1) lt 0 then message, 'Width exceeds array size'
 
     case nder of
 	0:	begin
 		    ks = (Make_grid(transpose([[-m],[m]]),2*m+1,fun=ker))^2
 
 		    s2 = [1.,m*(m+1)/3]
 		    s4 = s2*[1.,(3*m^2 + 3*m - 1)/5]
 		    sar = s2#transpose(s2) + Diagoarr(s4 - s2^2)
 		    rhs = [1.*ndm/n_elements(ks),fltarr(ndm)]
 		    lam = Solve_linsys(sar,rhs,/svd)
 
 		    ker = ker + lam(0)
 		    if ndm eq 1 then ker = ker + lam(1)*ks else $
 		    for i = 0, ndm-1 do ker = ker + lam(i+1)*ks(i,*,*,*,*,*)
 		    ker = reform(ker,2*m+1)
 		end
 	1:	ker = -3.*k/(m*(m+1)*(2*m+1))
 	2:	ker = 30.*(3*k^2 - m*(m+1))/(m*(m+1)*(2*m-1)*(2*m+1)*(2*m+3))
 	else:	message, 'Derivative of order'+ string(nder)+ ' not supported!'
     endcase
 
     if not keyword_set(edt) then begin
 	l = lonarr(ndmx)
 	l(0:ndm-1) = m
  	h = lonarr(ndmx)
 	h(0:ndm-1) = siz(1:ndm) - m - 1
 	res = Cast(arr,4)
 	tres = Convol_mm(arr,ker)
 	res(l(0):h(0),l(1):h(1),l(2):h(2),l(3):h(3),l(4):h(4),l(5):h(5)) = $
 	tres(l(0):h(0),l(1):h(1),l(2):h(2),l(3):h(3),l(4):h(4),l(5):h(5))
     endif else res = Convol_mm(arr,ker,/edge_trun)
 
     return, res
 end
 
                              *** SOLVE_LINSYS ***                    

 Function Solve_linsys, arr, rhs, threshold = thresh, status = stat, row = row,$
     svd = svdfl, umat = u, vmat = v, dvec = wvec
 
 ;+
 ; NAME:
 ;	SOLVE_LINSYS
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Solves the system of linear equations ARR*X = RHS
 ; CATEGORY:
 ;	Mathematical Function /matrix manipulation.
 ; CALLING SEQUENCE:
 ;	Result = SOLVE_LINSYS( ARR, RHS [, keywords])
 ; INPUTS:
 ;    ARR
 ;	Matrix, numeric.  Must be square, unless the keyword SVD is set.
 ;    RHS
 ;	Vector representing the right hand side of the equation.  Length should
 ;	be compatible to the dimensions of the matrix.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    THRESHOLD
 ;	Sets the threshold that's used to determine whether the matrix is
 ;	regular.  Default value is 1e-20.  See OPTIONAL OUTPUT PARAMETERS for
 ;	details.
 ;    STATUS
 ;	Optional output, see below.
 ;    /ROW
 ;	Switch.  If set, ARR is taken in a row major format.  Default is
 ;	column major (IDL standard).
 ;    /SVD
 ;	Switch.  Specifies solution using the Singular Value Decomposition
 ;	method.  Default is LU decomposition.
 ;    UMAT
 ;	Optional SVD output.  See below.
 ;    VMAT
 ;	Optional SVD output.  See below.
 ;    DVEC
 ;	Optional SVD output.  See below.
 ; OUTPUTS:
 ;    Returns the solution of the linear system in a vector form, type floating
 ;    or higher.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    STATUS
 ;	The name of the variable to receive the status flag for the operation.
 ;	Possible values are 0 for a singular ARR, 1 for regular.  ARR is
 ;	considered singular if the ratio of the smallest and largest diagonal
 ;	element in the LU decomposition (or the diagonal part of the SVD
 ;	decomposition) of ARR is less then THRESHOLD.
 ;    UMAT
 ;	SVD only.  The name of the variable to receive the U matrix from the
 ;	SVD decomposition.  See SVD routine for more detail.
 ;    VMAT
 ;	SVD only.  The name of the variable to receive the V matrix from the
 ;	SVD decomposition.  See SVD routine for more detail.
 ;    DVEC
 ;	Named variable.  Result depends on calculation mode, namely:
 ;	    LU 	:    vector of the diagonal elements of the LU decomposition.
 ;	    SVD	:    vector of the diagonal elements of W (see the SVD routine).
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Normally uses LU decomposition and backsubstitution, followed by LU
 ;	correction.  These operations are perfomed by the system routines
 ;	LUDC, LUSOL and LUMPROVE, based on routines from the book NUMERICAL
 ;	RECIPES IN C.  If the keyword SVD is set, the solution is obtained
 ;	using Singular Value Decomposition, and back-substitution performed by
 ;	the system routines SVDC and SVSOL (same source).  Also uses the
 ;	functions CAST, DEFAULT, DIAGOVEC, FPU_FIX, ISNUM and TOLER from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-DEC-1991 by Mati Meron.
 ;	Modified 25-MAY-1993 by Mati Meron.  SVD option added.
 ;	Modified 30-JUN-1995 by Mati Meron.  Changed from the SVD and SVBKSB
 ;	routines to the new SVDC and SVSOL.  The change is transparent to the
 ;	user other than the fact that that it allows for a DOUBLE type SVD
 ;	solution.
 ;	Modified 25-MAR-1997 by Mati Meron.  Changed from LUDCMP, LUBKSB and
 ;	MPROVE to the newer LUDC, LUSOL and LUMPROVE.  Same as with the
 ;	previous change, it is transparent for the user other than the fact
 ;	that it allows for a DOUBLE type solution.
 ;	Also added the keyword ROW which allows for treating the input matrix
 ;	in standard algebraic fashion, instead of the transposed IDL fashion.
 ;	Modified 10-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     siz = size(arr)
     if siz(0) ne 2 then message, 'Not a matrix!' else $
     if n_elements(rhs) ne siz(1) then message, 'Incompatible sizes!'
     dob = Isnum(arr,/double) or Isnum(rhs,/double)
     thresh = Default(thresh,Toler(double=dob))
     col = keyword_set(row) eq 0
 
     if keyword_set(svdfl) then begin
 	if siz(1) lt siz(2) then begin
 	    tarr = [arr,fltarr(siz(2) - siz(1), siz(2))]
 	    trhs = [rhs,fltarr(siz(2) - siz(1))]
 	endif else begin
 	    tarr = arr
 	    trhs = rhs
 	endelse
 	svdc, tarr, w, u, v, double = dob, column = col
 	u = FPU_fix(u)
 	v = FPU_fix(v)
 	w = FPU_fix(w)
 	wvec = w
 	abw = abs(wvec)
 	smalw = where(abw lt thresh*max(abw), scon)
 	if scon gt 0 then w(smalw) = 0
 	res = svsol(u,w,v,trhs, double = dob, column = col)
     endif else begin
 	if siz(1) ne siz(2) then message, 'Not a square matrix!'
 	tarr = arr
 	trhs = Cast(rhs,4)
 	ludc, tarr, ivec, double = dob, column = col
 	tarr = FPU_fix(tarr)
 	wvec = Diagovec(tarr)
 	abw = abs(wvec)
 	smalw = where(abw lt thresh*max(abw), scon)
 	res = lusol(tarr,ivec,trhs, double = dob, column = col)
 	res = lumprove(arr,tarr,ivec,trhs,res, double = dob, column = col)
     endelse
     stat = (scon eq 0)
 
     return, FPU_fix(res)
 end
 
                                *** SORPURGE ***                        

 Function Sorpurge, arr, netlen = nl
 
 ;+
 ; NAME:
 ;	SORPURGE
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Similar to the SORT function, but ignores repeated values of elements.
 ; CATEGORY:
 ;	Array Manipulation.
 ; CALLING SEQUENCE:
 ;	Result = SORPURGE ( ARR [, keywords])
 ; INPUTS:
 ;    ARR
 ;	The array to be sorted (scalar is also accepted).
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    NETLEN
 ;	Optional output, see below.
 ; OUTPUTS:
 ;	Returns a vector of indices that allow access to all DIFFERENT elements
 ;	of ARR in ascending order.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    NETLEN
 ;	The name of a variable to receive the number of elements .
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses SORT to order the array, then finds all the elements that differ
 ;	from their predecessors.
 ; MODIFICATION HISTORY:
 ;	Created 15-AUG-1992 by Mati Meron.
 ;-
 
     on_error, 1
 
     nl = n_elements(arr)
     if nl eq 0 then message, 'Variable is not defined!' $
     else if nl eq 1 then sorp = [0l] $
     else begin
 	sorp = sort(arr)
 	dum = arr(sorp)
 	wdum = where((dum(1:nl-1) - dum(0:nl-2)) ne 0, ndif)
 	if ndif eq 0 then sorp = [0l] else sorp = sorp([0, 1 + wdum])
 	nl = 1 + ndif
     endelse
 
     return, sorp
 end
 
                               *** SPLINROOT ***                       

 Function Splinroot, spc, range, eps, error = ervl, status = stat, done = don, $
     _extra = _e
 
 ;+
 ; NAME:
 ;	SPLINROOT
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Finds roots of function provided as a set of spline coefficients.
 ; CATEGORY:
 ;	Mathematical function (general).
 ; CALLING SEQUENCE:
 ;	Result = SPLINROOT(SPC [,RANGE ] [, EPS] [, keywords])
 ; INPUTS:
 ;    SPC
 ;	An (n,3) array of spline coefficients, generated by SPLIN_COEFFS.
 ; OPTIONAL INPUT PARAMETERS:
 ;    RANGE
 ;	Search range.  Defaults to full range present in SPC.  If exceeding
 ;	the range in SPC, a warning is issued.
 ;    EPS
 ;	Allowed error.  Default is machine precision (according to data type).
 ; KEYWORD PARAMETERS:
 ;	All the keyword parameters of ROOT with the exception of PARAMS are
 ;	accepted.
 ; OUTPUTS:
 ;	Returns a vector containing the location(s) of the root(s).  If no root
 ;	is found returns machine maximum.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	Same as for the function ROOT, i.e. ERROR, STATUS and DONE.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Calls ROOT from MIDL, using SPLIN_EVAL (also from MIDL) as the function
 ;	to provide the roots.  Also calls DEFAULT, from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 25-NOV-1996 by Mati Meron.
 ;-
 
     on_error, 1
     drange = [min(spc(*,0),max=xmax),xmax]
     wrange = Default(range,drange, /dtyp)
     if wrange(0) gt wrange(1) then wrange = reverse(wrange)
 
     if wrange(0) lt drange(0) or wrange(1) gt drange(1) then begin
 	wrange(0) = wrange(0) > drange(0)
 	wrange(1) = wrange(1) < drange(1)
 	message, 'Warning, range has been truncated!', /continue
     endif
 
     return, Root('Splin_eval', wrange, eps, param = spc, $
 	error = ervl, status = stat, done = don, _extra = _e)
 
 end
 
                                 *** SPLINT ***                          

 Function Splint, x, spc, value_only = val
 
 ;+
 ; NAME:
 ;	SPLINT
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Integrates a function provided as a set of spline coefficients.
 ; CATEGORY:
 ;	Mathematical Function (general).
 ; CALLING SEQUENCE:
 ;	Result = SPLINT (X, SPC [/VALUE_ONLY])
 ; INPUTS:
 ;    X
 ;       Numeric vector, 2 or more points.  The X coordinates of the data.
 ;    SPC
 ;       An (n,3) array of spline coefficients, created by the function
 ;       SPLIN_COEEFS.
 ; KEYWORD PARAMETERS:
 ;    /VALUE_ONLY
 ;	Switch.  Normally SPLINT returns the integral function of Y, as a vector
 ;	(see OUTPUTS below).  If VALUE_ONLY is set, only the full value of the
 ;	integral is returned as scalar.  This makes the execution faster.
 ; OUTPUTS:
 ;	Normally returns the integral function of Y, i.e. a vector whose i-th
 ;	entry is the integral of Y from X(0) to X(i) (and therefore the last
 ;	entry is the full integral of Y.  If the optional keyword VALUE_ONLY is
 ;	set, only the full integral is returned, as a scalar.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	The X vector must be of length >= 2.
 ; PROCEDURE:
 ;	Exact integration, of the cubic-spline approximation to the function.
 ;	Uses FPU_FIX and SPLIN_EVAL from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 20-FEB-1993 by Mati Meron.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     nv = n_elements(x)
     if nv lt 2 then message, 'Insufficient data!'
 
     xw = x(sort(x))
     yw = Splin_eval(x,spc)
     zw = (1./6)*Splin_eval(x,spc, deriv = 2)
     tem = replicate(1,nv)
 
     dum = where(spc(*,0) gt xw(0) and spc(*,0) lt xw(nv-1), ndum)
     nw = nv + ndum
     if ndum ne 0 then begin
 	xw = [xw, spc(dum,0)]
 	yw = [yw, spc(dum,1)]
 	zw = [zw, spc(dum,2)]
 	tem = [tem,intarr(ndum)]
 	sork = sort(xw)
 	xw = xw(sork)
 	yw = yw(sork)
 	zw = zw(sork)
 	tem = tem(sork)
     endif
 
     dxh = 0.5*(xw(1:nw-1) - xw(0:nw-2))
     res = [0, dxh*(yw(1:nw-1) + yw(0:nw-2) - 2*dxh^2*(zw(1:nw-1) + zw(0:nw-2)))]
 
     if not keyword_set(val) then begin
 	for i = 2l, nw - 1 do res(i) = res(i) + res(i-1)
 	res = res(where(tem))
     endif else res = total(res)
 
     return, FPU_fix(res)
 end
 
                              *** SPLIN_COEFFS ***                    

 Function Splin_coeffs, x, y, segmented = seg
 
 ;+
 ; NAME:
 ;	SPLIN_COEFFS
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates cubic splines coefficients which are intended to be used by
 ;	the supplementary function SPLIN_EVAL.  The combination of SPLIN_COEFFS
 ;	and SPLIN_EVAL is more efficient than the library function SPLINE when
 ;	repeated interpolations based on the same data set are performed.
 ; CATEGORY:
 ;	Mathemetical Function (General).
 ; CALLING SEQUENCE:
 ;	Result = SPLIN_COEFFS( X, Y [, /SEGMENTED] )
 ; INPUTS:
 ;    X
 ;	Vector, numeric, at least 2 elements.  Contains the X coordinates of
 ;	the data, in arbitrary order.
 ;    Y
 ;	Vector, numeric, same length as X.  Contains the Y values corresponding
 ;	to the values in X.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    /SEGMENTED
 ;	Switch.  If set the input data is treated as segmented, where segment
 ;	boundary is defined as two consecutive points with the same X
 ;	coordinate.  Spline fitting is performed on each segment separately.
 ;	In default operation, whenever multiple points with the same X
 ;	coordinate are encountered, all but the first one are deleted.
 ; OUTPUTS:
 ;	Returns an (n,3) array where n is the number of data points.  The
 ;	columns of the result are:
 ;	    0 -	X values, sorted in increasing order.
 ;	    1 - Corresponding Y values.
 ;	    2 - Calculated corresponding spline coefficients.
 ;	This array is intended to be used as an input to the function SPLIN_EVAL
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	As mentioned above, the X and Y arrays must have at least 2 elements.
 ;	Also, if the keyword SEGMENTED is used, the arrays must be presorted in
 ;	ascending order.  In normal (not SEGMENTED) evaluation the order
 ;	doesn't matter.
 ; PROCEDURE:
 ;	Standard Cubic spline evaluation (see Numerical Recipies, chapt. 3.3)
 ;	with the boundary condition of 0 THIRD derivative (constant end
 ;	curvature).  Calls itself recursively.  Also uses calls to CAST,
 ;	FPU_FIX and SORPURGE in MIDL.  If X and Y have only 2 elements, the
 ;	spline is a plain linear fit.
 ; MODIFICATION HISTORY:
 ;	Created 15-APR-1992 by Mati Meron.
 ;	Modified 15-AUG-1992 by Mati Meron.  Replaced SORT with SORPURGE in
 ;	order to protect against a possible repetition of x values.
 ;	Modified 10-FEB-1993 by Mati Meron.  Added SEGMENTED option.
 ;	Modified 10-APR-1993 by Mati Meron.  Added acceptance of 2-point data.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     nv = n_elements(x)
     if nv lt 2 then message, 'Insufficient data!'
     if n_elements(y) ne nv then message, 'X & Y lengths must be equal!'
 
     if keyword_set(seg) then begin
 	wx = x
 	wy = y
 	dum = where(wx(1:nv-1) - wx(0:nv-2) eq 0, ndum)
 	if ndum eq 0 then dum = [nv-1] else dum = [dum, nv-1]
 	res = Splin_coeffs(wx(0:dum(0)), wy(0:dum(0)))
 	for i = 0l, ndum - 1 do res = $
 	[res,Splin_coeffs(wx(dum(i)+1:dum(i+1)),wy(dum(i)+1:dum(i+1)))]
     endif else begin
 	sox = Sorpurge(x, netlen = nv)
 	if nv lt 2 then message, 'Insufficient useful data!'
 	wx = Cast(x(sox),4)
 	wy = Cast(y(sox),4)
 
 	if nv gt 2 then begin
 	    dex = wx(1:nv-1) - wx(0:nv-2)
 	    dey = wy(1:nv-1) - wy(0:nv-2)
 	    cdex = 2*(dex(0:nv-3) + dex(1:nv-2))
 	    deydex = dey/dex
 	    ddey = deydex(1:nv-2) - deydex(0:nv-3)
 	    spc = trisol([0,dex],[-dex(0),cdex,-dex(nv-2)],[dex,0],[0,ddey,0])
 	endif else spc = 0.*wy
 
 	res = [[wx],[wy],[spc]]
     endelse
 
     return, FPU_fix(res)
 end
 
                               *** SPLIN_EVAL ***                      

 Function Splin_eval, x, spc, deriv = nder
 
 ;+
 ; NAME:
 ;	SPLIN_EVAL
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Cubic spline evaluation using spline coefficients supplied by the
 ;	supplementary function SPLIN_COEFFS.  The combination of SPLIN_COEFFS
 ;	and SPLIN_EVAL is more efficient than the library function SPLINE when
 ;	repeated interpolations based on the same data set are performed.
 ; CATEGORY:
 ;	Mathemetical Function (General).
 ; CALLING SEQUENCE:
 ;	Result = SPLIN_EVAL( X, SPC [, DERIV = NDER)
 ; INPUTS:
 ;    X
 ;	Numeric, otherwise arbitrary.  The X value (or values) for which the
 ;	spline interpolation is to be performed.
 ;    SPC
 ;	An (n,3) array of spline coefficients, created by the function
 ;	SPLIN_COEEFS.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    DERIV
 ;	Integer.  If provided and nonzero, an interpolated derivative of the
 ;	order DERIV is returned.  Default value is 0.
 ; OUTPUTS:
 ;	Returns the result of the interpolation, in the same form as X.  The
 ;	type of the result is floating or higher, depending on X.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Standard Cubic spline evaluation (see Numerical Recipies, chapt. 3.3)
 ;	with the boundary condition of 0 THIRD derivative (constant end
 ;	curvature).  Uses DEFAULT and FPU_FIX from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-APR-1992 by Mati Meron.
 ;	Modified 15-MAY-1992 by Mati Meron.  Added derivative option.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     siz = size(spc)
     if siz(0) ne 2 or siz(2) ne 3 then message, 'Bad coefficient array!'
     nv = siz(1)
 
     nev = n_elements(x)
     if nev eq 1 then begin
 	loc = where(x(0) lt spc(1:nv-2,0), num)
 	if num ne 0 then l = loc(0) else l = nv - 2
 	m = 0l
     endif else begin
 	l = indgen(nv - 1)
 	m = make_array(nev, type = 3)
 	loc = where(x lt spc(1,0), num)
 	if num gt 0 then m(loc) = 0l
 	for i = 1l, nv - 3 do begin
 	    loc = where (x ge spc(i,0) and x lt spc(i+1,0), num)
 	    if num gt 0 then m(loc) = i
 	endfor
 	loc = where (x ge spc(nv-2,0), num)
 	if num gt 0 then m(loc) = nv - 2
     endelse
 
     dex = spc(l+1,0) - spc(l,0)
     dey = spc(l+1,1) - spc(l,1)
     dexsq = dex*dex
     spa = (spc(l+1,2) - spc(l,2))*dexsq
     spb = (spc(l+1,2) + 2*spc(l,2))*dexsq
     if nev gt 1 then l = m
     p = (x - spc(l,0))/dex(m)
 
     nder = Default(nder,0)
     case nder of
 	0:    res = spc(l,1) + p*(dey(m) - spb(m) + p*(spb(m) + spa(m)*(p - 1)))
 	1:    res = (dey(m) - spb(m) + p*(2*spb(m) + spa(m)*(3*p - 2)))/dex(m)
 	2:    res = 2*(spb(m) + spa(m)*(3*p - 1))/dexsq(m)
 	else:	message, 'Derivative of order ' + string(nder) +' not allowed!'
     endcase
 
     return, FPU_fix(res)
 end
 
                               *** SP_BESELJ ***                       

 Function Sp_Beselj, x, n
 
 ;+
 ; NAME:
 ;	SP_BESELJ
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates spherical Bessel functions of the first kind, j_n(x).
 ; CATEGORY:
 ;	Mathematical function.
 ; CALLING SEQUENCE:
 ;	Result = SP_BESELJ( X, N)
 ; INPUTS:
 ;    X
 ;	Numeric, otherwise arbitrary.
 ;    N
 ;	Nonnegative scalar.  Should be integer (if not then rounded downwards
 ;	to an integer on input.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the values of the spherical Bessel function j_n(x), which is
 ;	related to the standard Bessel function J by
 ;		j_n(x) = sqrt(pi/(2*x))*J_(n+1/2) (x)
 ;	The result is of the same form and type as the input (but no lower then
 ;	FLOAT.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None other than the restriction on N mentioned above.
 ; PROCEDURE:
 ;	Uses a combination of modified series expansion (for small values of X
 ;	and recursion for large X.  The transition between the two regions
 ;	occurs in the vicinity of |X| ~ N.
 ;	Warning:  for large values of N small inaccuracies may occur in the
 ;	vicinity of the transition region.  These are usually to small to be
 ;	noticed, though.
 ;	Calls CAST and ISNUM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 5-SEP-1995 by Mati Meron.
 ;	Modified 20-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     if n_elements(n) eq 0 then message, 'missing N!'
     if n lt 0 then message, 'N must be nonnegative!'
     nn = floor(n)
 
     if Isnum(x,/complex,typ=xtyp) then ztyp = 9 $
     else if Isnum(x) then ztyp = 5 $
     else message, 'Non numeric input!'
     z = Cast(x,ztyp)
     dum = machar(/double)
     eps = sqrt(dum.xmin)
 
     zetem = where(abs(z) le eps, zenum)
     nztem = where(abs(z) gt eps, nznum)
     if nznum gt 0 then zz = z(nztem)
     res = 0*z
 
     case nn of
 	0    :	begin
 		    if zenum gt 0 then res(zetem) = Cast(1,ztyp)
 		    if nznum gt 0 then res(nztem) = sin(zz)/zz
 		end
 	1    :	begin
 		    if zenum gt 0 then res(zetem) = Cast(0,ztyp)
 		    if nznum gt 0 then res(nztem) = (sin(zz) - zz*cos(zz))/zz^2
 		end
 	else :	begin
 		    eps = 0.895*nn*(4*sqrt(dum.eps)/nn)^(1./(nn+2))
 		    zetem = where(abs(z) le eps, zenum)
 		    nztem = where(abs(z) gt eps, nznum)
 		    if zenum gt 0 then begin
 			zz = z(zetem)
 			res(zetem) = 1d
 			for i = 1l, nn do res(zetem) = res(zetem)*zz/(2*i + 1)
 			zzs = zz^2/(4*nn + 6)
 			res(zetem) = res(zetem)*exp(-zzs*(1d + zzs/(2*nn +5)))
 		    endif
 		    if nznum gt 0 then begin
 			zz = z(nztem)
 			w2 = 0d*zz
 			w1 = w2 + 1
 			for i = nn-1, 1, -1 do begin
 			    w0 = ((2*i + 1)*w1 - zz*w2)/zz
 			    w2 = w1
 			    w1 = w0
 			endfor
 			j0 = sin(zz)/zz
 			j1 = (sin(zz) - zz*cos(zz))/zz^2
 			res(nztem) = w1*j1 - w2*j0
 		    endif
 		end
     endcase
 
     return, Cast(res,4,xtyp,/fix)
 end
 
                               *** SP_BESELY ***                       

 Function Sp_Besely, x, n
 
 ;+
 ; NAME:
 ;	SP_BESELY
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates spherical Bessel functions of the first kind, y_n(x).
 ; CATEGORY:
 ;	Mathematical function.
 ; CALLING SEQUENCE:
 ;	Result = SP_BESELY( X, N)
 ; INPUTS:
 ;    X
 ;	Numeric, otherwise arbitrary.
 ;    N
 ;	Nonnegative scalar.  Should be integer (if not then rounded downwards
 ;	to an integer on input.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the values of the spherical Bessel function y_n(x), which is
 ;	related to the standard Bessel function Y by
 ;		y_n(x) = sqrt(pi/(2*x))*Y_(n+1/2) (x)
 ;	The result is of the same form and type as the input (but no lower then
 ;	FLOAT.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None other than the restriction on N mentioned above.
 ; PROCEDURE:
 ;	Recursion, using calculated values of y_0 and y_1.
 ;	Calls CAST and ISNUM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 5-SEP-1995 by Mati Meron.
 ;	Modified 20-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     if n_elements(n) eq 0 then message, 'missing N!'
     if n lt 0 then message, 'N must be nonnegative!'
     nn = floor(n)
 
     if Isnum(x,/complex,typ=xtyp) then ztyp = 9 $
     else if Isnum(x) then ztyp = 5 $
     else message, 'Non numeric input!'
     z = Cast(x,ztyp)
 
     case nn of
 	0    :	res = -cos(z)/z
 	1    :	res = -(cos(z) + z*sin(z))/z^2
 	else :	begin
 		    w2 = 0d*z
 		    w1 = w2 + 1
 		    for i = nn-1, 1, -1 do begin
 			w0 = ((2*i + 1)*w1 - z*w2)/z
 			w2 = w1
 			w1 = w0
 		    endfor
 		    y0 = -cos(z)/z
 		    y1 = -(cos(z) + z*sin(z))/z^2
 		    res = w1*y1 - w2*y0
 		end
     endcase
 
     return, Cast(res,4,xtyp,/fix)
 end
 
                                 *** SQUARE ***                          

 Pro Square, base = bas, height = hei, side = sid, $
     ll_corner = llc, lr_corner = lrc, ur_corner = urc, ul_corner = ulc, $
     wiggle = wig, fill = fil, device = dev, normal = nor, $
     no_show = nsh, shapeout = shap, _extra = _e
 
 ;+
 ; NAME:
 ;	SQUARE
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ; 	Draws a SQUARE, based on a length of a side and a given location of a
 ;	corner.  The square is drawn so as to appear visually as a square, even
 ;	if the lengths of the sides in DATA coordinates differ.  The drawing is
 ;	done in the currently defined plot area.  Alternatively, a *SHAPE*
 ;	representation (see SHAPE_VER for definition) of the square may be
 ;	returned through the SHAPEOUT keyword. DATA coordinates are used unless
 ;	one of the keywords /DEVICE or /NORMAL is set.
 ; CATEGORY:
 ;	General Graphics.
 ; CALLING SEQUENCE:
 ;	Square, {BASE = BAS, HEIGHT = HEI, SIDE = SID}, $
 ;	{LL_CORNER = LLC, LR_CORNER = LRC, UR_CORNER = URC, UL_CORNER = ULC}, $
 ;	[optional keywords]
 ; INPUTS:
 ;	None.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None
 ; KEYWORD PARAMETERS:
 ;    BASE						|
 ;	Length of side, measured in the X-direction.	| One
 ;    SIDE						| and only one
 ;	Same as BASE.					| must be
 ;    HEIGHT						| provided
 ;	Length of side, measured in the Y-direction.	|
 ;
 ;    LL_CORNER						   |
 ;	2dim vector, coordinates of the lower left corner. |
 ;    LR_CORNER						   | One
 ;	2dim vector, coordinates of the lower right corner.| and only one
 ;    UR_CORNER						   | must be
 ;	2dim vector, coordinates of the upper right corner.| provided
 ;    UL_CORNER						   |
 ;	2dim vector, coordinates of the upper left corner. |
 ;
 ;    WIGGLE
 ;       Optional.  Allows to change the sides of the square from straight to
 ;	sinusoidal lines.  Can be given as scalar, 2D or 3D vector.  The first
 ;	parameter (mandatory) is number of periods, the second and third
 ;	(optional) are amplitude and phase, respectively (see the routine
 ;	WIGGLINE for explanation).  Number of periods is always rounded to
 ;	nearest integer or half integer and the phase is rounded to 0 or half
 ;	period.  Default for amplitude is 1, for phase is 0.
 ;    /FILL
 ;	Switch.  Causes the square to be filled with a solid pattern.
 ;    /DEVICE
 ;	Standard IDL plotting interpretation.
 ;    /NORMAL
 ;	Ditto.
 ;    /NO_SHOW
 ;	Switch.  If set, no plotting is done, but the shape is generated and
 ;	may be returned through SHAPEOUT.
 ;    SHAPEOUT
 ;	Optional output, see below.
 ;    _EXTRA
 ;	A formal keyword used to pass all plotting keywords.  Not to be used
 ;	directly.
 ; OUTPUTS:
 ;	None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    SHAPEOUT
 ;	When provided with the name of a variable, on return the variable
 ;	contains the *SHAPE* representation of the square.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;       SQUARE passes the extra keywords through _EXTRA, without checking.
 ;	Therefore, some care must be exercised.
 ; PROCEDURE:
 ;	Uses calls to COO_CONV, ONE_OF and SHAPE_COCON from MIDL.  Converts all
 ;	parameters to device coordinates and calls RECTAN (also from MIDL) to
 ;	do the actual plotting.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Modified 15-DEC-1993 by Mati Meron.  Now SQUARE takes advantage of the
 ;	keyword inheritance property and accepts all IDL plotting keywords.
 ;	Modified 25-JUL-1999 by Mati Meron.  Added keywords NO_SHOW and
 ;	SHAPEOUT.
 ;	Modified 20-SEP-1999 by Mati Meron.  Added possibility of wiggly
 ;	borders, through the keyword WIGGLE.
 ;-
 
     on_error, 1
     dnum = One_of(bas,hei,sid,  value = psid) mod 2
     if dnum eq -1 then message, 'Either base or height must be provided!'
     cnum = One_of(llc,lrc,urc, ulc, value = corner)
     if cnum eq -1 then message, 'One corner must be provided!'
 
     posib = ['DATA', 'DEVICE', 'NORMAL']
     sor = posib(1 + One_of(dev,nor))
 
     tem = [corner(dnum),corner(dnum) + psid]
     if (cnum - dnum) eq 1 or (cnum - dnum) eq 2 then tem = tem - psid
     tem = Coo_conv(tem, axis = dnum, from = sor, to = 'DEVICE')
     psid = tem(1) - tem(0)
 
     x = Coo_conv(corner(0), axis = 'X', from = sor, to = 'DEVICE')
     y = Coo_conv(corner(1), axis = 'Y', from = sor, to = 'DEVICE')
     xlims = [x, x + psid]
     ylims = [y, y + psid]
     if cnum eq 1 or cnum eq 2 then xlims = xlims - psid
     if cnum eq 2 or cnum eq 3 then ylims = ylims - psid
 
     Rectan, xlims = xlims, ylims = ylims, xwiggle = wig, ywiggle = wig, $
     /device, fill = fil, no_show = nsh, shapeout = shap, _extra = _e
 
     shap = Shape_cocon(temporary(shap),from = 'DEVICE', to = sor)
 
     return
 end
 
                                *** SQUNEXP ***                         

 Function Squnexp, x, n
 
 ;+
 ; NAME:
 ;	SQUNEXP
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates a "flattened" exponent.  See definition below.
 ; CATEGORY:
 ;	Mathematical function.
 ; CALLING SEQUENCE:
 ;	Result = SQUNEXP( X, N)
 ; INPUTS:
 ;    X
 ;	Numeric, otherwise arbitrary.  However, negative inputs may create
 ;	overflows and/or divergences.
 ;    N
 ;	Nonnegative scalar.  Should be integer (if not then rounded downwards
 ;	to an integer on input.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the values of a "flattened negative exponent, defined by
 ;
 ;	SQUNEXP(X,N) = exp(-X)*sum_(0 to N)(X^K)/K!
 ;
 ;	The result is of the same form and type as the input (but no lower then
 ;	FLOAT.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None other than the restriction on N mentioned above.
 ; PROCEDURE:
 ;	Clenshaw recursion with renormalization.
 ;	Calls CAST and ISNUM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 25-OCT-1995 by Mati Meron.
 ;	Modified 15-SEP-1998 by Mati Meron.  UNderflow filtering added.
 ;-
 
     on_error, 1
     if n_elements(n) eq 0 then message, 'missing N!'
     if n lt 0 then message, 'N must be nonnegative!'
     nn = floor(n)
 
     if Isnum(x, /complex, type = xtyp) then ztyp = 9 else ztyp = 5
     z = Cast(x,ztyp)
 
     case nn of
 	0    :	res = exp(-z)
 	1    :	res = exp(-z + alog(1 + z))
 	else :	begin
 		    lf = -z + alog(1 + z)
 		    w2 = 0
 		    for i = nn-1, 1, -1 do begin
 			w0 = 1 + z/(i + 1) - z/(i + 2)*w2
 			lf = lf + alog(w0)
 			w2 = 1/w0
 		    endfor
 		    res = (1 - 0.5*w2*z/(1 + z))*exp(lf)
 		end
     endcase
 
     return, Cast(res,4,xtyp,/fix)
 end
 
                                *** SQUNORM ***                         

 Function Squnorm, x, n
 
 ;+
 ; NAME:
 ;	SQUNORM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Calculates a "flattened" Gaussian.  See definition below.
 ; CATEGORY:
 ;	Mathematical function.
 ; CALLING SEQUENCE:
 ;	Result = SQUNORM( X, N)
 ; INPUTS:
 ;    X
 ;	Numeric, otherwise arbitrary.  However, negative inputs may create
 ;	overflows and/or divergences.
 ;    N
 ;	Nonnegative scalar.  Should be integer (if not then rounded downwards
 ;	to an integer on input.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the values of a "flattened" Gaussian, defined by
 ;
 ;	SQUNORM(X,N) = C*exp(-X^2/(2*D^2))*sum_(0 to N)((X^2/(2*D^2))^K)/K!
 ;
 ;	Where the constants C, D, given by:
 ;
 ;	C = sqrt((2*N+3)/(6*PI))*2^(2*N)*(N!)^2/(2*N+1)!
 ;
 ;	D = sqrt(3/(2*N+3))
 ;
 ;	are chosen so as to make the integral and the variance of the function
 ;	equal 1 (especially for N=0 the standard Normal distribution is
 ;	obtained).
 ;
 ;	The result is of the same form and type as the input (but no lower then
 ;	FLOAT.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None other than the restriction on N mentioned above.
 ; PROCEDURE:
 ;	Calculates the mormalization constants and calls SQUNEXP.  Also calls
 ;	CAST, DEFAULT and TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 25-OCT-1995 by Mati Meron.
 ;	Modified 15-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     typ = Type(x)
     n = Default(n,0l,/dtype)
     ecoef = n/3d + 0.5d
     coef = sqrt(ecoef/!dpi)
     for i = 1l, n do coef = coef/(1d + 0.5d/i)
 
     return, Cast(coef*Squnexp(ecoef*x^2,n),4,typ,/fix)
 end
 
                                 *** STREQ ***                           

 Function Streq, str1, str2, len, caseon = cas, warn = wn
 
 ;+
 ; NAME:
 ;	STREQ
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Compares for equality the first LEN characters of STR1, STR2.
 ;	If LEN is 0, or absent, the whole strings are compared.
 ; CATEGORY:
 ;	String Processing.
 ; CALLING SEQUENCE:
 ;	Result = STREQ( STR1, STR2 [,LEN] [, keywords])
 ; INPUTS:
 ;    STR1, STR2
 ;	character strings, mandatory.
 ; OPTIONAL INPUT PARAMETERS:
 ;    LEN
 ;	Number of characters to compare.  Default is 0, translating to a full
 ;	comparison.
 ; KEYWORD PARAMETERS:
 ;    /CASEON
 ;	Switch. If set the comparison is case sensitive. Default is ignore case.
 ;    /WARN
 ;	Switch.  If set, a warning is issued whenever STR1 or STR2 is not a
 ;	character variable.  Default is no warning.
 ; OUTPUTS:
 ;	1b for equal, 0b for nonequal.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Using DEFAULT and TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;-
 
     if Type(str1) ne 7 or Type(str2) ne 7 then begin
 	if keyword_set(wn) then message, 'Not a string!', /continue
 	return, 0b
     endif
 
     dlen = Default(len,0l,/dtype)
     if dlen eq 0 then dlen = max([strlen(str1),strlen(str2)])
     if not keyword_set(cas) then begin
 	dum1 = strupcase(str1)
 	dum2 = strupcase(str2)
     endif else begin
 	dum1 = str1
 	dum2 = str2
     endelse
 
     return, strmid(dum1,0,dlen) eq strmid(dum2,0,dlen)
 end
 
                                *** STRMATCH ***                        

 Function StrMatch, str, list, len, caseon = cas, all = all, exclude = exl
 
 ;+
 ; NAME:
 ;	STRMATCH
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Compares the string STR with the strings in the array LIST.  Comparison
 ;	is done for the first LEN characters, or all of them if LEN is 0.  If a
 ;	 match is found, STR is replaced by the full string from the list (or
 ;	if the keyword /ALL is set, by an array containing all the matching
 ;	strings).
 ; CATEGORY:
 ;	String Processing.
 ;	Obsolete.  Replaced by STRMATCH_MM.
 ; PROCEDURE:
 ;	Calls OBSTAT and STRMATCH_MM from MIDL.  See STRMATCH_MM for details.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Modified 20-NOV-1993 by Mati Meron.  Added keyword ALL.
 ;	Modified 11-OCT-1997 by Roger J. Dejus.  Added keyword EXCLUDE.
 ;	Replaced by STRMATCH_MM on 30-SEP-1999.
 ;-
 
     Obstat
 
     return, StrMatch_mm(str, list, len, caseon = cas, all = all, exclude = exl)
 end
 
                              *** STRMATCH_MM ***                     

 Function StrMatch_mm, str, list, len, caseon = cas, all = all, exclude = exl
 
 ;+
 ; NAME:
 ;	STRMATCH_MM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Compares the string STR with the strings in the array LIST.  Comparison
 ;	is done for the first LEN characters, or all of them if LEN is 0.  If a
 ;	 match is found, STR is replaced by the full string from the list (or
 ;	if the keyword /ALL is set, by an array containing all the matching
 ;	strings).
 ; CATEGORY:
 ;	String Processing.
 ; CALLING SEQUENCE:
 ;	Result = STRMATCH_MM( STR, LIST [, LEN] [, keywords])
 ; INPUTS:
 ;    STR
 ;	Character string.
 ;    LIST
 ;	Character array.
 ; OPTIONAL INPUT PARAMETERS:
 ;    LEN
 ;	The number of characters to compare.  Default is full comparison.
 ; KEYWORD PARAMETERS:
 ;    /CASEON
 ;	Switch. If set the comparison is case sensitive. Default is ignore case.
 ;    /ALL
 ;	Switch.  If set, returns the indices of all the matching elements.
 ;    /EXCLUDE
 ;	Switch.  If set returns the indices of all the non-matching elements.
 ; OUTPUTS:
 ;	Returns the index of the first match, or -1l if no match is found.
 ;	Optionally (see keyword ALL above) returns all the matching indices,
 ;	or non-matching indices when the keyword EXCLUDE is set.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None other then the substitution in STR.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses the function STREQ from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron, as STRMATCH.
 ;	Modified 20-NOV-1993 by Mati Meron.  Added keyword ALL.
 ;	Modified 11-OCT-1997 by Roger J. Dejus.  Added keyword EXCLUDE.
 ;	Renamed 25-SEP-1999 to STRMATCH_MM in order to avoid naming conflicts
 ;	with RSI routines.
 ;-
 
     if keyword_set(exl) then $
 	match = where(Streq(str,list,len,caseon = cas) eq 0, nmatch) else $
 	match = where(Streq(str,list,len,caseon = cas), nmatch)
     if not keyword_set(all) then match = match(0)
     if nmatch gt 0 then str = list(match)
 
     return, match
 end
 
                                *** STRPARSE ***                        

 Function StrParse, line, delim, list
 
 ;+
 ; NAME:
 ;	STRPARSE
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Parses the string LINE using the characters in DELIM as delimiters.
 ;	Puts individual pieces into consecutive locations in LIST.
 ; CATEGORY:
 ;	String Processing.
 ;	Obsolete.  Replaced by STRPARSE_MM.
 ; PROCEDURE:
 ;	Calls OBSTAT and STRPARSE_MM from MIDL.  See STRPARSE_MM for details.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;	Replaced by STRPARSE_MM on 30-SEP-1999.
 ;-
 
     Obstat
 
     return, Strparse_mm(line, delim, list)
 end
 
                              *** STRPARSE_MM ***                     

 Function StrParse_mm, line, delim, list
 
 ;+
 ; NAME:
 ;	STRPARSE_MM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Parses the string LINE using the characters in DELIM as delimiters.
 ;	Puts individual pieces into consecutive locations in LIST.
 ; CATEGORY:
 ;	String Processing.
 ; CALLING SEQUENCE:
 ;	Result = STRPARSE_MM( LINE, DELIM [, LIST])
 ; INPUTS:
 ;    LINE
 ;	Character string.
 ;    DELIM
 ;	Character string.  Each Character of DELIM is used as a delimiter.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the number of pieces found minus one i.e. the index of the last
 ;	element of LIST if LIST is provided.  If LINE is a null string or not a
 ;	string, the function returns -1l.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    LIST
 ;	Character array.  If name is provided, the pieces of LINE resulting
 ;	from the parsing process are returned in consecutive locations in LIST.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Using the function TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron as STRPARSE.
 ;	Renamed 25-SEP-1999 to STRPARSE_MM in order to avoid naming conflicts
 ;	with RSI routines.
 ;-
 
     if Type(line) ne 7 then return, -1l
     index = -1l
     list = ''
     len = strlen(line)
     for i = 0l, len - 1 do begin
 	if strpos(delim,strmid(line,i,1)) ne -1 then index = [index,i]
     endfor
     index = [index,len]
     for i = 0l, n_elements(index) - 2 do begin
 	list = [list,strmid(line,index(i) + 1,index(i+1) - index(i) -1)]
     endfor
     inlist = where(list ne '',items)
     if items ne 0 then list = list(inlist) else list = list([0])
 
     return, long(items - 1)
 end
 
                                *** TABULATE ***                        

 Pro Tabulate, a, b, c, d, e, f, g, h, index = ind, from = fro, to = to, $
     title = tit, header = ehed, noheader = nhed, format = efor, realform = rf, $
     IDF_off = idf, more = mor, file = fnam
 
 ;+
 ; NAME:
 ;	TABULATE
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Accepts data in form of a set (up to 8) one dimensional arrays and
 ;	prints it out as a table.
 ; CATEGORY:
 ;	Input/Output.
 ; CALLING SEQUENCE:
 ;	TABULATE, A [,B ....H] [,keywords]
 ; INPUTS:
 ;    A [B ... H]
 ;	One or more (up to 8) one dimensional arrays.  Type arbitrary
 ;	(including string arrays).  If the array lengths are not all equal, the
 ;	shortest length will be used.
 ; OPTIONAL INPUT PARAMETERS:
 ;	All but the first array are arbitrary.
 ; KEYWORD PARAMETERS:
 ;    /INDEX
 ;	If set, the elements indices (0, 1 ... etc.) are printed in the first
 ;	column of the table.  Set by default if only one column is provided.
 ;    FROM
 ;	Specifies the index of the first element to be displayed.  Default is 0.
 ;    TO
 ;	Specifies the index of the last element to be displayed.  Default is
 ;	end of array.
 ;    TITLE
 ;	Character string, used as the title of the table.  Default is no title.
 ;    HEADER
 ;	Character array containing the titles of the columns.  Default titles
 ;	are the letters A thru H.  The title of the index column, if it appears
 ;	is N and cannot be changed.  If some of the entries in HEADER are null
 ;	strings, the default headers will be used for the corresponding columns.
 ;    /NOHEADER
 ;	Switch.  If set, no header is printed.  If HEADER is provided and
 ;	NOHEADER is set, HEADER will be ignored.
 ;    FORMAT
 ;	Character array, containing format specifications for the columns.  The
 ;	default formats are as follows:
 ;	    BYTE		- I4
 ;	    INTEGER		- I8
 ;	    LONG		- I12
 ;	    FLOATING		- G13.6
 ;	    DOUBLE		- G16.8
 ;	    COMPLEX		- G13.6  (twice)
 ;	    STRING		- A16
 ;	    DOUBLECOMPLEX 	- G16.8  (twice)
 ;	If some of the entries in FORMAT are null strings, defaults will be
 ;	used for the corresponding columns.  If only partial formats are given
 ;	(for example 'E', or '16.6') missing fields are filled from the
 ;	default.  Valid formats are A, D, E, F, G, I, O, Z.  Nonvalid formats
 ;	are ignored.
 ;	Important:  TABULATE may change the formats (either defaults or
 ;	provided explicitly through FORMAT) in order to make enough room in the
 ;	display.
 ;    REALFORM
 ;	Character string (only first letter matters).  If given and is one of
 ;	D, E, F or G, provides the default format for all the real, double and
 ;	complex data.  If not given, the default is G format.
 ;    /IDF_OFF
 ;	Switch.  In normal operation formats I, D and F (if present) are
 ;	adjusted to the sizes of numbers displayed.  /IDF_OFF, when set, turns
 ;	off this adjustment.
 ;    FILE
 ;	String representing a valid file name (if extension is not provided the
 ;	default is .TAB).  If provided, the output is sent to this file,
 ;	otherwise it is sent to the terminal.
 ;    /MORE
 ;	Sends output to the screen one page at a time (like UNIX MORE).
 ; OUTPUTS:
 ;	None, other then the printed table.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	TABULATE may reduce the widths of the print fields in order to
 ;	accomodate all the data.  If after reduction to minimum widths the data
 ;	still cannot be fitted, no table will be generated.
 ;	While in theory TABULATE can display up to 8 columns, the actual number
 ;	depends on the data types and magnitudes.  Approximate maximal numbers
 ;	of columns are:
 ;	    BYTE, INTEGER
 ;	    or STRING		- 8 columns (strings may be truncated)
 ;	    LONG		- 6-8 columns (depends on size)
 ;	    FLOAT		- 8 columns in E/G format.  Size dependent in F.
 ;	    DOUBLE		- 8 columns in E/G format.  Size dependent in F.
 ;	    COMPLEX		- 4 columns in E/G format.  Size dependent in F.
 ;	    DOUBLECOMPLEX	- 4 columns in E/G format.  Size dependent in F.
 ;
 ;	Beginning with the SEP-1997 version, undefined columns are ignored
 ;	instead of being flagged as an error.  If there are defined columns
 ;	following an undefined one, they'll be ignored as well.
 ; PROCEDURE:
 ;	Straightforward.  Uses ABS_MM, DEFAULT, STREQ, STRPARSE_MM and TYPE
 ;	from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 3-MAY-1992 by Mati Meron.
 ;	Modified 20-JUN-1995 by Mati Meron to accept the new DOUBLECOMPLEX type.
 ;	Modified 30-MAY-1996 by Mati Meron.  Added keyword NOHEADER.
 ;	Modified 20-JUL-1997 by Mati Meron.  Adjusted format handling.
 ;	Modified 20-SEP-1997 by Mati Meron.  Ability to ignore undefined
 ;	columns added.
 ;	Modified 15-NOV-1997 by Mati Meron.  Formats adjusted to IDL standards
 ;	and correction for the errant behavior of G format added.
 ;	Modified 20-SEP-1998 by Mati Meron.  TABULATE now accepts multiline
 ;	titles.  Also, repeated formats, such as '3i' or '5e12.4' are now
 ;	recognized.  Enclosing formats in parentheses is legal but not needed.
 ;-
 
     on_error, 1
 
     fdef = [ '','I','I','I','G','G','G','A','NA','G']
     wdef = [ -1,  4,  8, 12, 13, 16, 13, 16, -1 , 16]
     ddef = [ -1, -1, -1, -1,  6,  8,  6, -1, -1 ,  8]
     wmin = [ -1,  3,  4,  4,  7,  7,  7,  4, -1 ,  7]
     compa = 'ADEFGIOZ'
     compn = '0123456789'
     compr = 'DEFG'
     ncomax = 8
     linlen = 80
     linum = 22
     ulin = 95b
     cnams = ['N', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
 
     filfl = Type(fnam) eq 7
     nco = (n_params() < ncomax)
     if nco eq 0 then message, 'No data!'
     infl = keyword_set(ind)
     cf = 1 - infl
     nco = nco + infl
     cinf = intarr(nco)
     for i = infl, nco - 1 do begin
 	id = execute('cinf(i)=n_elements('+cnams(i+cf)+')')
 	if cinf(i) eq 0 then nco = nco < i
     endfor
     if nco eq infl then message, 'No data!'
     cinf = cinf(0:nco-1)
 
     nro = min(cinf(infl:*), max = nrox)
     if nro ne nrox then message, 'Incompatible lengths, truncating data!',/con
     if infl then if nro le 2^15-1 then n = indgen(nro) else n = lindgen(nro)
     for i = 0, nco - 1 do id = execute('cinf(i) = Type(' + cnams(i+cf) + ')')
     if (where(cinf eq 8))(0) ge 0 then message, 'Structures not allowed!'
     cxin = intarr(nco)
     cxco = where(cinf eq 6 or cinf eq 9, cxfl)
     cxfl = cxfl gt 0
     if cxfl then cxin(cxco) = 1
 
     if n_elements(rf) ne 0 then begin
 	rfor = strupcase(strmid(strcompress(rf,/remove_all),0,1))
 	if strpos(compr,rfor) ne -1 then fdef([4,5,6,9]) = rfor $
 	else message, 'Default format ' +rfor+ ' not acceptable, ignored!',/con
     endif
     pf = fdef(cinf)
     pw = wdef(cinf)
     pd = ddef(cinf)
 
     nefor = n_elements(efor)
     if nefor ne 0 then begin
 	cfor = strupcase(strcompress(efor,/remove_all))
 	tfor = ''
 	for i = 0, nefor - 1 do begin
 	    sdum = Strparse_mm(cfor(i),'()',lis)
 	    ftem = lis(0)
 	    sdum = Strparse_mm(ftem,'.' + compn,lis)
 	    fpos = strpos(ftem,lis(0))
 	    frep = fix(strmid(ftem,0,fpos)) > 1
 	    sfor = strmid(ftem,fpos,strlen(ftem))
 	    tfor = [tfor,replicate(sfor,frep)]
 	endfor
 	if not infl then tfor = tfor(1:*)
 	nefor = n_elements(tfor) < nco
 	for i = 0, nefor - 1 do begin
 	    ftem = strmid(tfor(i),0,1)
 	    if ftem ne '' and strpos(compa + compn,ftem) ne -1 then begin
 		roff = 0
 		if strpos(compa,ftem) ne -1 then begin
 		    if cinf(i) ne 7 then pf(i) = ftem
 		    roff = 1
 		endif
 		nfields = Strparse_mm(strmid(tfor(i),roff,6),'.',fields)
 		if nfields ge 0 then pw(i) = fix(fields(0))
 		if strpos(compr,pf(i)) eq -1 then pd(i) = -1 else $
 	 	if nfields eq 1 then pd(i) = fix(fields(1)) > 0
 	    endif else if ftem ne '' then $
 	    message, 'Format ' + ftem + ' not acceptable, ignored!', /con
 	endfor
     endif
 
     fwm = intarr(nco)
     if filfl or not keyword_set(idf) then begin
 	com = ['fwm(dum(i))=floor(alog10(max(Abs_mm(' , '))>1))']
 	dum = where(pf eq 'I', nd)
 	for i = 0, nd - 1 do id = execute(com(0)+cnams(dum(i)+cf)+com(1)+'+2')
 	dum = where(pf eq 'D' or pf eq 'F', nd)
 	for i = 0, nd - 1 do id = execute(com(0)+cnams(dum(i)+cf)+com(1)+'+3')
     endif
     pwm = fwm > wmin(cinf)
 
     gap = replicate(4,nco)
     gap(0) = 0
     if nco gt 1 then begin
 	dum = where(pf eq 'G' and gap ne 0 and cxin eq 0, nd)
 	if nd ne 0 then gap(dum) = gap(dum) - 1
     endif else nd = 0
     netlin = linlen - nco + 1 + nd
 
     cow = pw > pwm
     mcow = pwm
     if cxfl then begin
 	cow(cxco) = 2*(cow(cxco) + 2)
 	mcow(cxco) = 2*(mcow(cxco) + 2)
     endif
     if fix(total(mcow)) le netlin then begin
 	excess = fix(total(cow)) - netlin
 	while excess gt 0 do begin
 	    dum = where(cinf eq 7, nd)
 	    if nd ne 0 then begin
 		if (excess - fix(total(cow(dum) - mcow(dum)))) le 0 then begin
 		    while excess gt 0 do begin
 			cow(dum) = (cow(dum) - (excess/nd > 1)) > mcow(dum)
 			excess = fix(total(cow)) - netlin
 		    endwhile
 		endif else begin
 		    cow(dum) = mcow(dum)
 		    excess = fix(total(cow)) - netlin
 		endelse
 	    endif
 	    while excess gt 0 do begin
 		dum = where(cow gt mcow and cxin eq 0, nd)
 		ddum = where(cow gt mcow and cxin ne 0, ndd)
 		sub = excess/(nd + 2*ndd) > 1
 		if nd gt 0 then cow(dum) = (cow(dum) - sub) > mcow(dum)
 		if ndd gt 0 then cow(ddum) = (cow(ddum) - 2*sub) > mcow(ddum)
 		excess = fix(total(cow)) - netlin
 	    endwhile
 	endwhile
 	mcow = cow
     endif else message, 'Too much stuff, can''t display!'
 
     dohed = not(keyword_set(nhed))
     nehed = n_elements(ehed)
     if not (dohed or nehed eq 0) then message, 'External header ignored!', /con
     if dohed then begin
 	hed = cnams(cf:nco-infl)
 	if nehed ne 0 then begin
 	    dum = where(ehed(0:(nehed < (nco-infl)) - 1) ne '',nd)
 	    if nd ne 0 then hed(dum + infl) = ehed(dum)
 	endif
 	cow = fix(cow > strlen(hed))
     endif
     excess = fix(total(cow)) - netlin
     while excess gt 0 do begin
 	dum = where(cow gt mcow, nd)
 	cow(dum) = (cow(dum) - (excess/nd > 1)) > mcow(dum)
 	excess = fix(total(cow)) - netlin
     endwhile
 
     pw = cow
     if cxfl then pw(cxco) = pw(cxco)/2 - 2
     dum = where(pf eq 'D' or pf eq 'F', nd)
     if nd gt 0 then pd(dum) = 0 > pd(dum) < (pw(dum) - (3 > fwm(dum)))
     dum = where(pf eq 'E' or pf eq 'G', nd)
     if nd gt 0 then pd(dum) = 0 > pd(dum) < (pw(dum) - 7)
 
     repeat begin
 	plen = fix(total(cow + gap))
 	if plen gt linlen then gap = (gap - 1) > 0
     endrep until plen le linlen
     pg = strarr(nco)
     dum = where(gap gt 0,nd)
     if nd ne 0 then pg(dum) = strtrim(string(gap(dum)),2) + 'X,'
 
     pplen = (plen + 2) < linlen
     tlen = max(strlen(Default(tit,'',/dtype))) < linlen
     ttlen = (tlen + 2) < linlen
 
     pwd = string(pw)
     dum = where(pd ge 0, nd)
     if nd ne 0 then pwd(dum) = pwd(dum) + '.' + string(pd(dum))
     pwd = strcompress(pwd,/remove_all)
     for i = 0, nco - 1 do begin
 	pf(i) = pf(i) + pwd(i)
 	if cxin(i) then pf(i) ='"(",'+ pf(i) + ',", ",' + pf(i) + ',")"'
     endfor
     pf = pg + pf
 
     fro = Default(fro,0l,/dtype) < (nro - 1)
     to = Default(to, nro - 1l,/dtype) > fro
     tabl = strarr(to - fro + 1)
     tfro = 0l
     repeat begin
 	tto = (tfro + 255) < (to - fro)
 	for i = 0, nco - 1 do $
 	id = execute("tabl(tfro:tto) = tabl(tfro:tto) + string(" $
 	+ cnams(i+cf) + "(tfro+fro:tto+fro), format = '(' + pf(i) + ')')")
 	tfro = tto + 1
     endrep until tto eq (to - fro)
     tabh = strarr(3)
     hf = pg + strcompress('A' + string(cow),/remove_all)
     if dohed then begin
 	for i = 0, nco - 1 do begin
 	    tabh(0) = tabh(0) + string(hed(i), format = '(' + hf(i) + ')')
 	    shed = string(replicate(ulin,cow(i)))
 	    tabh(1) = tabh(1) + string(shed, format = '(' + hf(i) + ')')
 	endfor
 	tabl = [tabh, tabl]
     endif
     if ttlen gt pplen then tabl = tabl + string(replicate(32b,ttlen - pplen))
     if tlen ne 0 then begin
 	titfor = 'A' +  strcompress(string(tlen),/remove_all)
 	tabh = string(tit + string(replicate(32b,tlen)),form='('+titfor+')')
 	pad = (plen - tlen + 1)/2 > 0
 	titfor = 'A' +  strcompress(string((ttlen > pplen) - pad),/remove_all)
 	tabh= string([tabh,string(replicate(ulin,tlen)),''],form='('+titfor+')')
 	if pad gt 0 then tabh = tabh + string(replicate(32b, pad))
 	tabl = [tabh, tabl]
     endif
 
     tabfor = strcompress('A' + string(pplen > ttlen), /remove_all)
     if filfl then begin
 	if Streq(!version.os,'vms',3) then begin
 	    openw, unit, fnam, default = '.tab', /get_lun
 	endif else openw, unit, fnam, /get_lun
 	printf, unit, tabl, format = '(' + tabfor + ')'
 	free_lun, unit
     endif else begin
 	if keyword_set(mor) then begin
 	    clear_screen
 	    rout = n_elements(tabl) - 1
 	    i = 0
 	    j = 0
 	    while j lt rout do begin
 		j = (i + linum) < rout
 		print, tabl(i:j), format = '(' + tabfor + ')'
 		i = j + 1
 		if j ne rout then hak
 	    endwhile
 	endif else print, tabl, format = '(' + tabfor + ')'
     endelse
 
     return
 end
 
                                  *** TAIL ***                            

 Pro Tail, a, b, c, d, e, f, g, h, nr = nr, nc = nc, row = ro, column = co, $
     transpose = trn, show_index = shin, nowrap = now, format = efor, _extra = _e
 
 ;+
 ; NAME:
 ;	TAIL
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Displays the ending ("tail") or, optionally, a selected part of an
 ;	1-2D array.
 ; CATEGORY:
 ;	Input/Output.
 ; CALLING SEQUENCE:
 ;	TAIL, A [,B ...H] [,keywords]
 ; INPUTS:
 ;    A [,B ...H]
 ;	One or more arrays, of arbitrary type.  If more than one array is
 ;	provided, all the arrays have to be 1D.  A single array can have 1 or
 ;	2 dimensions, but no more than 2.
 ; OPTIONAL INPUT PARAMETERS:
 ;	All but the first input are optional.
 ; KEYWORD PARAMETERS:
 ;    NR
 ;	The number of rows to be displayed.  Default value is 10 (except for
 ;	the case of a single 1D array in wrapping mode (see keyword NO_WRAP,
 ;	below), when it is 12).  If explicit values for the starting and ending
 ;	row numbers are provided through the keyword ROW (see below), NR is
 ;	ignored.
 ;    NC
 ;	Same as NR, for columns.  Default value is 6, maximal value is 8.
 ;	In the case of a single 1D array in wrapping mode, NC is
 ;	interchangeable with NR and, if both are provided, NC is ignored.
 ;    ROW
 ;	Specifies the first (and possibly last) row of the displayed array
 ;	part.  For an array with N rows, the possibilities are as follows:
 ;
 ;	    1)	No value provided: display area is from row #(N - NR) (or 0 if
 ;		N - NR is negative) through row #(N - 1).
 ;	    2)	Scalar value r0:  display area is from row #r0 through row
 ;		#(r0 + NR - 1) or last row, whichever comes first.
 ;	    3)  Single vector value r0 (for example, ROW = [4]):  this is
 ;		interpreted as a vector input, ROW = [r0,r0] (see case 4 below)
 ;		and a single row (#r0) is output.
 ;	    4)	Two element vector of the form ROW = [r0,r1]:  In this case
 ;		display area is from row #r0 through row #r1.
 ;
 ;	In the case of a single 1D array in the default wrapping mode (see
 ;	keyword NO_WRAP, below), ROW is interchangeble with COLUMN and
 ;	specifies the first (and, possibly, last) element to be displayed).
 ;    COLUMN
 ;	Same as ROW, for columns of the display area.  For a 2D array the
 ;	default number of displayed columns is the smaller of 6 and the actual
 ;	number of columns in the data.  For 1D arrays COLUMN is ignored,
 ;	except for the case of a single 1D array in wrapping mode.  In this
 ;	case COLUMN is interchangeable with ROW (see above) and ignored if ROW
 ;	is provided.
 ;	Maximal possible number of displayed columns is 8.
 ;    /TRANSPOSE
 ;	Switch.  If set and the input array is 2D, the transpose of the array
 ;	is used.  Thus TAIL, A, /TRANSPOSE is equivalent to TAIL, TRANSPOSE(A).
 ;	Ignored for multiple 1D inputs.
 ;    /SHOW_INDEX
 ;	Switch.  If set, the indices of the rows and columns shown are
 ;	displayed, on the right (for rows) and top (for columns).
 ;    /NO_WRAP
 ;	Switch.  Turns off wrapping mode which is on, by default for single 1D
 ;	arrays.  In the wrapping mode the array is displayed over as many lines
 ;	as needed, same as when being displayed using the PRINT statement.  In
 ;	a non-wrapping mode only a portion of a 1D array that fits on a single
 ;	line may be displayed.  If the input consists of a 2D array or multiple
 ;	1D arrays, the wrapping mode is off.
 ;    FORMAT
 ;	Character array, containing format specifications for the columns.
 ;	If not provided, default TABULATE formats are used.  If only a single
 ;	entry provided, it'll be used for all columns.  For more details see
 ;	TABULATE.
 ;	If multiple entries are provided in the wrapping mode, only the first
 ;	one is used.
 ;    _EXTRA
 ;	A formal keyword used to pass keywords to TABULATE.  Not to be used
 ;	directly.  All TABULATE keywords are available.
 ; OUTPUTS:
 ;	None, other then the printed output.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	As mentioned above:
 ;	    1)	Arrays with more then 2 dimensions not accepted.
 ;	    2)	For 2D, only a single array is allowed.
 ;	    3)	For 1D, up to 8 arrays allowed.  They can be of different
 ;		types but must have same length.
 ;	    4)  Wrapping is only possible with a single 1D array.
 ; PROCEDURE:
 ;	TAIL serves as a front end to TABULATE.  It selects a part of the
 ;	input, based on the row and column settings, and passes it to TABULATE
 ;	which displays it.  In addition to TABULATE, TAIL calls DEFAULT,
 ;	HOW_MANY, STRPARSE_MM and TYPE from MIDL.
 ;	In the wrap mode, TAIL bypasses TABULATE and uses PRINT, directly.
 ; MODIFICATION HISTORY:
 ;	Created 1-NOV-1997 by Mati Meron.
 ;	Modified 5-OCT-1998 by Mati Meron.  Added wrap mode for 1D arrays.
 ;-
 
     on_error, 1
     nwadef = 12l
     nrodef = 10l
     ncodef = 6l
     ncomax = 8l
     wrafl = 0
     cnams = [ 'A',  'B',  'C',  'D',  'E',  'F',  'G',  'H']
     wnams = ['WA', 'WB', 'WC', 'WD', 'WE', 'WF', 'WG', 'WH']
 
     wnr = Default(nr,nrodef,/dtype)
     wnc = Default(nc,ncodef,/dtype) < ncomax
     shofl = keyword_set(shin)
 
     nco = (n_params() < ncomax)
     if nco gt 0 then begin
 	if nco eq 1 then begin
 	    tem = [a]
 	    if keyword_set(trn) then tem = transpose(tem)
 	    siz = size(tem)
 	    if siz(0) gt 2 then begin
 		tem = reform(tem)
 		siz = size(tem)
 		if siz(0) gt 2 then message, 'Dims > 2 not supported!'
 	    endif
 	    if siz(0) eq 1 then begin
 		if keyword_set(now) then begin
 		    tem = reform(tem,siz(1),1)
 		    siz = size(tem)
 		endif else wrafl = 1
 	    endif
 	    if wrafl then begin
 		nro = siz(1)
 		ndum = How_many(fir = nr,sec = nc)
 		if ndum eq 0 then wnr = nwadef else wnr = Default(nr,nc) > 0l
 		ndum = How_many(fir = ro, sec = co)
 		if ndum eq 0 then wro= (nro-wnr)> 0l else wro=Default(ro,co)> 0l
 	    endif else begin
 		wco = Default(co,siz(1)-wnc,/dtype) > 0
 		if (size(wco))(0) eq 0 then wco = [wco,wco+wnc-1] else $
 		if n_elements(wco) eq 1 then wco = [wco,wco]
 		wco = wco(0) > wco < (((wco(0) + ncomax) < siz(1)) - 1)
 		nco = wco(1) - wco(0) + 1
 		nro = siz(2)
 		for i = wco(0), wco(1) do id = $
 		execute(wnams(i-wco(0)) + ' = reform(tem(' + string(i) + ',*))')
 		if shofl then begin
 		    lfor = floor(alog10(wco(1) > 1)) + 1
 		    hfor = strcompress('(I' + string(lfor) + ')', /remove_all)
 		    head = string(wco(0) + lindgen(nco), form = hfor)
 		endif
 	    endelse
 	endif else begin
 	    idim = lonarr(nco)
 	    nro = idim
 	    for i = 0, nco - 1 do begin
 		id = execute('typ = Type(' + cnams(i) + ')')
 		if typ gt 0 then begin
 		    id = execute(wnams(i) + ' = reform([' + cnams(i) + '])')
 		    id = execute('siz = size(' + wnams(i) + ')')
 		    idim(i) = siz(0)
 		    nro(i) = siz(1)
 		endif else nco = nco < i
 	    endfor
 	    if max(idim) gt 1 then message, 'multiple arrays must be 1D!'
 	    nro = min(nro(0:nco-1), max = nrox)
 	    if nro ne nrox then message, 'Unequal column lengths!'
 	endelse
     endif else message, 'No data!'
 
     if not wrafl then wro = Default(ro,nro-wnr,/dtype) > 0l
     if (size(wro))(0) eq 0 then wro = [wro,wro+wnr-1] else $
     if n_elements(wro) eq 1 then wro = [wro,wro]
     wro = wro(0) > wro < (nro - 1)
 
     if n_elements(efor) ne 0 then begin
 	wefor = efor
 	if wrafl then begin
 	    dum = Strparse_mm(wefor(0),'()',lis)
 	    wefor = lis(0)
 	    dum = Strparse_mm(wefor,'.0123456789',lis)
 	    fpos = strpos(wefor,lis(0))
 	    if fpos eq 0 then wefor = strcompress(string(nro),/remove) + wefor
 	    wefor = '(' + wefor +')'
 	endif else if n_elements(wefor) eq 1 then wefor = replicate(wefor,nco)
     endif
 
     if wrafl then print, a(wro(0):wro(1)), form = wefor else $
     Tabulate, wa, wb, wc, wd, we, wf, wg, wh, from = wro(0), to = wro(1), $
     index = shofl, head = head, nohead = 1 - shofl, format = wefor, _extra = _e
 
     return
 end
 
                                 *** TOLER ***                           

 Function Toler, x, type = typ, double = dob
 
 ;+
 ; NAME:
 ;	TOLER
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Establishes numerical tolerance value for numerical procedures.
 ; CATEGORY:
 ;	Programming.
 ; CALLING SEQUENCE:
 ;	Result = TOLER(X [, keywords])
 ; INPUTS:
 ;    X
 ;	Numeric, otherwise arbitrary.  Ignored if one of the keywords TYPE or
 ;	DOUBLE (see below) is used.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    TYPE
 ;	Numeric type code.  If given overrides the type provided by X.
 ;    /DOUBLE
 ;	Switch.  Specifies double precision.  If given, overrides both TYPE and
 ;	the type provided by X.
 ; OUTPUTS:
 ;	Returns a value equal to twice the .EPS field of the structure created
 ;	by the IDL function MACHAR.  If the type code, as set by the type of X,
 ;	or directly by one of the keywords TYPE or DOUBLE is 5 (DOUBLE) or 9
 ;	(DOUBLECOMPLEX), MACHAR is called with the keyword /DOUBLE.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	X (when provided) must be numeric else an error occurs.  Similarly,
 ;	calling TOLER with TYPE = 8 or 9 will cause an error.
 ; PROCEDURE:
 ;	Straightforward.  Uses MACHAR.  Calls DEFAULT and TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUN-1995 by Mati Meron.
 ;	Modified 10-SEP-1998 by Mati Meron.  Added keyword /DOUBLE.
 ;-
 
     on_error, 1
     nonum = [7,8,10,11,12,13,14,15]
     if keyword_set(dob) then typ = 5 else typ = Default(typ,Type(x))
     if (where(nonum eq typ))(0) ge 0 then message, 'input must be numeric!'
     eps = Machar(double = typ eq 5 or typ eq 9)
     return, eps.eps
 end
 
                                  *** TYPE ***                            

 Function Type, x
 
 ;+
 ; NAME:
 ;	TYPE
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Finds the type class of a variable.
 ; CATEGORY:
 ;	Programming.
 ; CALLING SEQUENCE:
 ;	Result = TYPE(X)
 ; INPUTS:
 ;    X
 ;	Arbitrary, doesn't even need to be defined.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the type of X as a long integer, in the (0,9) range.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Extracts information from the SIZE function.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUL-1991 by Mati Meron.
 ;-
 
     dum = size(x)
     return, dum(dum(0) + 1)
 end
 
                                 *** UNIVEC ***                          

 Function Univec, r
 
 ;+
 ; NAME:
 ;	UNIVEC
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Normalizes a vector.
 ; CATEGORY:
 ;	Geometry, general.
 ; CALLING SEQUENCE:
 ;	Result = UNIVEC (R)
 ; INPUTS:
 ;    R
 ;	Vector, numeric, otherwise arbitrary.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns a vector in the same direction as R, normalized to unity.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	A zero vector will cause error.
 ; PROCEDURE:
 ;	Straightforward.  Uses FPU_FIX and VNORM from MIDL.
 ;	Works also with complex vectors.
 ; MODIFICATION HISTORY:
 ;	Created 30-JUN-1992 by Mati Meron.
 ;	Added to MIDL 5-NOV-1997 by Mati Meron.
 ;	Modified 10-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     rnorm = Vnorm(r)
     if rnorm eq 0 then message, 'Zero vector, cannot normalize!' $
     else return, FPU_fix(r/rnorm)
 end
 
                                  *** VINP ***                            

 Function Vinp, u, v
 
 ;+
 ; NAME:
 ;	VINP
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Finds the scalar product of two vectors.
 ; CATEGORY:
 ;	Geometry, General.
 ; CALLING SEQUENCE:
 ;	Result = VINP ( U, V)
 ; INPUTS:
 ;    U, V
 ;	Vectors, numeric, of same length, otherwise arbitrary.  Scalars
 ;	accepted as vectors of length 1.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the value of the scalar product, in Type FLOAT or higher.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	Vectors must have same length.
 ; PROCEDURE:
 ;	Straightforward.  Uses CAST, FPU_FIX and ISNUM from MIDL.
 ;	Works also with complex vectors.
 ; MODIFICATION HISTORY:
 ;	Created 30-JUN-1992 by Mati Meron.
 ;	Modified and added to MIDL on 5-NOV-1997, by Mati Meron.
 ;	Modified on 10-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     if not (Isnum(u) and Isnum(v)) then message, 'Not numeric vectors!'
 
     ru = Cast(reform([u]),4)
     rv = Cast(reform([v]),4)
     siu = size(ru)
     siv = size(rv)
 
     if siu(0) eq 1 and siv(0) eq 1 then begin
 	if n_elements(ru) ne n_elements(rv) then message, 'Unequal lengths!' $
 	else if Isnum(ru,/com) or Isnum(rv,/com) then ru = conj(ru)
     endif else message, 'Inputs must be vectors'
 
     return, FPU_fix((transpose(ru)#rv)(0))
 end
 
                                 *** VNORM ***                           

 Function Vnorm, r
 
 ;+
 ; NAME:
 ;	VNORM
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Finds the norm of a vector.
 ; CATEGORY:
 ;	Geometry, General.
 ; CALLING SEQUENCE:
 ;	Result = VNORM (R)
 ; INPUTS:
 ;    R
 ;	Vector, numeric, otherwise arbitrary.  Can be complex.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the norm of the vector R.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Calls ABS_MM, CAST, FPU_FIX and ISNUM from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 30-JUN-1992 by Mati Meron.
 ;	Modified and added to MIDL 5-NOV-1997 by Mati Meron.
 ;	Modified 10-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     if not Isnum(r) then message, 'Input must be numeric!' else $
     return, sqrt(total(FPU_fix(Abs_mm(Cast(r,4))^2)))
 end
 
                                  *** VOUP ***                            

 Function Voup, u, v
 
 ;+
 ; NAME:
 ;	VOUP
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Finds the outer product of two vectors.
 ; CATEGORY:
 ;	Geometry, General.
 ; CALLING SEQUENCE:
 ;	Result = VOUP ( U, V)
 ; INPUTS:
 ;    U, V
 ;	Vectors, numeric, otherwise arbitrary.  Scalars accepted as vectors of
 ;	length 1.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;	None.
 ; OUTPUTS:
 ;	Returns the outer product in Type FLOAT or higher.  for U of length M
 ;	and V of length N, the outer product is an array of dimension (M,N).
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Straightforward.  Uses CAST, FPU_FIX and ISNUM from MIDL.
 ;	Works also with complex vectors.
 ; MODIFICATION HISTORY:
 ;	Created 10-NOV-1997 by Mati Meron.
 ;	Modified 10-SEP-1998 by Mati Meron.  Underflow filtering added.
 ;-
 
     on_error, 1
     if not (Isnum(u) and Isnum(v)) then message, 'Not numeric vectors!'
 
     ru = Cast(reform([u]),4)
     rv = Cast(reform([v]),4)
     siu = size(ru)
     siv = size(rv)
 
     if siu(0) ne 1 or siv(0) ne 1 then message, 'Inputs must be vectors' $
     else if Isnum(ru,/com) or Isnum(rv,/com) then rv = conj(rv)
 
     return, FPU_fix(ru#transpose(rv))
 end
 
                                 *** WASCII ***                          

 Pro Wascii, arr, filnam, header = hed, format = form, _extra = _e
 
 ;+
 ; NAME:
 ;	WASCII
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Writes an array into an ASCII file.
 ; CATEGORY:
 ;	Input/Output.
 ; CALLING SEQUENCE:
 ;	WASCII, ARR, FILNAM [, keywords]
 ; INPUTS:
 ;    ARR
 ;	Array, arbitrary, no more than 8 columns.
 ;    FILNAM
 ;	Char. value, the name of the data file.  Default extension is '.DAT'.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    HEADER
 ;	Character array, optional, if provided, the entries are used as column
 ;	titles.  Null string entries translate to default column headings of
 ;	TABULATE.  If not provided, no column headers appear in the file.
 ;    FORMAT
 ;	Character string translating to a valid format.  If provided will apply
 ;	to all the columns.  If not provided. the default formats of TABULATE
 ;	are used.
 ;
 ;	In addition, all the TABULATE keywords are available.
 ; OUTPUTS:
 ;	None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;	None.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	The number of columns (first index of array) is limited.  See
 ;	restrictions in TABULATE.
 ; PROCEDURE:
 ;	Straightforward, using TABULATE from MIDL.  Also calls DEFAULT, and
 ;	TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 30-MAY-1996 by Mati Meron.
 ;	Modified 10-JUL-1997 by Mati Meron.  Name changed from WRITE_ASCII to
 ;	WASCII, to avoid potential conflicts with future IDL releases.
 ;-
 
     on_error, 1
     siz= size(arr)
     if siz(0) eq 1 or siz(0) eq 2 then nc = siz(1) else $
 	message, 'not a matrix!'
     if nc gt 8 then message, 'At most eight columns are allowed!'
 
     if Type(filnam) eq 7 then begin
 	if strpos(filnam,'.') eq -1 then ofil = filnam +'.dat' $
 	else ofil = filnam
     endif else message, 'filename must be provided!'
 
     ofor = Default(form,'',/dtype)
     nf = n_elements(ofor)
     if nf lt nc then ofor = [ofor,replicate(ofor(nf-1),nc-nf)]
 
     nohed = n_elements(hed) eq 0
 
     com = 'Tabulate, arr(0,*)'
     for i = 1, nc - 1 do com = com + ',arr(' + string(i,form="(i2)") +',*)'
     com = com + ', head= hed, nohead= nohed, form= ofor, file= ofil, _extra =_e'
     idum = execute(com)
     return
 end
 
                              *** WHERINSTRUCT ***                    

 Function Wherinstruct, tagnam, structnam, count, tags = tnam
 
 ;+
 ; NAME:
 ;	WHERINSTRUCT
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Finding fields within a structure.
 ; CATEGORY:
 ;	Programming.
 ; CALLING SEQUENCE:
 ;	Result = WHERINSTRUCT( TAGNAM, STRUCTNUM [, COUNT] [,TAGS = TNAM])
 ; INPUTS:
 ;    TAGNAM
 ;	Character variable or constant.
 ;    STRUCTNUM
 ;	Name of a structure variable.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    TAGS
 ;	Optional output, see below.
 ; OUTPUTS:
 ;	If STRUCTNAM exists, is a structure, and has one or more tag names
 ;	which match with TAGNAM, The return is a numeric (long integer) array
 ;	which includes the indices of the matching fields (similar to the
 ;	output of WHERE.  In all other cases the output is -1.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    COUNT
 ;	Same as in WHERE, returns the number of matches found.
 ;    TAGS
 ;	Accepts the name of the variable in which the names of the matching
 ;	fields are returned as a string array.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;	None.
 ; PROCEDURE:
 ;	Uses the system routine TAG_NAMES to find all the tag names of the
 ;	structure, and then uses STRMATCH_MM from MIDL to match these names
 ;	with the input TAGNAM.  The number of characters in TAGNAM determines
 ;	the number of characters used in the match.  For example, if
 ;	TAGNAM = 't' then all the names starting with 't' will be picked but if
 ;	TAGNAM = 'thor' then only those starting with 'thor' will be noticed.
 ;	Calls STRMATCH_MM and TYPE from MIDL.
 ; MODIFICATION HISTORY:
 ;	Created 15-JUN-1995 by Mati Meron.
 ;-
 
     on_error, 1
 
     res = -1l
     if Type(structnam) eq 8 then begin
 	tnam = tagnam
 	res = StrMatch_mm(tnam,tag_names(structnam),strlen(tagnam),/all)
     endif
     if res(0) eq -1 then begin
 	tnam = ''
 	count = 0
     endif else count = n_elements(res)
 
     return, res
 end
 
                                *** WIGGLINE ***                        

 Pro Wiggline, from = tail, to = head, $
     periods = per, amplitude = amp, phase = pha, exact = exc, $
     device = dev, normal = nor, no_show = nsh, shapeout = shap, _extra = _e
 
 ;+
 ; NAME:
 ;	WIGGLINE
 ; VERSION:
 ;	3.3
 ; PURPOSE:
 ;	Draws a "wiggly line" (a sinusoid, to be exact) in the current plot
 ;	area, from the FROM to the TO location (with a possible modification
 ;	due to PHASE .  DATA coordinates are used, unless one of the keywords
 ;	/DEVICE or /NORMAL is set.  Alternatively, a *SHAPE* representation
 ;	(see SHAPE_VER) for definition) of the wiggly line may be returned
 ;	through the SHAPEOUT keyword.  DATA coordinates are used unless one
 ;	of the keywords /DEVICE or /NORMAL is set.
 ; CATEGORY:
 ;	General Graphics.
 ; CALLING SEQUENCE:
 ;	WIGGLINE, FROM = tail, TO = head [, keywords]
 ; INPUTS:
 ;	None.
 ; OPTIONAL INPUT PARAMETERS:
 ;	None.
 ; KEYWORD PARAMETERS:
 ;    FROM
 ;	Two dimensional vector, start location, mandatory.
 ;    TO
 ;	Two dimensional vector, end location, mandatory.
 ;    PERIODS
 ;	Scalar, specifies number of wiggle periods.  Default value is 1.  Note
 ;	that if PERIODS isn't integer or half integer, the curve may miss the
 ;	point provided by TO.
 ;    AMPLITUDE
 ;	Scalar, specifies amplitude of oscillation, relative to
 ;	period_length/2*pi.  Default value is 1.
 ;    PHASE
 ;	Scalar, provides a phase offset, in fractions of a cycle. Default is 0.
 ;	Note that when the phase is not 0, the curve may be offset from the
 ;	points provided by FROM and TO.
 ;    /EXACT
 ;	Switch.  If set, PERIODS and PHASE are rounded to the nearest half-
 ;	integer, assuring that the curve will pass through both FROM and TO.
 ;    /DEVICE
 ;	Standard IDL plotting interpretation.
 ;    /NORMAL
 ;	Ditto.
 ;    /NO_SHOW
 ;	Switch.  If set, no plotting is done, but the shape is generated and
 ;	may be returned through SHAPEOUT.
 ;    SHAPEOUT
 ;	Optional output, see below.
 ;    _EXTRA
 ;       A formal keyword used to pass all plotting keywords.  Not to be used
 ;       directly.
 ; OUTPUTS:
 ;	None.
 ; OPTIONAL OUTPUT PARAMETERS:
 ;    SHAPEOUT
 ;	When provided with the name of a variable, on return the variable
 ;	contains the *SHAPE* representation of the wiggly line.
 ; COMMON BLOCKS:
 ;	None.
 ; SIDE EFFECTS:
 ;	None.
 ; RESTRICTIONS:
 ;       The keywords passed through _EXTRA are transferred to the PLOTS
 ;	routine.  No keyword verification is performed by WIGGLINE.
 ; PROCEDURE:
 ;	Uses DEFAULT, MAKE_GRID, ONE_OF, SHAPE_COCON and VNORM from MIDL.
 ;	All the coordinates are converted to DEVICE coordinates for shape
 ;	generation and plotting purposes.
 ; MODIFICATION HISTORY:
 ;	Created 1-SEP-1999 by Mati Meron.
 ;-
 
     on_error, 1
     per = Default(per,1.,/dtyp)
     amp = Default(amp,1.,/dtyp)
     wph = Default(pha,0.,/dtyp) mod 1
     if keyword_set(exc) then begin
 	per = round(2*per)/2.
 	wph = round(2*wph)/2.
     endif
 
     posib = ['DATA', 'DEVICE', 'NORMAL']
     sor = posib(1 + One_of(dev,nor))
 
     tem = Shape_cocon([[tail],[head]], from = sor, to = 'DEVICE')
     fro = tem(*,0)
     seg = tem(*,1) - tem(*,0)
     npo = 1 + 4*ceil(per*(sqrt(!pi*amp*Vnorm(seg)/(4*per)) > 1))
 
     s = Make_grid([0,1],npo)
     ss = amp/(2*!pi*per)*sin(2*!pi*(per*s + wph))
 
     wigl = transpose([[fro(0)+seg(0)*s-seg(1)*ss],[fro(1)+seg(1)*s+seg(0)*ss]])
 
     if not keyword_set(nsh) then plots, wigl, /device, _extra = _e
     shap = Shape_cocon(temporary(wigl), from = 'DEVICE', to = sor)
 
     return
 end
 
